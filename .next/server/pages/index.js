module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = require('../ssr-module-cache.js');
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pages/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../next-server/lib/router-context":
/*!**************************************************************!*\
  !*** external "next/dist/next-server/lib/router-context.js" ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next/dist/next-server/lib/router-context.js");

/***/ }),

/***/ "./components/cart.js":
/*!****************************!*\
  !*** ./components/cart.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-jsx/style */ "styled-jsx/style");
/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ "next/router");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reactstrap */ "reactstrap");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./context */ "./components/context.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);
var _jsxFileName = "C:\\Users\\Sophie\\Desktop\\mitCert\\Part3-BackEnd\\28Week-FullstackRestaurant1\\next-restaurant\\restaurant-app\\components\\cart.js";

var __jsx = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement;




 // we can pass cart data in via props method 
// the alternative is using useContext as below

function Cart() {
  let isAuthenticated = true;
  let {
    cart,
    addItem,
    removeItem
  } = Object(react__WEBPACK_IMPORTED_MODULE_1__["useContext"])(_context__WEBPACK_IMPORTED_MODULE_4__["default"]); //const [cartA, setCartA] = useState({cart})
  //cart = value.cart;
  //console.log('props:'+ JSON.stringify(value));

  console.log(`in CART: ${JSON.stringify(cart)}`); //   problem is that cart may not be set

  const router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"])();
  console.log(`Router Path: ${JSON.stringify(router)}`);

  const renderItems = () => {
    let {
      items
    } = cart;
    console.log(`items: ${JSON.stringify(items)}`);

    if (items && items.length) {
      var itemList = cart.items.map(item => {
        if (item.quantity > 0) {
          return __jsx("div", {
            className: "items-one",
            style: {
              marginBottom: 15
            },
            key: item.id,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 26,
              columnNumber: 15
            }
          }, __jsx("div", {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 31,
              columnNumber: 17
            }
          }, __jsx("span", {
            id: "item-price",
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 32,
              columnNumber: 19
            }
          }, "\xA0 $", item.price), __jsx("span", {
            id: "item-name",
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 33,
              columnNumber: 19
            }
          }, "\xA0 ", item.name)), __jsx("div", {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 35,
              columnNumber: 17
            }
          }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["Button"], {
            style: {
              height: 25,
              padding: 0,
              width: 15,
              marginRight: 5,
              marginLeft: 10
            },
            onClick: () => addItem(item),
            color: "link",
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 36,
              columnNumber: 19
            }
          }, "+"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["Button"], {
            style: {
              height: 25,
              padding: 0,
              width: 15,
              marginRight: 10
            },
            onClick: () => removeItem(item),
            color: "link",
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 49,
              columnNumber: 19
            }
          }, "-"), __jsx("span", {
            style: {
              marginLeft: 5
            },
            id: "item-quantity",
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 61,
              columnNumber: 19
            }
          }, item.quantity, "x")));
        }
      });
      return itemList;
    } else {
      return __jsx("div", {
        __self: this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 72,
          columnNumber: 17
        }
      });
    }
  };

  const checkoutItems = () => {
    return __jsx("div", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 77,
        columnNumber: 5
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["Badge"], {
      style: {
        width: 200,
        padding: 10
      },
      color: "light",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 7
      }
    }, __jsx("h5", {
      style: {
        fontWeight: 100,
        color: "gray"
      },
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 79,
        columnNumber: 9
      }
    }, "Total:"), __jsx("h3", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 80,
        columnNumber: 9
      }
    }, "$", cart.total)), __jsx(next_link__WEBPACK_IMPORTED_MODULE_5___default.a, {
      href: "/checkout/",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 82,
        columnNumber: 11
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["Button"], {
      style: {
        width: "60%"
      },
      color: "primary",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 83,
        columnNumber: 13
      }
    }, __jsx("a", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 84,
        columnNumber: 15
      }
    }, "Order"))));
  }; // return Cart


  return __jsx("div", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 92,
      columnNumber: 5
    }
  }, __jsx("h1", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 93,
      columnNumber: 7
    }
  }, " Cart"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["Card"], {
    style: {
      padding: "10px 5px"
    },
    className: "cart",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 7
    }
  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["CardTitle"], {
    style: {
      margin: 10
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 95,
      columnNumber: 9
    }
  }, "Your Order:"), __jsx("hr", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 96,
      columnNumber: 9
    }
  }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__["CardBody"], {
    style: {
      padding: 10
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 97,
      columnNumber: 9
    }
  }, __jsx("div", {
    style: {
      marginBottom: 6
    },
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 98,
      columnNumber: 11
    }
  }, __jsx("small", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 99,
      columnNumber: 13
    }
  }, "Items:")), __jsx("div", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 101,
      columnNumber: 11
    }
  }, renderItems()), __jsx("div", {
    className: "jsx-3161218026",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 104,
      columnNumber: 11
    }
  }, checkoutItems()), console.log(`Router Path: ${router.asPath}`))), __jsx(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default.a, {
    id: "3161218026",
    __self: this
  }, "#item-price.jsx-3161218026{font-size:1.3em;color:rgba(97,97,97,1);}#item-quantity.jsx-3161218026{font-size:0.95em;padding-bottom:4px;color:rgba(158,158,158,1);}#item-name.jsx-3161218026{font-size:1.3em;color:rgba(97,97,97,1);}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU29waGllXFxEZXNrdG9wXFxtaXRDZXJ0XFxQYXJ0My1CYWNrRW5kXFwyOFdlZWstRnVsbHN0YWNrUmVzdGF1cmFudDFcXG5leHQtcmVzdGF1cmFudFxccmVzdGF1cmFudC1hcHBcXGNvbXBvbmVudHNcXGNhcnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBOEdrQixBQUcyQixBQUlDLEFBS0QsZ0JBUlUsQUFTQSxDQUxQLG1CQUNVLEdBSi9CLEFBU0EsdUJBSkEiLCJmaWxlIjoiQzpcXFVzZXJzXFxTb3BoaWVcXERlc2t0b3BcXG1pdENlcnRcXFBhcnQzLUJhY2tFbmRcXDI4V2Vlay1GdWxsc3RhY2tSZXN0YXVyYW50MVxcbmV4dC1yZXN0YXVyYW50XFxyZXN0YXVyYW50LWFwcFxcY29tcG9uZW50c1xcY2FydC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgeyBCdXR0b24sIENhcmQsIENhcmRCb2R5LCBDYXJkVGl0bGUsIEJhZGdlIH0gZnJvbSBcInJlYWN0c3RyYXBcIjtcclxuaW1wb3J0IEFwcENvbnRleHQgZnJvbSBcIi4vY29udGV4dFwiXHJcbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIlxyXG4vLyB3ZSBjYW4gcGFzcyBjYXJ0IGRhdGEgaW4gdmlhIHByb3BzIG1ldGhvZCBcclxuLy8gdGhlIGFsdGVybmF0aXZlIGlzIHVzaW5nIHVzZUNvbnRleHQgYXMgYmVsb3dcclxuZnVuY3Rpb24gQ2FydCgpIHtcclxuICBsZXQgaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcclxuICBsZXQge2NhcnQsYWRkSXRlbSxyZW1vdmVJdGVtfSA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XHJcbiAgLy9jb25zdCBbY2FydEEsIHNldENhcnRBXSA9IHVzZVN0YXRlKHtjYXJ0fSlcclxuICAvL2NhcnQgPSB2YWx1ZS5jYXJ0O1xyXG4gIC8vY29uc29sZS5sb2coJ3Byb3BzOicrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgY29uc29sZS5sb2coYGluIENBUlQ6ICR7SlNPTi5zdHJpbmdpZnkoY2FydCl9YClcclxuICBcclxuICAvLyAgIHByb2JsZW0gaXMgdGhhdCBjYXJ0IG1heSBub3QgYmUgc2V0XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgY29uc29sZS5sb2coYFJvdXRlciBQYXRoOiAke0pTT04uc3RyaW5naWZ5KHJvdXRlcil9YClcclxuICBjb25zdCByZW5kZXJJdGVtcyA9ICgpPT57XHJcbiAgbGV0IHtpdGVtc30gPSBjYXJ0O1xyXG4gICBjb25zb2xlLmxvZyhgaXRlbXM6ICR7SlNPTi5zdHJpbmdpZnkoaXRlbXMpfWApXHJcbiAgICBpZihpdGVtcyAmJiBpdGVtcy5sZW5ndGgpe1xyXG4gICAgICB2YXIgaXRlbUxpc3QgPSBjYXJ0Lml0ZW1zLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGl0ZW0ucXVhbnRpdHkgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaXRlbXMtb25lXCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogMTUgfX1cclxuICAgICAgICAgICAgICAgIGtleT17aXRlbS5pZH1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cIml0ZW0tcHJpY2VcIj4mbmJzcDsgJHtpdGVtLnByaWNlfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9XCJpdGVtLW5hbWVcIj4mbmJzcDsge2l0ZW0ubmFtZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNSxcclxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogNSxcclxuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gYWRkSXRlbShpdGVtKX1cclxuICAgICAgICAgICAgICAgICAgICBjb2xvcj1cImxpbmtcIlxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgK1xyXG4gICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAxMCxcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJlbW92ZUl0ZW0oaXRlbSl9XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJsaW5rXCJcclxuICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIC1cclxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6IDUgfX0gaWQ9XCJpdGVtLXF1YW50aXR5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAge2l0ZW0ucXVhbnRpdHl9eFxyXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBpdGVtTGlzdDtcclxuICAgICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICg8ZGl2PjwvZGl2PilcclxuICAgIH1cclxuICB9XHJcbmNvbnN0IGNoZWNrb3V0SXRlbXMgPSAoKT0+e1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICA8QmFkZ2Ugc3R5bGU9e3sgd2lkdGg6IDIwMCwgcGFkZGluZzogMTAgfX0gY29sb3I9XCJsaWdodFwiPlxyXG4gICAgICAgIDxoNSBzdHlsZT17eyBmb250V2VpZ2h0OiAxMDAsIGNvbG9yOiBcImdyYXlcIiB9fT5Ub3RhbDo8L2g1PlxyXG4gICAgICAgIDxoMz4ke2NhcnQudG90YWx9PC9oMz5cclxuICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvY2hlY2tvdXQvXCI+XHJcbiAgICAgICAgICAgIDxCdXR0b24gc3R5bGU9e3sgd2lkdGg6IFwiNjAlXCIgfX0gY29sb3I9XCJwcmltYXJ5XCI+XHJcbiAgICAgICAgICAgICAgPGE+T3JkZXI8L2E+XHJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgPC9MaW5rPlxyXG4gICAgPC9kaXY+XHJcbiAgKX1cclxuXHJcbi8vIHJldHVybiBDYXJ0XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIDxoMT4gQ2FydDwvaDE+XHJcbiAgICAgIDxDYXJkIHN0eWxlPXt7IHBhZGRpbmc6IFwiMTBweCA1cHhcIiB9fSBjbGFzc05hbWU9XCJjYXJ0XCI+XHJcbiAgICAgICAgPENhcmRUaXRsZSBzdHlsZT17eyBtYXJnaW46IDEwIH19PllvdXIgT3JkZXI6PC9DYXJkVGl0bGU+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPENhcmRCb2R5IHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19PlxyXG4gICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDYgfX0+XHJcbiAgICAgICAgICAgIDxzbWFsbD5JdGVtczo8L3NtYWxsPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICB7cmVuZGVySXRlbXMoKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAge2NoZWNrb3V0SXRlbXMoKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB7Y29uc29sZS5sb2coYFJvdXRlciBQYXRoOiAke3JvdXRlci5hc1BhdGh9YCl9XHJcbiAgICAgICAgPC9DYXJkQm9keT5cclxuICAgICAgPC9DYXJkPlxyXG4gICAgICA8c3R5bGUganN4PntgXHJcbiAgICAgICAgI2l0ZW0tcHJpY2Uge1xyXG4gICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcclxuICAgICAgICAgIGNvbG9yOiByZ2JhKDk3LCA5NywgOTcsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAjaXRlbS1xdWFudGl0eSB7XHJcbiAgICAgICAgICBmb250LXNpemU6IDAuOTVlbTtcclxuICAgICAgICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XHJcbiAgICAgICAgICBjb2xvcjogcmdiYSgxNTgsIDE1OCwgMTU4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgI2l0ZW0tbmFtZSB7XHJcbiAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xyXG4gICAgICAgICAgY29sb3I6IHJnYmEoOTcsIDk3LCA5NywgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICBgfTwvc3R5bGU+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IENhcnQ7Il19 */\n/*@ sourceURL=C:\\\\Users\\\\Sophie\\\\Desktop\\\\mitCert\\\\Part3-BackEnd\\\\28Week-FullstackRestaurant1\\\\next-restaurant\\\\restaurant-app\\\\components\\\\cart.js */"));
}

/* harmony default export */ __webpack_exports__["default"] = (Cart);

/***/ }),

/***/ "./components/context.js":
/*!*******************************!*\
  !*** ./components/context.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* /context/AppContext.js */
 // create auth context with default value
// set backup default for isAuthenticated if none is provided in Provider

const AppContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({
  isAuthenticated: true,
  cart: {
    items: [],
    total: 0
  },
  addItem: () => {},
  removeItem: () => {},
  user: false,
  setUser: () => {}
});
/* harmony default export */ __webpack_exports__["default"] = (AppContext);

/***/ }),

/***/ "./components/dishes.js":
/*!******************************!*\
  !*** ./components/dishes.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ "next/router");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @apollo/client */ "./node_modules/@apollo/client/main.cjs");
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "./components/context.js");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ "reactstrap");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "C:\\Users\\Sophie\\Desktop\\mitCert\\Part3-BackEnd\\28Week-FullstackRestaurant1\\next-restaurant\\restaurant-app\\components\\dishes.js";

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






function Dishes({
  restId
}) {
  const {
    0: restaurantID,
    1: setRestaurantID
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])();
  const {
    addItem
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_context__WEBPACK_IMPORTED_MODULE_3__["default"]);
  const GET_RESTAURANT_DISHES = _apollo_client__WEBPACK_IMPORTED_MODULE_2__["gql"]`
  query($id: ID!) {
    restaurant(id: $id) {
      id
      name
      dishes {
        id
        name
        description
        price
        image {
          url
        }
      }
    }
  }
`;
  const router = Object(next_router__WEBPACK_IMPORTED_MODULE_1__["useRouter"])();
  const {
    loading,
    error,
    data
  } = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_2__["useQuery"])(GET_RESTAURANT_DISHES, {
    variables: {
      id: restId
    }
  });
  if (loading) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 23
    }
  }, "Loading...");
  if (error) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 21
    }
  }, "ERROR here");
  if (!data) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 21
    }
  }, "Not found");
  let restaurant = data.restaurant;

  if (restId > 0) {
    return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, restaurant.dishes.map(res => __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Col"], {
      xs: "6",
      sm: "4",
      style: {
        padding: 0
      },
      key: res.id,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 53,
        columnNumber: 13
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Card"], {
      style: {
        margin: "0 10px"
      },
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 15
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardImg"], {
      top: true,
      style: {
        height: 150,
        width: 150
      },
      src: `http://localhost:1337${res.image.url}`,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 55,
        columnNumber: 17
      }
    }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardBody"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 60,
        columnNumber: 17
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardTitle"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 61,
        columnNumber: 19
      }
    }, res.name), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardText"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 62,
        columnNumber: 19
      }
    }, res.description)), __jsx("div", {
      className: "card-footer",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 64,
        columnNumber: 17
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Button"], {
      color: "info",
      onClick: () => addItem(res),
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 65,
        columnNumber: 19
      }
    }, "+ Add To Cart"))))));
  } else {
    return __jsx("h1", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 18
      }
    }, " No Dishes");
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Dishes);

/***/ }),

/***/ "./components/restaurantList.js":
/*!**************************************!*\
  !*** ./components/restaurantList.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @apollo/client */ "./node_modules/@apollo/client/main.cjs");
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dishes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dishes */ "./components/dishes.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "./components/context.js");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ "reactstrap");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "C:\\Users\\Sophie\\Desktop\\mitCert\\Part3-BackEnd\\28Week-FullstackRestaurant1\\next-restaurant\\restaurant-app\\components\\restaurantList.js";

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






function RestaurantList(props) {
  const {
    0: restaurantID,
    1: setRestaurantID
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0);
  const {
    cart
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_context__WEBPACK_IMPORTED_MODULE_3__["default"]);
  const {
    0: state,
    1: setState
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(cart);
  const GET_RESTAURANTS = _apollo_client__WEBPACK_IMPORTED_MODULE_1__["gql"]`
    query {
      restaurants {
        id
        name
        description
        image {
          url
        }
      }
    }
  `;
  const {
    loading,
    error,
    data
  } = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_1__["useQuery"])(GET_RESTAURANTS);
  if (loading) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 23
    }
  }, "Loading...");
  if (error) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 21
    }
  }, "ERROR");
  if (!data) return __jsx("p", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 21
    }
  }, "Not found");
  console.log(`Query Data: ${data.restaurants}`);
  let searchQuery = data.restaurants.filter(res => {
    return res.name.toLowerCase().includes(props.search);
  }) || [];
  let restId = searchQuery[0] ? searchQuery[0].id : null; // definet renderer for Dishes

  const renderDishes = restaurantID => {
    return __jsx(_dishes__WEBPACK_IMPORTED_MODULE_2__["default"], {
      restId: restaurantID,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 13
      }
    }, " ");
  };

  if (searchQuery.length > 0) {
    const restList = searchQuery.map(res => __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Col"], {
      xs: "6",
      sm: "4",
      key: res.id,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 7
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Card"], {
      style: {
        margin: "0 0.5rem 20px 0.5rem"
      },
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 55,
        columnNumber: 9
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardImg"], {
      top: true,
      style: {
        height: 200
      },
      src: `http://localhost:1337` + res.image.url,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 56,
        columnNumber: 11
      }
    }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardBody"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 63,
        columnNumber: 11
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["CardText"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 64,
        columnNumber: 13
      }
    }, res.description)), __jsx("div", {
      className: "card-footer",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 11
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Button"], {
      color: "info",
      onClick: () => setRestaurantID(res.id),
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 68,
        columnNumber: 13
      }
    }, res.name)))));
    return __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Container"], {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 77,
        columnNumber: 7
      }
    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Row"], {
      xs: "3",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 9
      }
    }, restList), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Row"], {
      xs: "3",
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 82,
        columnNumber: 9
      }
    }, renderDishes(restaurantID)));
  } else {
    return __jsx("h1", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 90,
        columnNumber: 12
      }
    }, " No Restaurants Found");
  }
}

/* harmony default export */ __webpack_exports__["default"] = (RestaurantList);

/***/ }),

/***/ "./node_modules/@apollo/client/cache/cache.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/cache/cache.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var optimism = __webpack_require__(/*! optimism */ "optimism");
var utilities = __webpack_require__(/*! ../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");
var equality = __webpack_require__(/*! @wry/equality */ "@wry/equality");
var trie = __webpack_require__(/*! @wry/trie */ "@wry/trie");
var context = __webpack_require__(/*! @wry/context */ "@wry/context");

var ApolloCache = (function () {
    function ApolloCache() {
        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument);
    }
    ApolloCache.prototype.batch = function (options) {
        var _this = this;
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic :
            options.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function () { return updateResult = options.update(_this); }, optimisticId);
        return updateResult;
    };
    ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
    };
    ApolloCache.prototype.transformDocument = function (document) {
        return document;
    };
    ApolloCache.prototype.identify = function (object) {
        return;
    };
    ApolloCache.prototype.gc = function () {
        return [];
    };
    ApolloCache.prototype.modify = function (options) {
        return false;
    };
    ApolloCache.prototype.transformForLink = function (document) {
        return document;
    };
    ApolloCache.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = !!options.optimistic; }
        return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || 'ROOT_QUERY', optimistic: optimistic }));
    };
    ApolloCache.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = !!options.optimistic; }
        return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic: optimistic }));
    };
    ApolloCache.prototype.writeQuery = function (_a) {
        var id = _a.id, data = _a.data, options = tslib.__rest(_a, ["id", "data"]);
        return this.write(Object.assign(options, {
            dataId: id || 'ROOT_QUERY',
            result: data,
        }));
    };
    ApolloCache.prototype.writeFragment = function (_a) {
        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = tslib.__rest(_a, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
            query: this.getFragmentDoc(fragment, fragmentName),
            dataId: id,
            result: data,
        }));
    };
    ApolloCache.prototype.updateQuery = function (options, update) {
        return this.batch({
            update: function (cache) {
                var value = cache.readQuery(options);
                var data = update(value);
                if (data === void 0 || data === null)
                    return value;
                cache.writeQuery(tslib.__assign(tslib.__assign({}, options), { data: data }));
                return data;
            },
        });
    };
    ApolloCache.prototype.updateFragment = function (options, update) {
        return this.batch({
            update: function (cache) {
                var value = cache.readFragment(options);
                var data = update(value);
                if (data === void 0 || data === null)
                    return value;
                cache.writeFragment(tslib.__assign(tslib.__assign({}, options), { data: data }));
                return data;
            },
        });
    };
    return ApolloCache;
}());

exports.Cache = void 0;
(function (Cache) {
})(exports.Cache || (exports.Cache = {}));

var MissingFieldError = (function () {
    function MissingFieldError(message, path, query, variables) {
        this.message = message;
        this.path = path;
        this.query = query;
        this.variables = variables;
    }
    return MissingFieldError;
}());

var hasOwn = Object.prototype.hasOwnProperty;
function defaultDataIdFromObject(_a, context) {
    var __typename = _a.__typename, id = _a.id, _id = _a._id;
    if (typeof __typename === "string") {
        if (context) {
            context.keyObject =
                id !== void 0 ? { id: id } :
                    _id !== void 0 ? { _id: _id } :
                        void 0;
        }
        if (id === void 0)
            id = _id;
        if (id !== void 0) {
            return "".concat(__typename, ":").concat((typeof id === "number" ||
                typeof id === "string") ? id : JSON.stringify(id));
        }
    }
}
var defaultConfig = {
    dataIdFromObject: defaultDataIdFromObject,
    addTypename: true,
    resultCaching: true,
    canonizeResults: false,
};
function normalizeConfig(config) {
    return utilities.compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
    var value = config.canonizeResults;
    return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
    return utilities.isReference(objectOrReference)
        ? store.get(objectOrReference.__ref, "__typename")
        : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
    var match = storeFieldName.match(TypeOrFieldNameRegExp);
    return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
    if (utilities.isNonNullObject(result)) {
        return isArray(result)
            ? result.every(function (item) { return selectionSetMatchesResult(selectionSet, item, variables); })
            : selectionSet.selections.every(function (field) {
                if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
                    var key = utilities.resultKeyNameFromField(field);
                    return hasOwn.call(result, key) &&
                        (!field.selectionSet ||
                            selectionSetMatchesResult(field.selectionSet, result[key], variables));
                }
                return true;
            });
    }
    return false;
}
function storeValueIsStoreObject(value) {
    return utilities.isNonNullObject(value) &&
        !utilities.isReference(value) &&
        !isArray(value);
}
function makeProcessedFieldsMerger() {
    return new utilities.DeepMerger;
}
var isArray = function (a) { return Array.isArray(a); };

var DELETE = Object.create(null);
var delModifier = function () { return DELETE; };
var INVALIDATE = Object.create(null);
exports.EntityStore = (function () {
    function EntityStore(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = Object.create(null);
        this.rootIds = Object.create(null);
        this.refs = Object.create(null);
        this.getFieldValue = function (objectOrReference, storeFieldName) { return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference)
            ? _this.get(objectOrReference.__ref, storeFieldName)
            : objectOrReference && objectOrReference[storeFieldName]); };
        this.canRead = function (objOrRef) {
            return utilities.isReference(objOrRef)
                ? _this.has(objOrRef.__ref)
                : typeof objOrRef === "object";
        };
        this.toReference = function (objOrIdOrRef, mergeIntoStore) {
            if (typeof objOrIdOrRef === "string") {
                return utilities.makeReference(objOrIdOrRef);
            }
            if (utilities.isReference(objOrIdOrRef)) {
                return objOrIdOrRef;
            }
            var id = _this.policies.identify(objOrIdOrRef)[0];
            if (id) {
                var ref = utilities.makeReference(id);
                if (mergeIntoStore) {
                    _this.merge(id, objOrIdOrRef);
                }
                return ref;
            }
        };
    }
    EntityStore.prototype.toObject = function () {
        return tslib.__assign({}, this.data);
    };
    EntityStore.prototype.has = function (dataId) {
        return this.lookup(dataId, true) !== void 0;
    };
    EntityStore.prototype.get = function (dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn.call(this.data, dataId)) {
            var storeObject = this.data[dataId];
            if (storeObject && hasOwn.call(storeObject, fieldName)) {
                return storeObject[fieldName];
            }
        }
        if (fieldName === "__typename" &&
            hasOwn.call(this.policies.rootTypenamesById, dataId)) {
            return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
            return this.parent.get(dataId, fieldName);
        }
    };
    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {
        if (dependOnExistence)
            this.group.depend(dataId, "__exists");
        if (hasOwn.call(this.data, dataId)) {
            return this.data[dataId];
        }
        if (this instanceof Layer) {
            return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
            return Object.create(null);
        }
    };
    EntityStore.prototype.merge = function (older, newer) {
        var _this = this;
        var dataId;
        if (utilities.isReference(older))
            older = older.__ref;
        if (utilities.isReference(newer))
            newer = newer.__ref;
        var existing = typeof older === "string"
            ? this.lookup(dataId = older)
            : older;
        var incoming = typeof newer === "string"
            ? this.lookup(dataId = newer)
            : newer;
        if (!incoming)
            return;
        __DEV__ ? globals.invariant(typeof dataId === "string", "store.merge expects a string ID") : globals.invariant(typeof dataId === "string", 1);
        var merged = new utilities.DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
            delete this.refs[dataId];
            if (this.group.caching) {
                var fieldsToDirty_1 = Object.create(null);
                if (!existing)
                    fieldsToDirty_1.__exists = 1;
                Object.keys(incoming).forEach(function (storeFieldName) {
                    if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                        fieldsToDirty_1[storeFieldName] = 1;
                        var fieldName = fieldNameFromStoreName(storeFieldName);
                        if (fieldName !== storeFieldName &&
                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                            fieldsToDirty_1[fieldName] = 1;
                        }
                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                            delete merged[storeFieldName];
                        }
                    }
                });
                if (fieldsToDirty_1.__typename &&
                    !(existing && existing.__typename) &&
                    this.policies.rootTypenamesById[dataId] === merged.__typename) {
                    delete fieldsToDirty_1.__typename;
                }
                Object.keys(fieldsToDirty_1).forEach(function (fieldName) { return _this.group.dirty(dataId, fieldName); });
            }
        }
    };
    EntityStore.prototype.modify = function (dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
            var changedFields_1 = Object.create(null);
            var needToMerge_1 = false;
            var allDeleted_1 = true;
            var sharedDetails_1 = {
                DELETE: DELETE,
                INVALIDATE: INVALIDATE,
                isReference: utilities.isReference,
                toReference: this.toReference,
                canRead: this.canRead,
                readField: function (fieldNameOrOptions, from) { return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                    fieldName: fieldNameOrOptions,
                    from: from || utilities.makeReference(dataId),
                } : fieldNameOrOptions, { store: _this }); },
            };
            Object.keys(storeObject).forEach(function (storeFieldName) {
                var fieldName = fieldNameFromStoreName(storeFieldName);
                var fieldValue = storeObject[storeFieldName];
                if (fieldValue === void 0)
                    return;
                var modify = typeof fields === "function"
                    ? fields
                    : fields[storeFieldName] || fields[fieldName];
                if (modify) {
                    var newValue = modify === delModifier ? DELETE :
                        modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
                    if (newValue === INVALIDATE) {
                        _this.group.dirty(dataId, storeFieldName);
                    }
                    else {
                        if (newValue === DELETE)
                            newValue = void 0;
                        if (newValue !== fieldValue) {
                            changedFields_1[storeFieldName] = newValue;
                            needToMerge_1 = true;
                            fieldValue = newValue;
                        }
                    }
                }
                if (fieldValue !== void 0) {
                    allDeleted_1 = false;
                }
            });
            if (needToMerge_1) {
                this.merge(dataId, changedFields_1);
                if (allDeleted_1) {
                    if (this instanceof Layer) {
                        this.data[dataId] = void 0;
                    }
                    else {
                        delete this.data[dataId];
                    }
                    this.group.dirty(dataId, "__exists");
                }
                return true;
            }
        }
        return false;
    };
    EntityStore.prototype.delete = function (dataId, fieldName, args) {
        var _a;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
            var typename = this.getFieldValue(storeObject, "__typename");
            var storeFieldName = fieldName && args
                ? this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })
                : fieldName;
            return this.modify(dataId, storeFieldName ? (_a = {},
                _a[storeFieldName] = delModifier,
                _a) : delModifier);
        }
        return false;
    };
    EntityStore.prototype.evict = function (options, limit) {
        var evicted = false;
        if (options.id) {
            if (hasOwn.call(this.data, options.id)) {
                evicted = this.delete(options.id, options.fieldName, options.args);
            }
            if (this instanceof Layer && this !== limit) {
                evicted = this.parent.evict(options, limit) || evicted;
            }
            if (options.fieldName || evicted) {
                this.group.dirty(options.id, options.fieldName || "__exists");
            }
        }
        return evicted;
    };
    EntityStore.prototype.clear = function () {
        this.replace(null);
    };
    EntityStore.prototype.extract = function () {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function (id) {
            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
                extraRootIds.push(id);
            }
        });
        if (extraRootIds.length) {
            obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
    };
    EntityStore.prototype.replace = function (newData) {
        var _this = this;
        Object.keys(this.data).forEach(function (dataId) {
            if (!(newData && hasOwn.call(newData, dataId))) {
                _this.delete(dataId);
            }
        });
        if (newData) {
            var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
            Object.keys(rest_1).forEach(function (dataId) {
                _this.merge(dataId, rest_1[dataId]);
            });
            if (__META) {
                __META.extraRootIds.forEach(this.retain, this);
            }
        }
    };
    EntityStore.prototype.retain = function (rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore.prototype.release = function (rootId) {
        if (this.rootIds[rootId] > 0) {
            var count = --this.rootIds[rootId];
            if (!count)
                delete this.rootIds[rootId];
            return count;
        }
        return 0;
    };
    EntityStore.prototype.getRootIdSet = function (ids) {
        if (ids === void 0) { ids = new Set(); }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
            this.parent.getRootIdSet(ids);
        }
        else {
            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
    };
    EntityStore.prototype.gc = function () {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function (id) {
            if (hasOwn.call(snapshot, id)) {
                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                delete snapshot[id];
            }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
            var root_1 = this;
            while (root_1 instanceof Layer)
                root_1 = root_1.parent;
            idsToRemove.forEach(function (id) { return root_1.delete(id); });
        }
        return idsToRemove;
    };
    EntityStore.prototype.findChildRefIds = function (dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
            var found_1 = this.refs[dataId] = Object.create(null);
            var root = this.data[dataId];
            if (!root)
                return found_1;
            var workSet_1 = new Set([root]);
            workSet_1.forEach(function (obj) {
                if (utilities.isReference(obj)) {
                    found_1[obj.__ref] = true;
                }
                if (utilities.isNonNullObject(obj)) {
                    Object.keys(obj).forEach(function (key) {
                        var child = obj[key];
                        if (utilities.isNonNullObject(child)) {
                            workSet_1.add(child);
                        }
                    });
                }
            });
        }
        return this.refs[dataId];
    };
    EntityStore.prototype.makeCacheKey = function () {
        return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore;
}());
var CacheGroup = (function () {
    function CacheGroup(caching, parent) {
        if (parent === void 0) { parent = null; }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
    }
    CacheGroup.prototype.resetCaching = function () {
        this.d = this.caching ? optimism.dep() : null;
        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
    };
    CacheGroup.prototype.depend = function (dataId, storeFieldName) {
        if (this.d) {
            this.d(makeDepKey(dataId, storeFieldName));
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName) {
                this.d(makeDepKey(dataId, fieldName));
            }
            if (this.parent) {
                this.parent.depend(dataId, storeFieldName);
            }
        }
    };
    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {
        if (this.d) {
            this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
        }
    };
    return CacheGroup;
}());
function makeDepKey(dataId, storeFieldName) {
    return storeFieldName + '#' + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
    if (supportsResultCaching(store)) {
        store.group.depend(entityId, "__exists");
    }
}
(function (EntityStore) {
    var Root = (function (_super) {
        tslib.__extends(Root, _super);
        function Root(_a) {
            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
            _this.stump = new Stump(_this);
            _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
            if (seed)
                _this.replace(seed);
            return _this;
        }
        Root.prototype.addLayer = function (layerId, replay) {
            return this.stump.addLayer(layerId, replay);
        };
        Root.prototype.removeLayer = function () {
            return this;
        };
        Root.prototype.getStorage = function () {
            return this.storageTrie.lookupArray(arguments);
        };
        return Root;
    }(EntityStore));
    EntityStore.Root = Root;
})(exports.EntityStore || (exports.EntityStore = {}));
var Layer = (function (_super) {
    tslib.__extends(Layer, _super);
    function Layer(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
    }
    Layer.prototype.addLayer = function (layerId, replay) {
        return new Layer(layerId, this, replay, this.group);
    };
    Layer.prototype.removeLayer = function (layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
            if (this.group.caching) {
                Object.keys(this.data).forEach(function (dataId) {
                    var ownStoreObject = _this.data[dataId];
                    var parentStoreObject = parent["lookup"](dataId);
                    if (!parentStoreObject) {
                        _this.delete(dataId);
                    }
                    else if (!ownStoreObject) {
                        _this.group.dirty(dataId, "__exists");
                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {
                            _this.group.dirty(dataId, storeFieldName);
                        });
                    }
                    else if (ownStoreObject !== parentStoreObject) {
                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {
                            if (!equality.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                                _this.group.dirty(dataId, storeFieldName);
                            }
                        });
                    }
                });
            }
            return parent;
        }
        if (parent === this.parent)
            return this;
        return parent.addLayer(this.id, this.replay);
    };
    Layer.prototype.toObject = function () {
        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
    };
    Layer.prototype.findChildRefIds = function (dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer.prototype.getStorage = function () {
        var p = this.parent;
        while (p.parent)
            p = p.parent;
        return p.getStorage.apply(p, arguments);
    };
    return Layer;
}(exports.EntityStore));
var Stump = (function (_super) {
    tslib.__extends(Stump, _super);
    function Stump(root) {
        return _super.call(this, "EntityStore.Stump", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;
    }
    Stump.prototype.removeLayer = function () {
        return this;
    };
    Stump.prototype.merge = function () {
        return this.parent.merge.apply(this.parent, arguments);
    };
    return Stump;
}(Layer));
function storeObjectReconciler(existingObject, incomingObject, property) {
    var existingValue = existingObject[property];
    var incomingValue = incomingObject[property];
    return equality.equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
    return !!(store instanceof exports.EntityStore && store.group.caching);
}

function shallowCopy(value) {
    if (utilities.isNonNullObject(value)) {
        return isArray(value)
            ? value.slice(0)
            : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
    }
    return value;
}
var ObjectCanon = (function () {
    function ObjectCanon() {
        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.pool = new trie.Trie(utilities.canUseWeakMap);
        this.passes = new WeakMap();
        this.keysByJSON = new Map();
        this.empty = this.admit({});
    }
    ObjectCanon.prototype.isKnown = function (value) {
        return utilities.isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon.prototype.pass = function (value) {
        if (utilities.isNonNullObject(value)) {
            var copy = shallowCopy(value);
            this.passes.set(copy, value);
            return copy;
        }
        return value;
    };
    ObjectCanon.prototype.admit = function (value) {
        var _this = this;
        if (utilities.isNonNullObject(value)) {
            var original = this.passes.get(value);
            if (original)
                return original;
            var proto = Object.getPrototypeOf(value);
            switch (proto) {
                case Array.prototype: {
                    if (this.known.has(value))
                        return value;
                    var array = value.map(this.admit, this);
                    var node = this.pool.lookupArray(array);
                    if (!node.array) {
                        this.known.add(node.array = array);
                        if (__DEV__) {
                            Object.freeze(array);
                        }
                    }
                    return node.array;
                }
                case null:
                case Object.prototype: {
                    if (this.known.has(value))
                        return value;
                    var proto_1 = Object.getPrototypeOf(value);
                    var array_1 = [proto_1];
                    var keys = this.sortedKeys(value);
                    array_1.push(keys.json);
                    var firstValueIndex_1 = array_1.length;
                    keys.sorted.forEach(function (key) {
                        array_1.push(_this.admit(value[key]));
                    });
                    var node = this.pool.lookupArray(array_1);
                    if (!node.object) {
                        var obj_1 = node.object = Object.create(proto_1);
                        this.known.add(obj_1);
                        keys.sorted.forEach(function (key, i) {
                            obj_1[key] = array_1[firstValueIndex_1 + i];
                        });
                        if (__DEV__) {
                            Object.freeze(obj_1);
                        }
                    }
                    return node.object;
                }
            }
        }
        return value;
    };
    ObjectCanon.prototype.sortedKeys = function (obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
            keys.sort();
            var json = JSON.stringify(keys);
            if (!(node.keys = this.keysByJSON.get(json))) {
                this.keysByJSON.set(json, node.keys = { sorted: keys, json: json });
            }
        }
        return node.keys;
    };
    return ObjectCanon;
}());
var canonicalStringify = Object.assign(function (value) {
    if (utilities.isNonNullObject(value)) {
        if (stringifyCanon === void 0) {
            resetCanonicalStringify();
        }
        var canonical = stringifyCanon.admit(value);
        var json = stringifyCache.get(canonical);
        if (json === void 0) {
            stringifyCache.set(canonical, json = JSON.stringify(canonical));
        }
        return json;
    }
    return JSON.stringify(value);
}, {
    reset: resetCanonicalStringify,
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
    stringifyCanon = new ObjectCanon;
    stringifyCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
}

function execSelectionSetKeyArgs(options) {
    return [
        options.selectionSet,
        options.objectOrReference,
        options.context,
        options.context.canonizeResults,
    ];
}
var StoreReader = (function () {
    function StoreReader(config) {
        var _this = this;
        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.config = utilities.compact(config, {
            addTypename: config.addTypename !== false,
            canonizeResults: shouldCanonizeResults(config),
        });
        this.canon = config.canon || new ObjectCanon;
        this.executeSelectionSet = optimism.wrap(function (options) {
            var _a;
            var canonizeResults = options.context.canonizeResults;
            var peekArgs = execSelectionSetKeyArgs(options);
            peekArgs[3] = !canonizeResults;
            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
            if (other) {
                if (canonizeResults) {
                    return tslib.__assign(tslib.__assign({}, other), { result: _this.canon.admit(other.result) });
                }
                return other;
            }
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSelectionSetImpl(options);
        }, {
            max: this.config.resultCacheMaxSize,
            keyArgs: execSelectionSetKeyArgs,
            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {
                if (supportsResultCaching(context.store)) {
                    return context.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
                }
            }
        });
        this.executeSubSelectedArray = optimism.wrap(function (options) {
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSubSelectedArrayImpl(options);
        }, {
            max: this.config.resultCacheMaxSize,
            makeCacheKey: function (_a) {
                var field = _a.field, array = _a.array, context = _a.context;
                if (supportsResultCaching(context.store)) {
                    return context.store.makeCacheKey(field, array, context.varString);
                }
            }
        });
    }
    StoreReader.prototype.resetCanon = function () {
        this.canon = new ObjectCanon;
    };
    StoreReader.prototype.diffQueryAgainstStore = function (_a) {
        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? 'ROOT_QUERY' : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
        var rootRef = utilities.makeReference(rootId);
        var execResult = this.executeSelectionSet({
            selectionSet: utilities.getMainDefinition(query).selectionSet,
            objectOrReference: rootRef,
            enclosingRef: rootRef,
            context: {
                store: store,
                query: query,
                policies: policies,
                variables: variables,
                varString: canonicalStringify(variables),
                canonizeResults: canonizeResults,
                fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
            },
        });
        var missing;
        if (execResult.missing) {
            missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];
            if (!returnPartialData) {
                throw missing[0];
            }
        }
        return {
            result: execResult.result,
            complete: !missing,
            missing: missing,
        };
    };
    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {
        if (supportsResultCaching(context.store) &&
            this.knownResults.get(result) === selectionSet) {
            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));
            if (latest && result === latest.result) {
                return true;
            }
        }
        return false;
    };
    StoreReader.prototype.execSelectionSetImpl = function (_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;
        if (utilities.isReference(objectOrReference) &&
            !context.policies.rootTypenamesById[objectOrReference.__ref] &&
            !context.store.has(objectOrReference.__ref)) {
            return {
                result: this.canon.empty,
                missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object"),
            };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new utilities.DeepMerger();
        if (this.config.addTypename &&
            typeof typename === "string" &&
            !policies.rootIdsByTypename[typename]) {
            objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result, resultName) {
            var _a;
            if (result.missing) {
                missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));
            }
            return result.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function (selection) {
            var _a, _b;
            if (!utilities.shouldInclude(selection, variables))
                return;
            if (utilities.isField(selection)) {
                var fieldValue = policies.readField({
                    fieldName: selection.name.value,
                    field: selection,
                    variables: context.variables,
                    from: objectOrReference,
                }, context);
                var resultName = utilities.resultKeyNameFromField(selection);
                if (fieldValue === void 0) {
                    if (!utilities.addTypenameToDocument.added(selection)) {
                        missing = missingMerger.merge(missing, (_a = {},
                            _a[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(utilities.isReference(objectOrReference)
                                ? objectOrReference.__ref + " object"
                                : "object " + JSON.stringify(objectOrReference, null, 2)),
                            _a));
                    }
                }
                else if (isArray(fieldValue)) {
                    fieldValue = handleMissing(_this.executeSubSelectedArray({
                        field: selection,
                        array: fieldValue,
                        enclosingRef: enclosingRef,
                        context: context,
                    }), resultName);
                }
                else if (!selection.selectionSet) {
                    if (context.canonizeResults) {
                        fieldValue = _this.canon.pass(fieldValue);
                    }
                }
                else if (fieldValue != null) {
                    fieldValue = handleMissing(_this.executeSelectionSet({
                        selectionSet: selection.selectionSet,
                        objectOrReference: fieldValue,
                        enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                        context: context,
                    }), resultName);
                }
                if (fieldValue !== void 0) {
                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
                }
            }
            else {
                var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
                if (fragment && policies.fragmentMatches(fragment, typename)) {
                    fragment.selectionSet.selections.forEach(workSet.add, workSet);
                }
            }
        });
        var result = utilities.mergeDeepArray(objectsToMerge);
        var finalResult = { result: result, missing: missing };
        var frozen = context.canonizeResults
            ? this.canon.admit(finalResult)
            : utilities.maybeDeepFreeze(finalResult);
        if (frozen.result) {
            this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
    };
    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {
        var _this = this;
        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;
        var missing;
        var missingMerger = new utilities.DeepMerger();
        function handleMissing(childResult, i) {
            var _a;
            if (childResult.missing) {
                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));
            }
            return childResult.result;
        }
        if (field.selectionSet) {
            array = array.filter(context.store.canRead);
        }
        array = array.map(function (item, i) {
            if (item === null) {
                return null;
            }
            if (isArray(item)) {
                return handleMissing(_this.executeSubSelectedArray({
                    field: field,
                    array: item,
                    enclosingRef: enclosingRef,
                    context: context,
                }), i);
            }
            if (field.selectionSet) {
                return handleMissing(_this.executeSelectionSet({
                    selectionSet: field.selectionSet,
                    objectOrReference: item,
                    enclosingRef: utilities.isReference(item) ? item : enclosingRef,
                    context: context,
                }), i);
            }
            if (__DEV__) {
                assertSelectionSetForIdValue(context.store, field, item);
            }
            return item;
        });
        return {
            result: context.canonizeResults ? this.canon.admit(array) : array,
            missing: missing,
        };
    };
    return StoreReader;
}());
function firstMissing(tree) {
    try {
        JSON.stringify(tree, function (_, value) {
            if (typeof value === "string")
                throw value;
            return value;
        });
    }
    catch (result) {
        return result;
    }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
    if (!field.selectionSet) {
        var workSet_1 = new Set([fieldValue]);
        workSet_1.forEach(function (value) {
            if (utilities.isNonNullObject(value)) {
                __DEV__ ? globals.invariant(!utilities.isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : globals.invariant(!utilities.isReference(value), 5);
                Object.values(value).forEach(workSet_1.add, workSet_1);
            }
        });
    }
}

var cacheSlot = new context.Slot();
var cacheInfoMap = new WeakMap();
function getCacheInfo(cache) {
    var info = cacheInfoMap.get(cache);
    if (!info) {
        cacheInfoMap.set(cache, info = {
            vars: new Set,
            dep: optimism.dep(),
        });
    }
    return info;
}
function forgetCache(cache) {
    getCacheInfo(cache).vars.forEach(function (rv) { return rv.forgetCache(cache); });
}
function recallCache(cache) {
    getCacheInfo(cache).vars.forEach(function (rv) { return rv.attachCache(cache); });
}
function makeVar(value) {
    var caches = new Set();
    var listeners = new Set();
    var rv = function (newValue) {
        if (arguments.length > 0) {
            if (value !== newValue) {
                value = newValue;
                caches.forEach(function (cache) {
                    getCacheInfo(cache).dep.dirty(rv);
                    broadcast(cache);
                });
                var oldListeners = Array.from(listeners);
                listeners.clear();
                oldListeners.forEach(function (listener) { return listener(value); });
            }
        }
        else {
            var cache = cacheSlot.getValue();
            if (cache) {
                attach(cache);
                getCacheInfo(cache).dep(rv);
            }
        }
        return value;
    };
    rv.onNextChange = function (listener) {
        listeners.add(listener);
        return function () {
            listeners.delete(listener);
        };
    };
    var attach = rv.attachCache = function (cache) {
        caches.add(cache);
        getCacheInfo(cache).vars.add(rv);
        return rv;
    };
    rv.forgetCache = function (cache) { return caches.delete(cache); };
    return rv;
}
function broadcast(cache) {
    if (cache.broadcastWatches) {
        cache.broadcastWatches();
    }
}

var specifierInfoCache = Object.create(null);
function lookupSpecifierInfo(spec) {
    var cacheKey = JSON.stringify(spec);
    return specifierInfoCache[cacheKey] ||
        (specifierInfoCache[cacheKey] = Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {
        var extract = function (from, key) { return context.readField(key, from); };
        var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {
            var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);
            if (extracted === void 0 &&
                object !== context.storeObject &&
                hasOwn.call(object, schemaKeyPath[0])) {
                extracted = extractKeyPath(object, schemaKeyPath, extractKey);
            }
            __DEV__ ? globals.invariant(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join('.'), "' while extracting keyFields from ").concat(JSON.stringify(object))) : globals.invariant(extracted !== void 0, 2);
            return extracted;
        });
        return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
    });
}
function keyArgsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {
        var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;
        var collected = collectSpecifierPaths(specifier, function (keyPath) {
            var firstKey = keyPath[0];
            var firstChar = firstKey.charAt(0);
            if (firstChar === "@") {
                if (field && utilities.isNonEmptyArray(field.directives)) {
                    var directiveName_1 = firstKey.slice(1);
                    var d = field.directives.find(function (d) { return d.name.value === directiveName_1; });
                    var directiveArgs = d && utilities.argumentsObjectFromField(d, variables);
                    return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
                }
                return;
            }
            if (firstChar === "$") {
                var variableName = firstKey.slice(1);
                if (variables && hasOwn.call(variables, variableName)) {
                    var varKeyPath = keyPath.slice(0);
                    varKeyPath[0] = variableName;
                    return extractKeyPath(variables, varKeyPath);
                }
                return;
            }
            if (args) {
                return extractKeyPath(args, keyPath);
            }
        });
        var suffix = JSON.stringify(collected);
        if (args || suffix !== "{}") {
            fieldName += ":" + suffix;
        }
        return fieldName;
    });
}
function collectSpecifierPaths(specifier, extractor) {
    var merger = new utilities.DeepMerger;
    return getSpecifierPaths(specifier).reduce(function (collected, path) {
        var _a;
        var toMerge = extractor(path);
        if (toMerge !== void 0) {
            for (var i = path.length - 1; i >= 0; --i) {
                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);
            }
            collected = merger.merge(collected, toMerge);
        }
        return collected;
    }, Object.create(null));
}
function getSpecifierPaths(spec) {
    var info = lookupSpecifierInfo(spec);
    if (!info.paths) {
        var paths_1 = info.paths = [];
        var currentPath_1 = [];
        spec.forEach(function (s, i) {
            if (isArray(s)) {
                getSpecifierPaths(s).forEach(function (p) { return paths_1.push(currentPath_1.concat(p)); });
                currentPath_1.length = 0;
            }
            else {
                currentPath_1.push(s);
                if (!isArray(spec[i + 1])) {
                    paths_1.push(currentPath_1.slice(0));
                    currentPath_1.length = 0;
                }
            }
        });
    }
    return info.paths;
}
function extractKey(object, key) {
    return object[key];
}
function extractKeyPath(object, path, extract) {
    extract = extract || extractKey;
    return normalize(path.reduce(function reducer(obj, key) {
        return isArray(obj)
            ? obj.map(function (child) { return reducer(child, key); })
            : obj && extract(obj, key);
    }, object));
}
function normalize(value) {
    if (utilities.isNonNullObject(value)) {
        if (isArray(value)) {
            return value.map(normalize);
        }
        return collectSpecifierPaths(Object.keys(value).sort(), function (path) { return extractKeyPath(value, path); });
    }
    return value;
}

utilities.getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
    return spec.args !== void 0 ? spec.args :
        spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function () { return void 0; };
var simpleKeyArgsFn = function (_args, context) { return context.fieldName; };
var mergeTrueFn = function (existing, incoming, _a) {
    var mergeObjects = _a.mergeObjects;
    return mergeObjects(existing, incoming);
};
var mergeFalseFn = function (_, incoming) { return incoming; };
var Policies = (function () {
    function Policies(config) {
        this.config = config;
        this.typePolicies = Object.create(null);
        this.toBeAdded = Object.create(null);
        this.supertypeMap = new Map();
        this.fuzzySubtypes = new Map();
        this.rootIdsByTypename = Object.create(null);
        this.rootTypenamesById = Object.create(null);
        this.usingPossibleTypes = false;
        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
            this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
            this.addTypePolicies(config.typePolicies);
        }
    }
    Policies.prototype.identify = function (object, partialContext) {
        var _a;
        var policies = this;
        var typename = partialContext && (partialContext.typename ||
            ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
            return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = tslib.__assign(tslib.__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: partialContext && partialContext.readField || function () {
                var options = normalizeReadFieldOptions(arguments, storeObject);
                return policies.readField(options, {
                    store: policies.cache["data"],
                    variables: options.variables,
                });
            } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
            var specifierOrId = keyFn(object, context);
            if (isArray(specifierOrId)) {
                keyFn = keyFieldsFnFromSpecifier(specifierOrId);
            }
            else {
                id = specifierOrId;
                break;
            }
        }
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
    };
    Policies.prototype.addTypePolicies = function (typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function (typename) {
            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = tslib.__rest(_a, ["queryType", "mutationType", "subscriptionType"]);
            if (queryType)
                _this.setRootTypename("Query", typename);
            if (mutationType)
                _this.setRootTypename("Mutation", typename);
            if (subscriptionType)
                _this.setRootTypename("Subscription", typename);
            if (hasOwn.call(_this.toBeAdded, typename)) {
                _this.toBeAdded[typename].push(incoming);
            }
            else {
                _this.toBeAdded[typename] = [incoming];
            }
        });
    };
    Policies.prototype.updateTypePolicy = function (typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing, merge) {
            existing.merge =
                typeof merge === "function" ? merge :
                    merge === true ? mergeTrueFn :
                        merge === false ? mergeFalseFn :
                            existing.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn =
            keyFields === false ? nullKeyFieldsFn :
                isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :
                    typeof keyFields === "function" ? keyFields :
                        existing.keyFn;
        if (fields) {
            Object.keys(fields).forEach(function (fieldName) {
                var existing = _this.getFieldPolicy(typename, fieldName, true);
                var incoming = fields[fieldName];
                if (typeof incoming === "function") {
                    existing.read = incoming;
                }
                else {
                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;
                    existing.keyFn =
                        keyArgs === false ? simpleKeyArgsFn :
                            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :
                                typeof keyArgs === "function" ? keyArgs :
                                    existing.keyFn;
                    if (typeof read === "function") {
                        existing.read = read;
                    }
                    setMerge(existing, merge);
                }
                if (existing.read && existing.merge) {
                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;
                }
            });
        }
    };
    Policies.prototype.setRootTypename = function (which, typename) {
        if (typename === void 0) { typename = which; }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
            __DEV__ ? globals.invariant(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : globals.invariant(!old || old === which, 3);
            if (old)
                delete this.rootIdsByTypename[old];
            this.rootIdsByTypename[typename] = rootId;
            this.rootTypenamesById[rootId] = typename;
        }
    };
    Policies.prototype.addPossibleTypes = function (possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function (supertype) {
            _this.getSupertypeSet(supertype, true);
            possibleTypes[supertype].forEach(function (subtype) {
                _this.getSupertypeSet(subtype, true).add(supertype);
                var match = subtype.match(TypeOrFieldNameRegExp);
                if (!match || match[0] !== subtype) {
                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
                }
            });
        });
    };
    Policies.prototype.getTypePolicy = function (typename) {
        var _this = this;
        if (!hasOwn.call(this.typePolicies, typename)) {
            var policy_1 = this.typePolicies[typename] = Object.create(null);
            policy_1.fields = Object.create(null);
            var supertypes = this.supertypeMap.get(typename);
            if (supertypes && supertypes.size) {
                supertypes.forEach(function (supertype) {
                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = tslib.__rest(_a, ["fields"]);
                    Object.assign(policy_1, rest);
                    Object.assign(policy_1.fields, fields);
                });
            }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
            inbox.splice(0).forEach(function (policy) {
                _this.updateTypePolicy(typename, policy);
            });
        }
        return this.typePolicies[typename];
    };
    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {
        if (typename) {
            var fieldPolicies = this.getTypePolicy(typename).fields;
            return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));
        }
    };
    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
            this.supertypeMap.set(subtype, supertypeSet = new Set());
        }
        return supertypeSet;
    };
    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {
        var _this = this;
        if (!fragment.typeCondition)
            return true;
        if (!typename)
            return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
            return true;
        if (this.usingPossibleTypes &&
            this.supertypeMap.has(supertype)) {
            var typenameSupertypeSet = this.getSupertypeSet(typename, true);
            var workQueue_1 = [typenameSupertypeSet];
            var maybeEnqueue_1 = function (subtype) {
                var supertypeSet = _this.getSupertypeSet(subtype, false);
                if (supertypeSet &&
                    supertypeSet.size &&
                    workQueue_1.indexOf(supertypeSet) < 0) {
                    workQueue_1.push(supertypeSet);
                }
            };
            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
            var checkingFuzzySubtypes = false;
            for (var i = 0; i < workQueue_1.length; ++i) {
                var supertypeSet = workQueue_1[i];
                if (supertypeSet.has(supertype)) {
                    if (!typenameSupertypeSet.has(supertype)) {
                        if (checkingFuzzySubtypes) {
                            __DEV__ && globals.invariant.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
                        }
                        typenameSupertypeSet.add(supertype);
                    }
                    return true;
                }
                supertypeSet.forEach(maybeEnqueue_1);
                if (needToCheckFuzzySubtypes &&
                    i === workQueue_1.length - 1 &&
                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
                    needToCheckFuzzySubtypes = false;
                    checkingFuzzySubtypes = true;
                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {
                        var match = typename.match(regExp);
                        if (match && match[0] === typename) {
                            maybeEnqueue_1(fuzzyString);
                        }
                    });
                }
            }
        }
        return false;
    };
    Policies.prototype.hasKeyArgs = function (typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
    };
    Policies.prototype.getStoreFieldName = function (fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
            var context = {
                typename: typename,
                fieldName: fieldName,
                field: fieldSpec.field || null,
                variables: fieldSpec.variables,
            };
            var args = argsFromFieldSpecifier(fieldSpec);
            while (keyFn) {
                var specifierOrString = keyFn(args, context);
                if (isArray(specifierOrString)) {
                    keyFn = keyArgsFnFromSpecifier(specifierOrString);
                }
                else {
                    storeFieldName = specifierOrString || fieldName;
                    break;
                }
            }
        }
        if (storeFieldName === void 0) {
            storeFieldName = fieldSpec.field
                ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)
                : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
            return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName)
            ? storeFieldName
            : fieldName + ":" + storeFieldName;
    };
    Policies.prototype.readField = function (options, context) {
        var objectOrReference = options.from;
        if (!objectOrReference)
            return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
            return;
        if (options.typename === void 0) {
            var typename = context.store.getFieldValue(objectOrReference, "__typename");
            if (typename)
                options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(utilities.isReference(objectOrReference)
                ? objectOrReference.__ref
                : objectOrReference, storeFieldName));
            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
        }
        return existing;
    };
    Policies.prototype.getReadFunction = function (typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
    };
    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
            policy = this.getTypePolicy(childTypename);
            merge = policy && policy.merge;
        }
        return merge;
    };
    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {
        var field = _a.field, typename = _a.typename, merge = _a.merge;
        if (merge === mergeTrueFn) {
            return makeMergeObjectsFunction(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
            return incoming;
        }
        if (context.overwrite) {
            existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename: typename, fieldName: field.name.value, field: field, variables: context.variables }, context, storage || Object.create(null)));
    };
    return Policies;
}());
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
    var storeFieldName = policies.getStoreFieldName(fieldSpec);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var variables = fieldSpec.variables || context.variables;
    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;
    return {
        args: argsFromFieldSpecifier(fieldSpec),
        field: fieldSpec.field || null,
        fieldName: fieldName,
        storeFieldName: storeFieldName,
        variables: variables,
        isReference: utilities.isReference,
        toReference: toReference,
        storage: storage,
        cache: policies.cache,
        canRead: canRead,
        readField: function () {
            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
        },
        mergeObjects: makeMergeObjectsFunction(context.store),
    };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
    var options;
    if (typeof fieldNameOrOptions === "string") {
        options = {
            fieldName: fieldNameOrOptions,
            from: argc > 1 ? from : objectOrReference,
        };
    }
    else {
        options = tslib.__assign({}, fieldNameOrOptions);
        if (!hasOwn.call(options, "from")) {
            options.from = objectOrReference;
        }
    }
    if (__DEV__ && options.from === void 0) {
        __DEV__ && globals.invariant.warn("Undefined 'from' passed to readField with arguments ".concat(utilities.stringifyForDisplay(Array.from(readFieldArgs))));
    }
    if (void 0 === options.variables) {
        options.variables = variables;
    }
    return options;
}
function makeMergeObjectsFunction(store) {
    return function mergeObjects(existing, incoming) {
        if (isArray(existing) || isArray(incoming)) {
            throw __DEV__ ? new globals.InvariantError("Cannot automatically merge arrays") : new globals.InvariantError(4);
        }
        if (utilities.isNonNullObject(existing) &&
            utilities.isNonNullObject(incoming)) {
            var eType = store.getFieldValue(existing, "__typename");
            var iType = store.getFieldValue(incoming, "__typename");
            var typesDiffer = eType && iType && eType !== iType;
            if (typesDiffer) {
                return incoming;
            }
            if (utilities.isReference(existing) &&
                storeValueIsStoreObject(incoming)) {
                store.merge(existing.__ref, incoming);
                return existing;
            }
            if (storeValueIsStoreObject(existing) &&
                utilities.isReference(incoming)) {
                store.merge(existing, incoming.__ref);
                return incoming;
            }
            if (storeValueIsStoreObject(existing) &&
                storeValueIsStoreObject(incoming)) {
                return tslib.__assign(tslib.__assign({}, existing), incoming);
            }
        }
        return incoming;
    };
}

function getContextFlavor(context, clientOnly, deferred) {
    var key = "".concat(clientOnly).concat(deferred);
    var flavored = context.flavors.get(key);
    if (!flavored) {
        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&
            context.deferred === deferred) ? context : tslib.__assign(tslib.__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));
    }
    return flavored;
}
var StoreWriter = (function () {
    function StoreWriter(cache, reader) {
        this.cache = cache;
        this.reader = reader;
    }
    StoreWriter.prototype.writeToStore = function (store, _a) {
        var _this = this;
        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
        var operationDefinition = utilities.getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
        var context = {
            store: store,
            written: Object.create(null),
            merge: function (existing, incoming) {
                return merger.merge(existing, incoming);
            },
            variables: variables,
            varString: canonicalStringify(variables),
            fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
            overwrite: !!overwrite,
            incomingById: new Map,
            clientOnly: false,
            deferred: false,
            flavors: new Map,
        };
        var ref = this.processSelectionSet({
            result: result || Object.create(null),
            dataId: dataId,
            selectionSet: operationDefinition.selectionSet,
            mergeTree: { map: new Map },
            context: context,
        });
        if (!utilities.isReference(ref)) {
            throw __DEV__ ? new globals.InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new globals.InvariantError(6);
        }
        context.incomingById.forEach(function (_a, dataId) {
            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;
            var entityRef = utilities.makeReference(dataId);
            if (mergeTree && mergeTree.map.size) {
                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
                if (utilities.isReference(applied)) {
                    return;
                }
                storeObject = applied;
            }
            if (__DEV__ && !context.overwrite) {
                var fieldsWithSelectionSets_1 = Object.create(null);
                fieldNodeSet.forEach(function (field) {
                    if (field.selectionSet) {
                        fieldsWithSelectionSets_1[field.name.value] = true;
                    }
                });
                var hasSelectionSet_1 = function (storeFieldName) {
                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
                };
                var hasMergeFunction_1 = function (storeFieldName) {
                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);
                    return Boolean(childTree && childTree.info && childTree.info.merge);
                };
                Object.keys(storeObject).forEach(function (storeFieldName) {
                    if (hasSelectionSet_1(storeFieldName) &&
                        !hasMergeFunction_1(storeFieldName)) {
                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
                    }
                });
            }
            store.merge(dataId, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
    };
    StoreWriter.prototype.processSelectionSet = function (_a) {
        var _this = this;
        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;
        var policies = this.cache.policies;
        var incoming = Object.create(null);
        var typename = (dataId && policies.rootTypenamesById[dataId]) ||
            utilities.getTypenameFromResult(result, selectionSet, context.fragmentMap) ||
            (dataId && context.store.get(dataId, "__typename"));
        if ("string" === typeof typename) {
            incoming.__typename = typename;
        }
        var readField = function () {
            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
            if (utilities.isReference(options.from)) {
                var info = context.incomingById.get(options.from.__ref);
                if (info) {
                    var result_1 = policies.readField(tslib.__assign(tslib.__assign({}, options), { from: info.storeObject }), context);
                    if (result_1 !== void 0) {
                        return result_1;
                    }
                }
            }
            return policies.readField(options, context);
        };
        var fieldNodeSet = new Set();
        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {
            var _a;
            var resultFieldKey = utilities.resultKeyNameFromField(field);
            var value = result[resultFieldKey];
            fieldNodeSet.add(field);
            if (value !== void 0) {
                var storeFieldName = policies.getStoreFieldName({
                    typename: typename,
                    fieldName: field.name.value,
                    field: field,
                    variables: context.variables,
                });
                var childTree = getChildMergeTree(mergeTree, storeFieldName);
                var incomingValue = _this.processFieldValue(value, field, field.selectionSet
                    ? getContextFlavor(context, false, false)
                    : context, childTree);
                var childTypename = void 0;
                if (field.selectionSet &&
                    (utilities.isReference(incomingValue) ||
                        storeValueIsStoreObject(incomingValue))) {
                    childTypename = readField("__typename", incomingValue);
                }
                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
                if (merge) {
                    childTree.info = {
                        field: field,
                        typename: typename,
                        merge: merge,
                    };
                }
                else {
                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);
                }
                incoming = context.merge(incoming, (_a = {},
                    _a[storeFieldName] = incomingValue,
                    _a));
            }
            else if (__DEV__ &&
                !context.clientOnly &&
                !context.deferred &&
                !utilities.addTypenameToDocument.added(field) &&
                !policies.getReadFunction(typename, field.name.value)) {
                __DEV__ && globals.invariant.error("Missing field '".concat(utilities.resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1000));
            }
        });
        try {
            var _b = policies.identify(result, {
                typename: typename,
                selectionSet: selectionSet,
                fragmentMap: context.fragmentMap,
                storeObject: incoming,
                readField: readField,
            }), id = _b[0], keyObject = _b[1];
            dataId = dataId || id;
            if (keyObject) {
                incoming = context.merge(incoming, keyObject);
            }
        }
        catch (e) {
            if (!dataId)
                throw e;
        }
        if ("string" === typeof dataId) {
            var dataRef = utilities.makeReference(dataId);
            var sets = context.written[dataId] || (context.written[dataId] = []);
            if (sets.indexOf(selectionSet) >= 0)
                return dataRef;
            sets.push(selectionSet);
            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
                return dataRef;
            }
            var previous_1 = context.incomingById.get(dataId);
            if (previous_1) {
                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });
            }
            else {
                context.incomingById.set(dataId, {
                    storeObject: incoming,
                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
                    fieldNodeSet: fieldNodeSet,
                });
            }
            return dataRef;
        }
        return incoming;
    };
    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
            return __DEV__ ? utilities.cloneDeep(value) : value;
        }
        if (isArray(value)) {
            return value.map(function (item, i) {
                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
                maybeRecycleChildMergeTree(mergeTree, i);
                return value;
            });
        }
        return this.processSelectionSet({
            result: value,
            selectionSet: field.selectionSet,
            context: context,
            mergeTree: mergeTree,
        });
    };
    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {
        if (typename === void 0) { typename = utilities.getTypenameFromResult(result, selectionSet, context.fragmentMap); }
        var fieldMap = new Map();
        var policies = this.cache.policies;
        var limitingTrie = new trie.Trie(false);
        (function flatten(selectionSet, inheritedContext) {
            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);
            if (visitedNode.visited)
                return;
            visitedNode.visited = true;
            selectionSet.selections.forEach(function (selection) {
                if (!utilities.shouldInclude(selection, context.variables))
                    return;
                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
                if (!(clientOnly && deferred) &&
                    utilities.isNonEmptyArray(selection.directives)) {
                    selection.directives.forEach(function (dir) {
                        var name = dir.name.value;
                        if (name === "client")
                            clientOnly = true;
                        if (name === "defer") {
                            var args = utilities.argumentsObjectFromField(dir, context.variables);
                            if (!args || args.if !== false) {
                                deferred = true;
                            }
                        }
                    });
                }
                if (utilities.isField(selection)) {
                    var existing = fieldMap.get(selection);
                    if (existing) {
                        clientOnly = clientOnly && existing.clientOnly;
                        deferred = deferred && existing.deferred;
                    }
                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
                }
                else {
                    var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
                    if (fragment &&
                        policies.fragmentMatches(fragment, typename, result, context.variables)) {
                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
                    }
                }
            });
        })(selectionSet, context);
        return fieldMap;
    };
    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {
        var _a;
        var _this = this;
        if (mergeTree.map.size && !utilities.isReference(incoming)) {
            var e_1 = (!isArray(incoming) &&
                (utilities.isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;
            var i_1 = incoming;
            if (e_1 && !getStorageArgs) {
                getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
            }
            var changedFields_1;
            var getValue_1 = function (from, name) {
                return isArray(from)
                    ? (typeof name === "number" ? from[name] : void 0)
                    : context.store.getFieldValue(from, String(name));
            };
            mergeTree.map.forEach(function (childTree, storeFieldName) {
                var eVal = getValue_1(e_1, storeFieldName);
                var iVal = getValue_1(i_1, storeFieldName);
                if (void 0 === iVal)
                    return;
                if (getStorageArgs) {
                    getStorageArgs.push(storeFieldName);
                }
                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
                if (aVal !== iVal) {
                    changedFields_1 = changedFields_1 || new Map;
                    changedFields_1.set(storeFieldName, aVal);
                }
                if (getStorageArgs) {
                    globals.invariant(getStorageArgs.pop() === storeFieldName);
                }
            });
            if (changedFields_1) {
                incoming = (isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1));
                changedFields_1.forEach(function (value, name) {
                    incoming[name] = value;
                });
            }
        }
        if (mergeTree.info) {
            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));
        }
        return incoming;
    };
    return StoreWriter;
}());
var emptyMergeTreePool = [];
function getChildMergeTree(_a, name) {
    var map = _a.map;
    if (!map.has(name)) {
        map.set(name, emptyMergeTreePool.pop() || { map: new Map });
    }
    return map.get(name);
}
function mergeMergeTrees(left, right) {
    if (left === right || !right || mergeTreeIsEmpty(right))
        return left;
    if (!left || mergeTreeIsEmpty(left))
        return right;
    var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
    var needToMergeMaps = left.map.size && right.map.size;
    var map = needToMergeMaps ? new Map :
        left.map.size ? left.map : right.map;
    var merged = { info: info, map: map };
    if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function (leftTree, key) {
            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
            remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function (key) {
            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
        });
    }
    return merged;
}
function mergeTreeIsEmpty(tree) {
    return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a, name) {
    var map = _a.map;
    var childTree = map.get(name);
    if (childTree && mergeTreeIsEmpty(childTree)) {
        emptyMergeTreePool.push(childTree);
        map.delete(name);
    }
}
var warnings = new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
    var getChild = function (objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
    };
    var existing = getChild(existingRef);
    if (!existing)
        return;
    var incoming = getChild(incomingObj);
    if (!incoming)
        return;
    if (utilities.isReference(existing))
        return;
    if (equality.equal(existing, incoming))
        return;
    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {
        return;
    }
    var parentType = store.getFieldValue(existingRef, "__typename") ||
        store.getFieldValue(incomingObj, "__typename");
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var typeDotName = "".concat(parentType, ".").concat(fieldName);
    if (warnings.has(typeDotName))
        return;
    warnings.add(typeDotName);
    var childTypenames = [];
    if (!isArray(existing) &&
        !isArray(incoming)) {
        [existing, incoming].forEach(function (child) {
            var typename = store.getFieldValue(child, "__typename");
            if (typeof typename === "string" &&
                !childTypenames.includes(typename)) {
                childTypenames.push(typename);
            }
        });
    }
    __DEV__ && globals.invariant.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length
        ? "either ensure all objects of type " +
            childTypenames.join(" and ") + " have an ID or a custom merge function, or "
        : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1000), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1000), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
}

var InMemoryCache = (function (_super) {
    tslib.__extends(InMemoryCache, _super);
    function InMemoryCache(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        _this.watches = new Set();
        _this.typenameDocumentCache = new Map();
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = normalizeConfig(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
            cache: _this,
            dataIdFromObject: _this.config.dataIdFromObject,
            possibleTypes: _this.config.possibleTypes,
            typePolicies: _this.config.typePolicies,
        });
        _this.init();
        return _this;
    }
    InMemoryCache.prototype.init = function () {
        var rootStore = this.data = new exports.EntityStore.Root({
            policies: this.policies,
            resultCaching: this.config.resultCaching,
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
    };
    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
            cache: this,
            addTypename: this.addTypename,
            resultCacheMaxSize: this.config.resultCacheMaxSize,
            canonizeResults: shouldCanonizeResults(this.config),
            canon: resetResultIdentities
                ? void 0
                : previousReader && previousReader.canon,
        }));
        this.maybeBroadcastWatch = optimism.wrap(function (c, options) {
            return _this.broadcastWatch(c, options);
        }, {
            max: this.config.resultCacheMaxSize,
            makeCacheKey: function (c) {
                var store = c.optimistic ? _this.optimisticData : _this.data;
                if (supportsResultCaching(store)) {
                    var optimistic = c.optimistic, rootId = c.rootId, variables = c.variables;
                    return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic: optimistic, rootId: rootId, variables: variables }));
                }
            }
        });
        new Set([
            this.data.group,
            this.optimisticData.group,
        ]).forEach(function (group) { return group.resetCaching(); });
    };
    InMemoryCache.prototype.restore = function (data) {
        this.init();
        if (data)
            this.data.replace(data);
        return this;
    };
    InMemoryCache.prototype.extract = function (optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache.prototype.read = function (options) {
        var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
        try {
            return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null;
        }
        catch (e) {
            if (e instanceof MissingFieldError) {
                return null;
            }
            throw e;
        }
    };
    InMemoryCache.prototype.write = function (options) {
        try {
            ++this.txCount;
            return this.storeWriter.writeToStore(this.data, options);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.modify = function (options) {
        if (hasOwn.call(options, "id") && !options.id) {
            return false;
        }
        var store = options.optimistic
            ? this.optimisticData
            : this.data;
        try {
            ++this.txCount;
            return store.modify(options.id || "ROOT_QUERY", options.fields);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.diff = function (options) {
        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache.prototype.watch = function (watch) {
        var _this = this;
        if (!this.watches.size) {
            recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
            this.maybeBroadcastWatch(watch);
        }
        return function () {
            if (_this.watches.delete(watch) && !_this.watches.size) {
                forgetCache(_this);
            }
            _this.maybeBroadcastWatch.forget(watch);
        };
    };
    InMemoryCache.prototype.gc = function (options) {
        canonicalStringify.reset();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
            if (options.resetResultCache) {
                this.resetResultCache(options.resetResultIdentities);
            }
            else if (options.resetResultIdentities) {
                this.storeReader.resetCanon();
            }
        }
        return ids;
    };
    InMemoryCache.prototype.retain = function (rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache.prototype.release = function (rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache.prototype.identify = function (object) {
        if (utilities.isReference(object))
            return object.__ref;
        try {
            return this.policies.identify(object)[0];
        }
        catch (e) {
            __DEV__ && globals.invariant.warn(e);
        }
    };
    InMemoryCache.prototype.evict = function (options) {
        if (!options.id) {
            if (hasOwn.call(options, "id")) {
                return false;
            }
            options = tslib.__assign(tslib.__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
            ++this.txCount;
            return this.optimisticData.evict(options, this.data);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.reset = function (options) {
        var _this = this;
        this.init();
        canonicalStringify.reset();
        if (options && options.discardWatches) {
            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });
            this.watches.clear();
            forgetCache(this);
        }
        else {
            this.broadcastWatches();
        }
        return Promise.resolve();
    };
    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
            this.optimisticData = newOptimisticData;
            this.broadcastWatches();
        }
    };
    InMemoryCache.prototype.batch = function (options) {
        var _this = this;
        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var updateResult;
        var perform = function (layer) {
            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;
            ++_this.txCount;
            if (layer) {
                _this.data = _this.optimisticData = layer;
            }
            try {
                return updateResult = update(_this);
            }
            finally {
                --_this.txCount;
                _this.data = data;
                _this.optimisticData = optimisticData;
            }
        };
        var alreadyDirty = new Set();
        if (onWatchUpdated && !this.txCount) {
            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function (watch) {
                    alreadyDirty.add(watch);
                    return false;
                } }));
        }
        if (typeof optimistic === 'string') {
            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        }
        else if (optimistic === false) {
            perform(this.data);
        }
        else {
            perform();
        }
        if (typeof removeOptimistic === "string") {
            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function (watch, diff) {
                    var result = onWatchUpdated.call(this, watch, diff);
                    if (result !== false) {
                        alreadyDirty.delete(watch);
                    }
                    return result;
                } }));
            if (alreadyDirty.size) {
                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });
            }
        }
        else {
            this.broadcastWatches(options);
        }
        return updateResult;
    };
    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {
        return this.batch({
            update: update,
            optimistic: optimisticId || (optimisticId !== null),
        });
    };
    InMemoryCache.prototype.transformDocument = function (document) {
        if (this.addTypename) {
            var result = this.typenameDocumentCache.get(document);
            if (!result) {
                result = utilities.addTypenameToDocument(document);
                this.typenameDocumentCache.set(document, result);
                this.typenameDocumentCache.set(result, result);
            }
            return result;
        }
        return document;
    };
    InMemoryCache.prototype.broadcastWatches = function (options) {
        var _this = this;
        if (!this.txCount) {
            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });
        }
    };
    InMemoryCache.prototype.broadcastWatch = function (c, options) {
        var lastDiff = c.lastDiff;
        var diff = this.diff(c);
        if (options) {
            if (c.optimistic &&
                typeof options.optimistic === "string") {
                diff.fromOptimisticTransaction = true;
            }
            if (options.onWatchUpdated &&
                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
                return;
            }
        }
        if (!lastDiff || !equality.equal(lastDiff.result, diff.result)) {
            c.callback(c.lastDiff = diff, lastDiff);
        }
    };
    return InMemoryCache;
}(ApolloCache));

exports.isReference = utilities.isReference;
exports.makeReference = utilities.makeReference;
exports.ApolloCache = ApolloCache;
exports.InMemoryCache = InMemoryCache;
exports.MissingFieldError = MissingFieldError;
exports.Policies = Policies;
exports.cacheSlot = cacheSlot;
exports.canonicalStringify = canonicalStringify;
exports.defaultDataIdFromObject = defaultDataIdFromObject;
exports.fieldNameFromStoreName = fieldNameFromStoreName;
exports.makeVar = makeVar;
//# sourceMappingURL=cache.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/core/core.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@apollo/client/core/core.cjs ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var core = __webpack_require__(/*! ../link/core */ "./node_modules/@apollo/client/link/core/core.cjs");
var http = __webpack_require__(/*! ../link/http */ "./node_modules/@apollo/client/link/http/http.cjs");
var equality = __webpack_require__(/*! @wry/equality */ "@wry/equality");
var cache = __webpack_require__(/*! ../cache */ "./node_modules/@apollo/client/cache/cache.cjs");
var utilities = __webpack_require__(/*! ../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");
var errors = __webpack_require__(/*! ../errors */ "./node_modules/@apollo/client/errors/errors.cjs");
var graphql = __webpack_require__(/*! graphql */ "graphql");
var utils = __webpack_require__(/*! ../link/utils */ "./node_modules/@apollo/client/link/utils/utils.cjs");
var tsInvariant = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.cjs");
var graphqlTag = __webpack_require__(/*! graphql-tag */ "graphql-tag");

var version = '3.6.9';

exports.NetworkStatus = void 0;
(function (NetworkStatus) {
    NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
    NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
    NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
    NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
    NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
    NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
    NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(exports.NetworkStatus || (exports.NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
    return networkStatus ? networkStatus < 7 : false;
}

var assign = Object.assign, hasOwnProperty$1 = Object.hasOwnProperty;
var ObservableQuery = (function (_super) {
    tslib.__extends(ObservableQuery, _super);
    function ObservableQuery(_a) {
        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
        var _this = _super.call(this, function (observer) {
            try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                    subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
            }
            catch (_a) { }
            var first = !_this.observers.size;
            _this.observers.add(observer);
            var last = _this.last;
            if (last && last.error) {
                observer.error && observer.error(last.error);
            }
            else if (last && last.result) {
                observer.next && observer.next(last.result);
            }
            if (first) {
                _this.reobserve().catch(function () { });
            }
            return function () {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                    _this.tearDownQuery();
                }
            };
        }) || this;
        _this.observers = new Set();
        _this.subscriptions = new Set();
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.isTornDown = false;
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? (fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy) : _f;
        _this.options = tslib.__assign(tslib.__assign({}, options), { initialFetchPolicy: initialFetchPolicy, fetchPolicy: fetchPolicy });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = utilities.getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
    }
    Object.defineProperty(ObservableQuery.prototype, "query", {
        get: function () {
            return this.queryManager.transform(this.options.query).document;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuery.prototype, "variables", {
        get: function () {
            return this.options.variables;
        },
        enumerable: false,
        configurable: true
    });
    ObservableQuery.prototype.result = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var observer = {
                next: function (result) {
                    resolve(result);
                    _this.observers.delete(observer);
                    if (!_this.observers.size) {
                        _this.queryManager.removeQuery(_this.queryId);
                    }
                    setTimeout(function () {
                        subscription.unsubscribe();
                    }, 0);
                },
                error: reject,
            };
            var subscription = _this.subscribe(observer);
        });
    };
    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {
        if (saveAsLastResult === void 0) { saveAsLastResult = true; }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus ||
            (lastResult && lastResult.networkStatus) ||
            exports.NetworkStatus.ready;
        var result = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });
        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
        if (fetchPolicy === 'network-only' ||
            fetchPolicy === 'no-cache' ||
            fetchPolicy === 'standby' ||
            this.queryManager.transform(this.options.query).hasForcedResolvers) ;
        else {
            var diff = this.queryInfo.getDiff();
            if (diff.complete || this.options.returnPartialData) {
                result.data = diff.result;
            }
            if (equality.equal(result.data, {})) {
                result.data = void 0;
            }
            if (diff.complete) {
                delete result.partial;
                if (diff.complete &&
                    result.networkStatus === exports.NetworkStatus.loading &&
                    (fetchPolicy === 'cache-first' ||
                        fetchPolicy === 'cache-only')) {
                    result.networkStatus = exports.NetworkStatus.ready;
                    result.loading = false;
                }
            }
            else {
                result.partial = true;
            }
            if (__DEV__ &&
                !diff.complete &&
                !this.options.partialRefetch &&
                !result.loading &&
                !result.data &&
                !result.error) {
                logMissingFieldErrors(diff.missing);
            }
        }
        if (saveAsLastResult) {
            this.updateLastResult(result);
        }
        return result;
    };
    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
        return !this.last || !equality.equal(this.last.result, newResult);
    };
    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {
        var last = this.last;
        if (last &&
            last[key] &&
            (!variablesMustMatch || equality.equal(last.variables, this.variables))) {
            return last[key];
        }
    };
    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery.prototype.resetLastResults = function () {
        delete this.last;
        this.isTornDown = false;
    };
    ObservableQuery.prototype.resetQueryStoreErrors = function () {
        this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery.prototype.refetch = function (variables) {
        var _a;
        var reobserveOptions = {
            pollInterval: 0,
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === 'cache-and-network') {
            reobserveOptions.fetchPolicy = fetchPolicy;
        }
        else if (fetchPolicy === 'no-cache') {
            reobserveOptions.fetchPolicy = 'no-cache';
        }
        else {
            reobserveOptions.fetchPolicy = 'network-only';
        }
        if (__DEV__ && variables && hasOwnProperty$1.call(variables, "variables")) {
            var queryDef = utilities.getQueryDefinition(this.query);
            var vars = queryDef.variableDefinitions;
            if (!vars || !vars.some(function (v) { return v.variable.name.value === "variables"; })) {
                __DEV__ && globals.invariant.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
            }
        }
        if (variables && !equality.equal(this.options.variables, variables)) {
            reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
    };
    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
        var _this = this;
        var combinedOptions = tslib.__assign(tslib.__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), { query: this.query }), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) }))), { fetchPolicy: "no-cache" });
        var qid = this.queryManager.generateQueryId();
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
            this.observe();
        }
        var updatedQuerySet = new Set();
        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function (fetchMoreResult) {
            _this.queryManager.removeQuery(qid);
            if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
                queryInfo.networkStatus = originalNetworkStatus;
            }
            _this.queryManager.cache.batch({
                update: function (cache) {
                    var updateQuery = fetchMoreOptions.updateQuery;
                    if (updateQuery) {
                        cache.updateQuery({
                            query: _this.query,
                            variables: _this.variables,
                            returnPartialData: true,
                            optimistic: false,
                        }, function (previous) { return updateQuery(previous, {
                            fetchMoreResult: fetchMoreResult.data,
                            variables: combinedOptions.variables,
                        }); });
                    }
                    else {
                        cache.writeQuery({
                            query: combinedOptions.query,
                            variables: combinedOptions.variables,
                            data: fetchMoreResult.data,
                        });
                    }
                },
                onWatchUpdated: function (watch) {
                    updatedQuerySet.add(watch.query);
                },
            });
            return fetchMoreResult;
        }).finally(function () {
            if (!updatedQuerySet.has(_this.query)) {
                reobserveCacheFirst(_this);
            }
        });
    };
    ObservableQuery.prototype.subscribeToMore = function (options) {
        var _this = this;
        var subscription = this.queryManager
            .startGraphQLSubscription({
            query: options.document,
            variables: options.variables,
            context: options.context,
        })
            .subscribe({
            next: function (subscriptionData) {
                var updateQuery = options.updateQuery;
                if (updateQuery) {
                    _this.updateQuery(function (previous, _a) {
                        var variables = _a.variables;
                        return updateQuery(previous, {
                            subscriptionData: subscriptionData,
                            variables: variables,
                        });
                    });
                }
            },
            error: function (err) {
                if (options.onError) {
                    options.onError(err);
                    return;
                }
                __DEV__ && globals.invariant.error('Unhandled GraphQL subscription error', err);
            },
        });
        this.subscriptions.add(subscription);
        return function () {
            if (_this.subscriptions.delete(subscription)) {
                subscription.unsubscribe();
            }
        };
    };
    ObservableQuery.prototype.setOptions = function (newOptions) {
        return this.reobserve(newOptions);
    };
    ObservableQuery.prototype.setVariables = function (variables) {
        if (equality.equal(this.variables, variables)) {
            return this.observers.size
                ? this.result()
                : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
            return Promise.resolve();
        }
        return this.reobserve({
            fetchPolicy: this.options.initialFetchPolicy,
            variables: variables,
        }, exports.NetworkStatus.setVariables);
    };
    ObservableQuery.prototype.updateQuery = function (mapFn) {
        var queryManager = this.queryManager;
        var result = queryManager.cache.diff({
            query: this.options.query,
            variables: this.variables,
            returnPartialData: true,
            optimistic: false,
        }).result;
        var newResult = mapFn(result, {
            variables: this.variables,
        });
        if (newResult) {
            queryManager.cache.writeQuery({
                query: this.options.query,
                data: newResult,
                variables: this.variables,
            });
            queryManager.broadcastQueries();
        }
    };
    ObservableQuery.prototype.startPolling = function (pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
    };
    ObservableQuery.prototype.stopPolling = function () {
        this.options.pollInterval = 0;
        this.updatePolling();
    };
    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, options) {
        if (options.nextFetchPolicy) {
            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
            if (fetchPolicy === "standby") ;
            else if (typeof options.nextFetchPolicy === "function") {
                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
                    reason: reason,
                    options: options,
                    observable: this,
                    initialFetchPolicy: initialFetchPolicy,
                });
            }
            else if (reason === "variables-changed") {
                options.fetchPolicy = initialFetchPolicy;
            }
            else {
                options.fetchPolicy = options.nextFetchPolicy;
            }
        }
        return options.fetchPolicy;
    };
    ObservableQuery.prototype.fetch = function (options, newNetworkStatus) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
    };
    ObservableQuery.prototype.updatePolling = function () {
        var _this = this;
        if (this.queryManager.ssrMode) {
            return;
        }
        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
        if (!pollInterval) {
            if (pollingInfo) {
                clearTimeout(pollingInfo.timeout);
                delete this.pollingInfo;
            }
            return;
        }
        if (pollingInfo &&
            pollingInfo.interval === pollInterval) {
            return;
        }
        __DEV__ ? globals.invariant(pollInterval, 'Attempted to start a polling query without a polling interval.') : globals.invariant(pollInterval, 10);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function () {
            if (_this.pollingInfo) {
                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
                    _this.reobserve({
                        fetchPolicy: "network-only",
                    }, exports.NetworkStatus.poll).then(poll, poll);
                }
                else {
                    poll();
                }
            }
        };
        var poll = function () {
            var info = _this.pollingInfo;
            if (info) {
                clearTimeout(info.timeout);
                info.timeout = setTimeout(maybeFetch, info.interval);
            }
        };
        poll();
    };
    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {
        if (variables === void 0) { variables = this.variables; }
        this.last = tslib.__assign(tslib.__assign({}, this.last), { result: this.queryManager.assumeImmutableResults
                ? newResult
                : utilities.cloneDeep(newResult), variables: variables });
        if (!utilities.isNonEmptyArray(newResult.errors)) {
            delete this.last.error;
        }
        return this.last;
    };
    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch ||
            newNetworkStatus === exports.NetworkStatus.fetchMore ||
            newNetworkStatus === exports.NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = utilities.compact(this.options, newOptions || {});
        var options = useDisposableConcast
            ? mergedOptions
            : assign(this.options, mergedOptions);
        if (!useDisposableConcast) {
            this.updatePolling();
            if (newOptions &&
                newOptions.variables &&
                !equality.equal(newOptions.variables, oldVariables) &&
                options.fetchPolicy !== "standby" &&
                options.fetchPolicy === oldFetchPolicy) {
                this.applyNextFetchPolicy("variables-changed", options);
                if (newNetworkStatus === void 0) {
                    newNetworkStatus = exports.NetworkStatus.setVariables;
                }
            }
        }
        var variables = options.variables && tslib.__assign({}, options.variables);
        var concast = this.fetch(options, newNetworkStatus);
        var observer = {
            next: function (result) {
                _this.reportResult(result, variables);
            },
            error: function (error) {
                _this.reportError(error, variables);
            },
        };
        if (!useDisposableConcast) {
            if (this.concast && this.observer) {
                this.concast.removeObserver(this.observer);
            }
            this.concast = concast;
            this.observer = observer;
        }
        concast.addObserver(observer);
        return concast.promise;
    };
    ObservableQuery.prototype.observe = function () {
        this.reportResult(this.getCurrentResult(false), this.variables);
    };
    ObservableQuery.prototype.reportResult = function (result, variables) {
        var lastError = this.getLastError();
        if (lastError || this.isDifferentFromLastResult(result)) {
            if (lastError || !result.partial || this.options.returnPartialData) {
                this.updateLastResult(result, variables);
            }
            utilities.iterateObserversSafely(this.observers, 'next', result);
        }
    };
    ObservableQuery.prototype.reportError = function (error, variables) {
        var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        utilities.iterateObserversSafely(this.observers, 'error', this.last.error = error);
    };
    ObservableQuery.prototype.hasObservers = function () {
        return this.observers.size > 0;
    };
    ObservableQuery.prototype.tearDownQuery = function () {
        if (this.isTornDown)
            return;
        if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
            delete this.concast;
            delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
    };
    return ObservableQuery;
}(utilities.Observable));
utilities.fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;
    if (fetchPolicy === "cache-and-network" ||
        fetchPolicy === "network-only") {
        return obsQuery.reobserve({
            fetchPolicy: "cache-first",
            nextFetchPolicy: function () {
                this.nextFetchPolicy = nextFetchPolicy;
                if (typeof nextFetchPolicy === "function") {
                    return nextFetchPolicy.apply(this, arguments);
                }
                return fetchPolicy;
            },
        });
    }
    return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
    __DEV__ && globals.invariant.error('Unhandled error', error.message, error.stack);
}
function logMissingFieldErrors(missing) {
    if (__DEV__ && missing) {
        __DEV__ && globals.invariant.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
    }
}

var LocalState = (function () {
    function LocalState(_a) {
        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
        this.cache = cache;
        if (client) {
            this.client = client;
        }
        if (resolvers) {
            this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
            this.setFragmentMatcher(fragmentMatcher);
        }
    }
    LocalState.prototype.addResolvers = function (resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
            resolvers.forEach(function (resolverGroup) {
                _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
            });
        }
        else {
            this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
        }
    };
    LocalState.prototype.setResolvers = function (resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
    };
    LocalState.prototype.getResolvers = function () {
        return this.resolvers || {};
    };
    LocalState.prototype.runResolvers = function (_a) {
        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_c) {
                if (document) {
                    return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result })); })];
                }
                return [2, remoteResult];
            });
        });
    };
    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
    };
    LocalState.prototype.getFragmentMatcher = function () {
        return this.fragmentMatcher;
    };
    LocalState.prototype.clientQuery = function (document) {
        if (utilities.hasDirectives(['client'], document)) {
            if (this.resolvers) {
                return document;
            }
        }
        return null;
    };
    LocalState.prototype.serverQuery = function (document) {
        return utilities.removeClientSetsFromDocument(document);
    };
    LocalState.prototype.prepareContext = function (context) {
        var cache = this.cache;
        return tslib.__assign(tslib.__assign({}, context), { cache: cache, getCacheKey: function (obj) {
                return cache.identify(obj);
            } });
    };
    LocalState.prototype.addExportedVariables = function (document, variables, context) {
        if (variables === void 0) { variables = {}; }
        if (context === void 0) { context = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                if (document) {
                    return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (tslib.__assign(tslib.__assign({}, variables), data.exportedVariables)); })];
                }
                return [2, tslib.__assign({}, variables)];
            });
        });
    };
    LocalState.prototype.shouldForceResolvers = function (document) {
        var forceResolvers = false;
        graphql.visit(document, {
            Directive: {
                enter: function (node) {
                    if (node.name.value === 'client' && node.arguments) {
                        forceResolvers = node.arguments.some(function (arg) {
                            return arg.name.value === 'always' &&
                                arg.value.kind === 'BooleanValue' &&
                                arg.value.value === true;
                        });
                        if (forceResolvers) {
                            return graphql.BREAK;
                        }
                    }
                },
            },
        });
        return forceResolvers;
    };
    LocalState.prototype.buildRootValueFromCache = function (document, variables) {
        return this.cache.diff({
            query: utilities.buildQueryFromSelectionSet(document),
            variables: variables,
            returnPartialData: true,
            optimistic: false,
        }).result;
    };
    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        if (context === void 0) { context = {}; }
        if (variables === void 0) { variables = {}; }
        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }
        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
            return tslib.__generator(this, function (_b) {
                mainDefinition = utilities.getMainDefinition(document);
                fragments = utilities.getFragmentDefinitions(document);
                fragmentMap = utilities.createFragmentMap(fragments);
                definitionOperation = mainDefinition
                    .operation;
                defaultOperationType = definitionOperation
                    ? definitionOperation.charAt(0).toUpperCase() +
                        definitionOperation.slice(1)
                    : 'Query';
                _a = this, cache = _a.cache, client = _a.client;
                execContext = {
                    fragmentMap: fragmentMap,
                    context: tslib.__assign(tslib.__assign({}, context), { cache: cache, client: client }),
                    variables: variables,
                    fragmentMatcher: fragmentMatcher,
                    defaultOperationType: defaultOperationType,
                    exportedVariables: {},
                    onlyRunForcedResolvers: onlyRunForcedResolvers,
                };
                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({
                        result: result,
                        exportedVariables: execContext.exportedVariables,
                    }); })];
            });
        });
    };
    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var fragmentMap, context, variables, resultsToMerge, execute;
            var _this = this;
            return tslib.__generator(this, function (_a) {
                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                resultsToMerge = [rootValue];
                execute = function (selection) { return tslib.__awaiter(_this, void 0, void 0, function () {
                    var fragment, typeCondition;
                    return tslib.__generator(this, function (_a) {
                        if (!utilities.shouldInclude(selection, variables)) {
                            return [2];
                        }
                        if (utilities.isField(selection)) {
                            return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                                    var _a;
                                    if (typeof fieldResult !== 'undefined') {
                                        resultsToMerge.push((_a = {},
                                            _a[utilities.resultKeyNameFromField(selection)] = fieldResult,
                                            _a));
                                    }
                                })];
                        }
                        if (utilities.isInlineFragment(selection)) {
                            fragment = selection;
                        }
                        else {
                            fragment = fragmentMap[selection.name.value];
                            __DEV__ ? globals.invariant(fragment, "No fragment named ".concat(selection.name.value)) : globals.invariant(fragment, 9);
                        }
                        if (fragment && fragment.typeCondition) {
                            typeCondition = fragment.typeCondition.name.value;
                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                                        resultsToMerge.push(fragmentResult);
                                    })];
                            }
                        }
                        return [2];
                    });
                }); };
                return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
                        return utilities.mergeDeepArray(resultsToMerge);
                    })];
            });
        });
    };
    LocalState.prototype.resolveField = function (field, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
            var _this = this;
            return tslib.__generator(this, function (_a) {
                variables = execContext.variables;
                fieldName = field.name.value;
                aliasedFieldName = utilities.resultKeyNameFromField(field);
                aliasUsed = fieldName !== aliasedFieldName;
                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                resultPromise = Promise.resolve(defaultResult);
                if (!execContext.onlyRunForcedResolvers ||
                    this.shouldForceResolvers(field)) {
                    resolverType = rootValue.__typename || execContext.defaultOperationType;
                    resolverMap = this.resolvers && this.resolvers[resolverType];
                    if (resolverMap) {
                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                        if (resolve) {
                            resultPromise = Promise.resolve(cache.cacheSlot.withValue(this.cache, resolve, [
                                rootValue,
                                utilities.argumentsObjectFromField(field, variables),
                                execContext.context,
                                { field: field, fragmentMap: execContext.fragmentMap },
                            ]));
                        }
                    }
                }
                return [2, resultPromise.then(function (result) {
                        if (result === void 0) { result = defaultResult; }
                        if (field.directives) {
                            field.directives.forEach(function (directive) {
                                if (directive.name.value === 'export' && directive.arguments) {
                                    directive.arguments.forEach(function (arg) {
                                        if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                                            execContext.exportedVariables[arg.value.value] = result;
                                        }
                                    });
                                }
                            });
                        }
                        if (!field.selectionSet) {
                            return result;
                        }
                        if (result == null) {
                            return result;
                        }
                        if (Array.isArray(result)) {
                            return _this.resolveSubSelectedArray(field, result, execContext);
                        }
                        if (field.selectionSet) {
                            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
                        }
                    })];
            });
        });
    };
    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
        var _this = this;
        return Promise.all(result.map(function (item) {
            if (item === null) {
                return null;
            }
            if (Array.isArray(item)) {
                return _this.resolveSubSelectedArray(field, item, execContext);
            }
            if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, item, execContext);
            }
        }));
    };
    return LocalState;
}());

var destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache, methodName) {
    var original = cache[methodName];
    if (typeof original === "function") {
        cache[methodName] = function () {
            destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
            return original.apply(this, arguments);
        };
    }
}
function cancelNotifyTimeout(info) {
    if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
    }
}
var QueryInfo = (function () {
    function QueryInfo(queryManager, queryId) {
        if (queryId === void 0) { queryId = queryManager.generateQueryId(); }
        this.queryId = queryId;
        this.listeners = new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.subscriptions = new Set();
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache)) {
            destructiveMethodCounts.set(cache, 0);
            wrapDestructiveCacheMethod(cache, "evict");
            wrapDestructiveCacheMethod(cache, "modify");
            wrapDestructiveCacheMethod(cache, "reset");
        }
    }
    QueryInfo.prototype.init = function (query) {
        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
        if (this.variables &&
            this.networkStatus !== exports.NetworkStatus.loading &&
            !equality.equal(this.variables, query.variables)) {
            networkStatus = exports.NetworkStatus.setVariables;
        }
        if (!equality.equal(query.variables, this.variables)) {
            this.lastDiff = void 0;
        }
        Object.assign(this, {
            document: query.document,
            variables: query.variables,
            networkError: null,
            graphQLErrors: this.graphQLErrors || [],
            networkStatus: networkStatus,
        });
        if (query.observableQuery) {
            this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
            this.lastRequestId = query.lastRequestId;
        }
        return this;
    };
    QueryInfo.prototype.reset = function () {
        cancelNotifyTimeout(this);
        this.lastDiff = void 0;
        this.dirty = false;
    };
    QueryInfo.prototype.getDiff = function (variables) {
        if (variables === void 0) { variables = this.variables; }
        var options = this.getDiffOptions(variables);
        if (this.lastDiff && equality.equal(options, this.lastDiff.options)) {
            return this.lastDiff.diff;
        }
        this.updateWatch(this.variables = variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
            return { complete: false };
        }
        var diff = this.cache.diff(options);
        this.updateLastDiff(diff, options);
        return diff;
    };
    QueryInfo.prototype.updateLastDiff = function (diff, options) {
        this.lastDiff = diff ? {
            diff: diff,
            options: options || this.getDiffOptions(),
        } : void 0;
    };
    QueryInfo.prototype.getDiffOptions = function (variables) {
        var _a;
        if (variables === void 0) { variables = this.variables; }
        return {
            query: this.document,
            variables: variables,
            returnPartialData: true,
            optimistic: true,
            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults,
        };
    };
    QueryInfo.prototype.setDiff = function (diff) {
        var _this = this;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        this.updateLastDiff(diff);
        if (!this.dirty &&
            !equality.equal(oldDiff && oldDiff.result, diff && diff.result)) {
            this.dirty = true;
            if (!this.notifyTimeout) {
                this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);
            }
        }
    };
    QueryInfo.prototype.setObservableQuery = function (oq) {
        var _this = this;
        if (oq === this.observableQuery)
            return;
        if (this.oqListener) {
            this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
            oq["queryInfo"] = this;
            this.listeners.add(this.oqListener = function () {
                var diff = _this.getDiff();
                if (diff.fromOptimisticTransaction) {
                    oq["observe"]();
                }
                else {
                    reobserveCacheFirst(oq);
                }
            });
        }
        else {
            delete this.oqListener;
        }
    };
    QueryInfo.prototype.notify = function () {
        var _this = this;
        cancelNotifyTimeout(this);
        if (this.shouldNotify()) {
            this.listeners.forEach(function (listener) { return listener(_this); });
        }
        this.dirty = false;
    };
    QueryInfo.prototype.shouldNotify = function () {
        if (!this.dirty || !this.listeners.size) {
            return false;
        }
        if (isNetworkRequestInFlight(this.networkStatus) &&
            this.observableQuery) {
            var fetchPolicy = this.observableQuery.options.fetchPolicy;
            if (fetchPolicy !== "cache-only" &&
                fetchPolicy !== "cache-and-network") {
                return false;
            }
        }
        return true;
    };
    QueryInfo.prototype.stop = function () {
        if (!this.stopped) {
            this.stopped = true;
            this.reset();
            this.cancel();
            this.cancel = QueryInfo.prototype.cancel;
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            var oq = this.observableQuery;
            if (oq)
                oq.stopPolling();
        }
    };
    QueryInfo.prototype.cancel = function () { };
    QueryInfo.prototype.updateWatch = function (variables) {
        var _this = this;
        if (variables === void 0) { variables = this.variables; }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
            return;
        }
        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function (diff) { return _this.setDiff(diff); } });
        if (!this.lastWatch ||
            !equality.equal(watchOptions, this.lastWatch)) {
            this.cancel();
            this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
    };
    QueryInfo.prototype.resetLastWrite = function () {
        this.lastWrite = void 0;
    };
    QueryInfo.prototype.shouldWrite = function (result, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite &&
            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&
            equality.equal(variables, lastWrite.variables) &&
            equality.equal(result.data, lastWrite.result.data));
    };
    QueryInfo.prototype.markResult = function (result, options, cacheWriteBehavior) {
        var _this = this;
        this.graphQLErrors = utilities.isNonEmptyArray(result.errors) ? result.errors : [];
        this.reset();
        if (options.fetchPolicy === 'no-cache') {
            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
        }
        else if (cacheWriteBehavior !== 0) {
            if (shouldWriteResult(result, options.errorPolicy)) {
                this.cache.performTransaction(function (cache) {
                    if (_this.shouldWrite(result, options.variables)) {
                        cache.writeQuery({
                            query: _this.document,
                            data: result.data,
                            variables: options.variables,
                            overwrite: cacheWriteBehavior === 1,
                        });
                        _this.lastWrite = {
                            result: result,
                            variables: options.variables,
                            dmCount: destructiveMethodCounts.get(_this.cache),
                        };
                    }
                    else {
                        if (_this.lastDiff &&
                            _this.lastDiff.diff.complete) {
                            result.data = _this.lastDiff.diff.result;
                            return;
                        }
                    }
                    var diffOptions = _this.getDiffOptions(options.variables);
                    var diff = cache.diff(diffOptions);
                    if (!_this.stopped) {
                        _this.updateWatch(options.variables);
                    }
                    _this.updateLastDiff(diff, diffOptions);
                    if (diff.complete) {
                        result.data = diff.result;
                    }
                });
            }
            else {
                this.lastWrite = void 0;
            }
        }
    };
    QueryInfo.prototype.markReady = function () {
        this.networkError = null;
        return this.networkStatus = exports.NetworkStatus.ready;
    };
    QueryInfo.prototype.markError = function (error) {
        this.networkStatus = exports.NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
            this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
            this.networkError = error.networkError;
        }
        return error;
    };
    return QueryInfo;
}());
function shouldWriteResult(result, errorPolicy) {
    if (errorPolicy === void 0) { errorPolicy = "none"; }
    var ignoreErrors = errorPolicy === "ignore" ||
        errorPolicy === "all";
    var writeWithErrors = !utilities.graphQLResultHasError(result);
    if (!writeWithErrors && ignoreErrors && result.data) {
        writeWithErrors = true;
    }
    return writeWithErrors;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var QueryManager = (function () {
    function QueryManager(_a) {
        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
        this.clientAwareness = {};
        this.queries = new Map();
        this.fetchCancelFns = new Map();
        this.transformCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new Map();
        this.cache = cache;
        this.link = link;
        this.defaultOptions = defaultOptions || Object.create(null);
        this.queryDeduplication = queryDeduplication;
        this.clientAwareness = clientAwareness;
        this.localState = localState || new LocalState({ cache: cache });
        this.ssrMode = ssrMode;
        this.assumeImmutableResults = !!assumeImmutableResults;
        if ((this.onBroadcast = onBroadcast)) {
            this.mutationStore = Object.create(null);
        }
    }
    QueryManager.prototype.stop = function () {
        var _this = this;
        this.queries.forEach(function (_info, queryId) {
            _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError('QueryManager stopped while query was in flight') : new globals.InvariantError(11));
    };
    QueryManager.prototype.cancelPendingFetches = function (error) {
        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });
        this.fetchCancelFns.clear();
    };
    QueryManager.prototype.mutate = function (_a) {
        var _b, _c;
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a.keepRootFields, context = _a.context;
        return tslib.__awaiter(this, void 0, void 0, function () {
            var mutationId, mutationStoreValue, self;
            return tslib.__generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        __DEV__ ? globals.invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.') : globals.invariant(mutation, 12);
                        __DEV__ ? globals.invariant(fetchPolicy === 'network-only' ||
                            fetchPolicy === 'no-cache', "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : globals.invariant(fetchPolicy === 'network-only' ||
                            fetchPolicy === 'no-cache', 13);
                        mutationId = this.generateMutationId();
                        mutation = this.transform(mutation).document;
                        variables = this.getVariables(mutation, variables);
                        if (!this.transform(mutation).hasClientExports) return [3, 2];
                        return [4, this.localState.addExportedVariables(mutation, variables, context)];
                    case 1:
                        variables = (_h.sent());
                        _h.label = 2;
                    case 2:
                        mutationStoreValue = this.mutationStore &&
                            (this.mutationStore[mutationId] = {
                                mutation: mutation,
                                variables: variables,
                                loading: true,
                                error: null,
                            });
                        if (optimisticResponse) {
                            this.markMutationOptimistic(optimisticResponse, {
                                mutationId: mutationId,
                                document: mutation,
                                variables: variables,
                                fetchPolicy: fetchPolicy,
                                errorPolicy: errorPolicy,
                                context: context,
                                updateQueries: updateQueries,
                                update: updateWithProxyFn,
                                keepRootFields: keepRootFields,
                            });
                        }
                        this.broadcastQueries();
                        self = this;
                        return [2, new Promise(function (resolve, reject) {
                                return utilities.asyncMap(self.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse: optimisticResponse }), variables, false), function (result) {
                                    if (utilities.graphQLResultHasError(result) && errorPolicy === 'none') {
                                        throw new errors.ApolloError({
                                            graphQLErrors: result.errors,
                                        });
                                    }
                                    if (mutationStoreValue) {
                                        mutationStoreValue.loading = false;
                                        mutationStoreValue.error = null;
                                    }
                                    var storeResult = tslib.__assign({}, result);
                                    if (typeof refetchQueries === "function") {
                                        refetchQueries = refetchQueries(storeResult);
                                    }
                                    if (errorPolicy === 'ignore' &&
                                        utilities.graphQLResultHasError(storeResult)) {
                                        delete storeResult.errors;
                                    }
                                    return self.markMutationResult({
                                        mutationId: mutationId,
                                        result: storeResult,
                                        document: mutation,
                                        variables: variables,
                                        fetchPolicy: fetchPolicy,
                                        errorPolicy: errorPolicy,
                                        context: context,
                                        update: updateWithProxyFn,
                                        updateQueries: updateQueries,
                                        awaitRefetchQueries: awaitRefetchQueries,
                                        refetchQueries: refetchQueries,
                                        removeOptimistic: optimisticResponse ? mutationId : void 0,
                                        onQueryUpdated: onQueryUpdated,
                                        keepRootFields: keepRootFields,
                                    });
                                }).subscribe({
                                    next: function (storeResult) {
                                        self.broadcastQueries();
                                        resolve(storeResult);
                                    },
                                    error: function (err) {
                                        if (mutationStoreValue) {
                                            mutationStoreValue.loading = false;
                                            mutationStoreValue.error = err;
                                        }
                                        if (optimisticResponse) {
                                            self.cache.removeOptimistic(mutationId);
                                        }
                                        self.broadcastQueries();
                                        reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                                            networkError: err,
                                        }));
                                    },
                                });
                            })];
                }
            });
        });
    };
    QueryManager.prototype.markMutationResult = function (mutation, cache) {
        var _this = this;
        if (cache === void 0) { cache = this.cache; }
        var result = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
            cacheWrites.push({
                result: result.data,
                dataId: 'ROOT_MUTATION',
                query: mutation.document,
                variables: mutation.variables,
            });
            var updateQueries_1 = mutation.updateQueries;
            if (updateQueries_1) {
                this.queries.forEach(function (_a, queryId) {
                    var observableQuery = _a.observableQuery;
                    var queryName = observableQuery && observableQuery.queryName;
                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
                        return;
                    }
                    var updater = updateQueries_1[queryName];
                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
                    var _c = cache.diff({
                        query: document,
                        variables: variables,
                        returnPartialData: true,
                        optimistic: false,
                    }), currentQueryResult = _c.result, complete = _c.complete;
                    if (complete && currentQueryResult) {
                        var nextQueryResult = updater(currentQueryResult, {
                            mutationResult: result,
                            queryName: document && utilities.getOperationName(document) || void 0,
                            queryVariables: variables,
                        });
                        if (nextQueryResult) {
                            cacheWrites.push({
                                result: nextQueryResult,
                                dataId: 'ROOT_QUERY',
                                query: document,
                                variables: variables,
                            });
                        }
                    }
                });
            }
        }
        if (cacheWrites.length > 0 ||
            mutation.refetchQueries ||
            mutation.update ||
            mutation.onQueryUpdated ||
            mutation.removeOptimistic) {
            var results_1 = [];
            this.refetchQueries({
                updateCache: function (cache) {
                    if (!skipCache) {
                        cacheWrites.forEach(function (write) { return cache.write(write); });
                    }
                    var update = mutation.update;
                    if (update) {
                        if (!skipCache) {
                            var diff = cache.diff({
                                id: "ROOT_MUTATION",
                                query: _this.transform(mutation.document).asQuery,
                                variables: mutation.variables,
                                optimistic: false,
                                returnPartialData: true,
                            });
                            if (diff.complete) {
                                result = tslib.__assign(tslib.__assign({}, result), { data: diff.result });
                            }
                        }
                        update(cache, result, {
                            context: mutation.context,
                            variables: mutation.variables,
                        });
                    }
                    if (!skipCache && !mutation.keepRootFields) {
                        cache.modify({
                            id: 'ROOT_MUTATION',
                            fields: function (value, _a) {
                                var fieldName = _a.fieldName, DELETE = _a.DELETE;
                                return fieldName === "__typename" ? value : DELETE;
                            },
                        });
                    }
                },
                include: mutation.refetchQueries,
                optimistic: false,
                removeOptimistic: mutation.removeOptimistic,
                onQueryUpdated: mutation.onQueryUpdated || null,
            }).forEach(function (result) { return results_1.push(result); });
            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
                return Promise.all(results_1).then(function () { return result; });
            }
        }
        return Promise.resolve(result);
    };
    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function"
            ? optimisticResponse(mutation.variables)
            : optimisticResponse;
        return this.cache.recordOptimisticTransaction(function (cache) {
            try {
                _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data: data } }), cache);
            }
            catch (error) {
                __DEV__ && globals.invariant.error(error);
            }
        }, mutation.mutationId);
    };
    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {
        return this.fetchQueryObservable(queryId, options, networkStatus).promise;
    };
    QueryManager.prototype.getQueryStore = function () {
        var store = Object.create(null);
        this.queries.forEach(function (info, queryId) {
            store[queryId] = {
                variables: info.variables,
                networkStatus: info.networkStatus,
                networkError: info.networkError,
                graphQLErrors: info.graphQLErrors,
            };
        });
        return store;
    };
    QueryManager.prototype.resetErrors = function (queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
            queryInfo.networkError = undefined;
            queryInfo.graphQLErrors = [];
        }
    };
    QueryManager.prototype.transform = function (document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
            var transformed = this.cache.transformDocument(document);
            var forLink = utilities.removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
            var clientQuery = this.localState.clientQuery(transformed);
            var serverQuery = forLink && this.localState.serverQuery(forLink);
            var cacheEntry_1 = {
                document: transformed,
                hasClientExports: utilities.hasClientExports(transformed),
                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                clientQuery: clientQuery,
                serverQuery: serverQuery,
                defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(transformed)),
                asQuery: tslib.__assign(tslib.__assign({}, transformed), { definitions: transformed.definitions.map(function (def) {
                        if (def.kind === "OperationDefinition" &&
                            def.operation !== "query") {
                            return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
                        }
                        return def;
                    }) })
            };
            var add = function (doc) {
                if (doc && !transformCache.has(doc)) {
                    transformCache.set(doc, cacheEntry_1);
                }
            };
            add(document);
            add(transformed);
            add(clientQuery);
            add(serverQuery);
        }
        return transformCache.get(document);
    };
    QueryManager.prototype.getVariables = function (document, variables) {
        return tslib.__assign(tslib.__assign({}, this.transform(document).defaultVars), variables);
    };
    QueryManager.prototype.watchQuery = function (options) {
        options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(options.query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
            options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
            queryManager: this,
            queryInfo: queryInfo,
            options: options,
        });
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
            document: observable.query,
            observableQuery: observable,
            variables: observable.variables,
        });
        return observable;
    };
    QueryManager.prototype.query = function (options, queryId) {
        var _this = this;
        if (queryId === void 0) { queryId = this.generateQueryId(); }
        __DEV__ ? globals.invariant(options.query, 'query option is required. You must specify your GraphQL document ' +
            'in the query option.') : globals.invariant(options.query, 14);
        __DEV__ ? globals.invariant(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.') : globals.invariant(options.query.kind === 'Document', 15);
        __DEV__ ? globals.invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.') : globals.invariant(!options.returnPartialData, 16);
        __DEV__ ? globals.invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.') : globals.invariant(!options.pollInterval, 17);
        return this.fetchQuery(queryId, options).finally(function () { return _this.stopQuery(queryId); });
    };
    QueryManager.prototype.generateQueryId = function () {
        return String(this.queryIdCounter++);
    };
    QueryManager.prototype.generateRequestId = function () {
        return this.requestIdCounter++;
    };
    QueryManager.prototype.generateMutationId = function () {
        return String(this.mutationIdCounter++);
    };
    QueryManager.prototype.stopQueryInStore = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
            queryInfo.stop();
    };
    QueryManager.prototype.clearStore = function (options) {
        if (options === void 0) { options = {
            discardWatches: true,
        }; }
        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError('Store reset while query was in flight (not completed in link chain)') : new globals.InvariantError(18));
        this.queries.forEach(function (queryInfo) {
            if (queryInfo.observableQuery) {
                queryInfo.networkStatus = exports.NetworkStatus.loading;
            }
            else {
                queryInfo.stop();
            }
        });
        if (this.mutationStore) {
            this.mutationStore = Object.create(null);
        }
        return this.cache.reset(options);
    };
    QueryManager.prototype.getObservableQueries = function (include) {
        var _this = this;
        if (include === void 0) { include = "active"; }
        var queries = new Map();
        var queryNamesAndDocs = new Map();
        var legacyQueryOptions = new Set();
        if (Array.isArray(include)) {
            include.forEach(function (desc) {
                if (typeof desc === "string") {
                    queryNamesAndDocs.set(desc, false);
                }
                else if (utilities.isDocumentNode(desc)) {
                    queryNamesAndDocs.set(_this.transform(desc).document, false);
                }
                else if (utilities.isNonNullObject(desc) && desc.query) {
                    legacyQueryOptions.add(desc);
                }
            });
        }
        this.queries.forEach(function (_a, queryId) {
            var oq = _a.observableQuery, document = _a.document;
            if (oq) {
                if (include === "all") {
                    queries.set(queryId, oq);
                    return;
                }
                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
                if (fetchPolicy === "standby" ||
                    (include === "active" && !oq.hasObservers())) {
                    return;
                }
                if (include === "active" ||
                    (queryName && queryNamesAndDocs.has(queryName)) ||
                    (document && queryNamesAndDocs.has(document))) {
                    queries.set(queryId, oq);
                    if (queryName)
                        queryNamesAndDocs.set(queryName, true);
                    if (document)
                        queryNamesAndDocs.set(document, true);
                }
            }
        });
        if (legacyQueryOptions.size) {
            legacyQueryOptions.forEach(function (options) {
                var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
                var queryInfo = _this.getQuery(queryId).init({
                    document: options.query,
                    variables: options.variables,
                });
                var oq = new ObservableQuery({
                    queryManager: _this,
                    queryInfo: queryInfo,
                    options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "network-only" }),
                });
                globals.invariant(oq.queryId === queryId);
                queryInfo.setObservableQuery(oq);
                queries.set(queryId, oq);
            });
        }
        if (__DEV__ && queryNamesAndDocs.size) {
            queryNamesAndDocs.forEach(function (included, nameOrDoc) {
                if (!included) {
                    __DEV__ && globals.invariant.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
                }
            });
        }
        return queries;
    };
    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
        var _this = this;
        if (includeStandby === void 0) { includeStandby = false; }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function (observableQuery, queryId) {
            var fetchPolicy = observableQuery.options.fetchPolicy;
            observableQuery.resetLastResults();
            if (includeStandby ||
                (fetchPolicy !== "standby" &&
                    fetchPolicy !== "cache-only")) {
                observableQueryPromises.push(observableQuery.refetch());
            }
            _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
    };
    QueryManager.prototype.setObservableQuery = function (observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager.prototype.startGraphQLSubscription = function (_a) {
        var _this = this;
        var query = _a.query, fetchPolicy = _a.fetchPolicy, errorPolicy = _a.errorPolicy, variables = _a.variables, _b = _a.context, context = _b === void 0 ? {} : _b;
        query = this.transform(query).document;
        variables = this.getVariables(query, variables);
        var makeObservable = function (variables) {
            return _this.getObservableFromLink(query, context, variables).map(function (result) {
                if (fetchPolicy !== 'no-cache') {
                    if (shouldWriteResult(result, errorPolicy)) {
                        _this.cache.write({
                            query: query,
                            result: result.data,
                            dataId: 'ROOT_SUBSCRIPTION',
                            variables: variables,
                        });
                    }
                    _this.broadcastQueries();
                }
                if (utilities.graphQLResultHasError(result)) {
                    throw new errors.ApolloError({
                        graphQLErrors: result.errors,
                    });
                }
                return result;
            });
        };
        if (this.transform(query).hasClientExports) {
            var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
            return new utilities.Observable(function (observer) {
                var sub = null;
                observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);
                return function () { return sub && sub.unsubscribe(); };
            });
        }
        return makeObservable(variables);
    };
    QueryManager.prototype.stopQuery = function (queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
    };
    QueryManager.prototype.removeQuery = function (queryId) {
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
            this.getQuery(queryId).stop();
            this.queries.delete(queryId);
        }
    };
    QueryManager.prototype.broadcastQueries = function () {
        if (this.onBroadcast)
            this.onBroadcast();
        this.queries.forEach(function (info) { return info.notify(); });
    };
    QueryManager.prototype.getLocalState = function () {
        return this.localState;
    };
    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
        var _this = this;
        var _a;
        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }
        var observable;
        var serverQuery = this.transform(query).serverQuery;
        if (serverQuery) {
            var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
            var operation = {
                query: serverQuery,
                variables: variables,
                operationName: utilities.getOperationName(serverQuery) || void 0,
                context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication })),
            };
            context = operation.context;
            if (deduplication) {
                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
                inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                var varJson_1 = cache.canonicalStringify(variables);
                observable = byVariables_1.get(varJson_1);
                if (!observable) {
                    var concast = new utilities.Concast([
                        core.execute(link, operation)
                    ]);
                    byVariables_1.set(varJson_1, observable = concast);
                    concast.cleanup(function () {
                        if (byVariables_1.delete(varJson_1) &&
                            byVariables_1.size < 1) {
                            inFlightLinkObservables_1.delete(serverQuery);
                        }
                    });
                }
            }
            else {
                observable = new utilities.Concast([
                    core.execute(link, operation)
                ]);
            }
        }
        else {
            observable = new utilities.Concast([
                utilities.Observable.of({ data: {} })
            ]);
            context = this.prepareContext(context);
        }
        var clientQuery = this.transform(query).clientQuery;
        if (clientQuery) {
            observable = utilities.asyncMap(observable, function (result) {
                return _this.localState.runResolvers({
                    document: clientQuery,
                    remoteResult: result,
                    context: context,
                    variables: variables,
                });
            });
        }
        return observable;
    };
    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        return utilities.asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function (result) {
            var hasErrors = utilities.isNonEmptyArray(result.errors);
            if (requestId >= queryInfo.lastRequestId) {
                if (hasErrors && options.errorPolicy === "none") {
                    throw queryInfo.markError(new errors.ApolloError({
                        graphQLErrors: result.errors,
                    }));
                }
                queryInfo.markResult(result, options, cacheWriteBehavior);
                queryInfo.markReady();
            }
            var aqr = {
                data: result.data,
                loading: false,
                networkStatus: exports.NetworkStatus.ready,
            };
            if (hasErrors && options.errorPolicy !== "ignore") {
                aqr.errors = result.errors;
                aqr.networkStatus = exports.NetworkStatus.error;
            }
            return aqr;
        }, function (networkError) {
            var error = errors.isApolloError(networkError)
                ? networkError
                : new errors.ApolloError({ networkError: networkError });
            if (requestId >= queryInfo.lastRequestId) {
                queryInfo.markError(error);
            }
            throw error;
        });
    };
    QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {
        var _this = this;
        if (networkStatus === void 0) { networkStatus = exports.NetworkStatus.loading; }
        var query = this.transform(options.query).document;
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var defaults = this.defaultOptions.watchQuery;
        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
            query: query,
            variables: variables,
            fetchPolicy: fetchPolicy,
            errorPolicy: errorPolicy,
            returnPartialData: returnPartialData,
            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,
            context: context,
        });
        var fromVariables = function (variables) {
            normalized.variables = variables;
            var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
            if (normalized.fetchPolicy !== "standby" &&
                concastSources.length > 0 &&
                queryInfo.observableQuery) {
                queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
            }
            return concastSources;
        };
        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };
        this.fetchCancelFns.set(queryId, function (reason) {
            cleanupCancelFn();
            setTimeout(function () { return concast.cancel(reason); });
        });
        var concast = new utilities.Concast(this.transform(normalized.query).hasClientExports
            ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables)
            : fromVariables(normalized.variables));
        concast.promise.then(cleanupCancelFn, cleanupCancelFn);
        return concast;
    };
    QueryManager.prototype.refetchQueries = function (_a) {
        var _this = this;
        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
        var includedQueriesById = new Map();
        if (include) {
            this.getObservableQueries(include).forEach(function (oq, queryId) {
                includedQueriesById.set(queryId, {
                    oq: oq,
                    lastDiff: _this.getQuery(queryId).getDiff(),
                });
            });
        }
        var results = new Map;
        if (updateCache) {
            this.cache.batch({
                update: updateCache,
                optimistic: optimistic && removeOptimistic || false,
                removeOptimistic: removeOptimistic,
                onWatchUpdated: function (watch, diff, lastDiff) {
                    var oq = watch.watcher instanceof QueryInfo &&
                        watch.watcher.observableQuery;
                    if (oq) {
                        if (onQueryUpdated) {
                            includedQueriesById.delete(oq.queryId);
                            var result = onQueryUpdated(oq, diff, lastDiff);
                            if (result === true) {
                                result = oq.refetch();
                            }
                            if (result !== false) {
                                results.set(oq, result);
                            }
                            return result;
                        }
                        if (onQueryUpdated !== null) {
                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });
                        }
                    }
                },
            });
        }
        if (includedQueriesById.size) {
            includedQueriesById.forEach(function (_a, queryId) {
                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;
                var result;
                if (onQueryUpdated) {
                    if (!diff) {
                        var info = oq["queryInfo"];
                        info.reset();
                        diff = info.getDiff();
                    }
                    result = onQueryUpdated(oq, diff, lastDiff);
                }
                if (!onQueryUpdated || result === true) {
                    result = oq.refetch();
                }
                if (result !== false) {
                    results.set(oq, result);
                }
                if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
                    _this.stopQueryNoBroadcast(queryId);
                }
            });
        }
        if (removeOptimistic) {
            this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
    };
    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {
        var _this = this;
        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
            document: this.transform(query).document,
            variables: variables,
            networkStatus: networkStatus,
        });
        var readCache = function () { return queryInfo.getDiff(variables); };
        var resultsFromCache = function (diff, networkStatus) {
            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || exports.NetworkStatus.loading; }
            var data = diff.result;
            if (__DEV__ &&
                !returnPartialData &&
                !equality.equal(data, {})) {
                logMissingFieldErrors(diff.missing);
            }
            var fromData = function (data) { return utilities.Observable.of(tslib.__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true }))); };
            if (data && _this.transform(query).hasForcedResolvers) {
                return _this.localState.runResolvers({
                    document: query,
                    remoteResult: { data: data },
                    context: context,
                    variables: variables,
                    onlyRunForcedResolvers: true,
                }).then(function (resolved) { return fromData(resolved.data || void 0); });
            }
            return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 :
            (networkStatus === exports.NetworkStatus.refetch &&
                refetchWritePolicy !== "merge") ? 1
                : 2;
        var resultsFromLink = function () { return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            variables: variables,
            context: context,
            fetchPolicy: fetchPolicy,
            errorPolicy: errorPolicy,
        }); };
        var shouldNotify = notifyOnNetworkStatusChange &&
            typeof oldNetworkStatus === "number" &&
            oldNetworkStatus !== networkStatus &&
            isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
            default:
            case "cache-first": {
                var diff = readCache();
                if (diff.complete) {
                    return [
                        resultsFromCache(diff, queryInfo.markReady()),
                    ];
                }
                if (returnPartialData || shouldNotify) {
                    return [
                        resultsFromCache(diff),
                        resultsFromLink(),
                    ];
                }
                return [
                    resultsFromLink(),
                ];
            }
            case "cache-and-network": {
                var diff = readCache();
                if (diff.complete || returnPartialData || shouldNotify) {
                    return [
                        resultsFromCache(diff),
                        resultsFromLink(),
                    ];
                }
                return [
                    resultsFromLink(),
                ];
            }
            case "cache-only":
                return [
                    resultsFromCache(readCache(), queryInfo.markReady()),
                ];
            case "network-only":
                if (shouldNotify) {
                    return [
                        resultsFromCache(readCache()),
                        resultsFromLink(),
                    ];
                }
                return [resultsFromLink()];
            case "no-cache":
                if (shouldNotify) {
                    return [
                        resultsFromCache(queryInfo.getDiff()),
                        resultsFromLink(),
                    ];
                }
                return [resultsFromLink()];
            case "standby":
                return [];
        }
    };
    QueryManager.prototype.getQuery = function (queryId) {
        if (queryId && !this.queries.has(queryId)) {
            this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
    };
    QueryManager.prototype.prepareContext = function (context) {
        if (context === void 0) { context = {}; }
        var newContext = this.localState.prepareContext(context);
        return tslib.__assign(tslib.__assign({}, newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager;
}());

var hasSuggestedDevtools = false;
var ApolloClient = (function () {
    function ApolloClient(options) {
        var _this = this;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === 'object' &&
            !window.__APOLLO_CLIENT__ &&
            __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
        var link = options.link;
        if (!link) {
            link = uri
                ? new http.HttpLink({ uri: uri, credentials: credentials, headers: headers })
                : core.ApolloLink.empty();
        }
        if (!cache) {
            throw __DEV__ ? new globals.InvariantError("To initialize Apollo Client, you must specify a 'cache' property " +
                "in the options object. \n" +
                "For more information, please visit: https://go.apollo.dev/c/docs") : new globals.InvariantError(7);
        }
        this.link = link;
        this.cache = cache;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions || Object.create(null);
        this.typeDefs = typeDefs;
        if (ssrForceFetchDelay) {
            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        if (connectToDevTools && typeof window === 'object') {
            window.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && __DEV__) {
            hasSuggestedDevtools = true;
            if (typeof window !== 'undefined' &&
                window.document &&
                window.top === window.self &&
                !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                    if (ua.indexOf("Chrome/") > -1) {
                        url = "https://chrome.google.com/webstore/detail/" +
                            "apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                    }
                    else if (ua.indexOf("Firefox/") > -1) {
                        url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                    }
                }
                if (url) {
                    __DEV__ && globals.invariant.log("Download the Apollo DevTools for a better development " +
                        "experience: " + url);
                }
            }
        }
        this.version = version;
        this.localState = new LocalState({
            cache: cache,
            client: this,
            resolvers: resolvers,
            fragmentMatcher: fragmentMatcher,
        });
        this.queryManager = new QueryManager({
            cache: this.cache,
            link: this.link,
            defaultOptions: this.defaultOptions,
            queryDeduplication: queryDeduplication,
            ssrMode: ssrMode,
            clientAwareness: {
                name: clientAwarenessName,
                version: clientAwarenessVersion,
            },
            localState: this.localState,
            assumeImmutableResults: assumeImmutableResults,
            onBroadcast: connectToDevTools ? function () {
                if (_this.devToolsHookCb) {
                    _this.devToolsHookCb({
                        action: {},
                        state: {
                            queries: _this.queryManager.getQueryStore(),
                            mutations: _this.queryManager.mutationStore || {},
                        },
                        dataWithOptimisticResults: _this.cache.extract(true),
                    });
                }
            } : void 0,
        });
    }
    ApolloClient.prototype.stop = function () {
        this.queryManager.stop();
    };
    ApolloClient.prototype.watchQuery = function (options) {
        if (this.defaultOptions.watchQuery) {
            options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches &&
            (options.fetchPolicy === 'network-only' ||
                options.fetchPolicy === 'cache-and-network')) {
            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.watchQuery(options);
    };
    ApolloClient.prototype.query = function (options) {
        if (this.defaultOptions.query) {
            options = utilities.mergeOptions(this.defaultOptions.query, options);
        }
        __DEV__ ? globals.invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +
            'client.query can only return a single result. Please use client.watchQuery ' +
            'to receive multiple results from the cache and the network, or consider ' +
            'using a different fetchPolicy, such as cache-first or network-only.') : globals.invariant(options.fetchPolicy !== 'cache-and-network', 8);
        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.query(options);
    };
    ApolloClient.prototype.mutate = function (options) {
        if (this.defaultOptions.mutate) {
            options = utilities.mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
    };
    ApolloClient.prototype.subscribe = function (options) {
        return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readQuery(options, optimistic);
    };
    ApolloClient.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readFragment(options, optimistic);
    };
    ApolloClient.prototype.writeQuery = function (options) {
        this.cache.writeQuery(options);
        this.queryManager.broadcastQueries();
    };
    ApolloClient.prototype.writeFragment = function (options) {
        this.cache.writeFragment(options);
        this.queryManager.broadcastQueries();
    };
    ApolloClient.prototype.__actionHookForDevTools = function (cb) {
        this.devToolsHookCb = cb;
    };
    ApolloClient.prototype.__requestRaw = function (payload) {
        return core.execute(this.link, payload);
    };
    ApolloClient.prototype.resetStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore({
            discardWatches: false,
        }); })
            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
            .then(function () { return _this.reFetchObservableQueries(); });
    };
    ApolloClient.prototype.clearStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore({
            discardWatches: true,
        }); })
            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });
    };
    ApolloClient.prototype.onResetStore = function (cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function () {
            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.onClearStore = function (cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function () {
            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient.prototype.refetchQueries = function (options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function (result, obsQuery) {
            queries.push(obsQuery);
            results.push(result);
        });
        var result = Promise.all(results);
        result.queries = queries;
        result.results = results;
        result.catch(function (error) {
            __DEV__ && globals.invariant.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
        });
        return result;
    };
    ApolloClient.prototype.getObservableQueries = function (include) {
        if (include === void 0) { include = "active"; }
        return this.queryManager.getObservableQueries(include);
    };
    ApolloClient.prototype.extract = function (optimistic) {
        return this.cache.extract(optimistic);
    };
    ApolloClient.prototype.restore = function (serializedState) {
        return this.cache.restore(serializedState);
    };
    ApolloClient.prototype.addResolvers = function (resolvers) {
        this.localState.addResolvers(resolvers);
    };
    ApolloClient.prototype.setResolvers = function (resolvers) {
        this.localState.setResolvers(resolvers);
    };
    ApolloClient.prototype.getResolvers = function () {
        return this.localState.getResolvers();
    };
    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient.prototype.setLink = function (newLink) {
        this.link = this.queryManager.link = newLink;
    };
    return ApolloClient;
}());

tsInvariant.setVerbosity(globals.DEV ? "log" : "silent");

exports.ApolloCache = cache.ApolloCache;
exports.Cache = cache.Cache;
exports.InMemoryCache = cache.InMemoryCache;
exports.MissingFieldError = cache.MissingFieldError;
exports.defaultDataIdFromObject = cache.defaultDataIdFromObject;
exports.makeVar = cache.makeVar;
exports.Observable = utilities.Observable;
exports.isReference = utilities.isReference;
exports.makeReference = utilities.makeReference;
exports.mergeOptions = utilities.mergeOptions;
exports.ApolloError = errors.ApolloError;
exports.isApolloError = errors.isApolloError;
exports.fromError = utils.fromError;
exports.fromPromise = utils.fromPromise;
exports.throwServerError = utils.throwServerError;
exports.toPromise = utils.toPromise;
exports.setLogVerbosity = tsInvariant.setVerbosity;
exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
exports.gql = graphqlTag.gql;
exports.resetCaches = graphqlTag.resetCaches;
exports.ApolloClient = ApolloClient;
exports.ObservableQuery = ObservableQuery;
for (var k in core) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = core[k];
}
for (var k in http) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = http[k];
}
//# sourceMappingURL=core.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/errors/errors.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@apollo/client/errors/errors.cjs ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var tslib = __webpack_require__(/*! tslib */ "tslib");
__webpack_require__(/*! ../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var utilities = __webpack_require__(/*! ../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");

function isApolloError(err) {
    return err.hasOwnProperty('graphQLErrors');
}
var generateErrorMessage = function (err) {
    var message = '';
    if (utilities.isNonEmptyArray(err.graphQLErrors) || utilities.isNonEmptyArray(err.clientErrors)) {
        var errors = (err.graphQLErrors || [])
            .concat(err.clientErrors || []);
        errors.forEach(function (error) {
            var errorMessage = error
                ? error.message
                : 'Error message not found.';
            message += "".concat(errorMessage, "\n");
        });
    }
    if (err.networkError) {
        message += "".concat(err.networkError.message, "\n");
    }
    message = message.replace(/\n$/, '');
    return message;
};
var ApolloError = (function (_super) {
    tslib.__extends(ApolloError, _super);
    function ApolloError(_a) {
        var graphQLErrors = _a.graphQLErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError.prototype;
        return _this;
    }
    return ApolloError;
}(Error));

exports.ApolloError = ApolloError;
exports.isApolloError = isApolloError;
//# sourceMappingURL=errors.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/link/core/core.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/core.cjs ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var utilities = __webpack_require__(/*! ../../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/@apollo/client/link/utils/utils.cjs");

function passthrough(op, forward) {
    return (forward ? forward(op) : utilities.Observable.of());
}
function toLink(handler) {
    return typeof handler === 'function' ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
    return link.request.length <= 1;
}
var LinkError = (function (_super) {
    tslib.__extends(LinkError, _super);
    function LinkError(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
    }
    return LinkError;
}(Error));
var ApolloLink = (function () {
    function ApolloLink(request) {
        if (request)
            this.request = request;
    }
    ApolloLink.empty = function () {
        return new ApolloLink(function () { return utilities.Observable.of(); });
    };
    ApolloLink.from = function (links) {
        if (links.length === 0)
            return ApolloLink.empty();
        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
    };
    ApolloLink.split = function (test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink(passthrough));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
            return new ApolloLink(function (operation) {
                return test(operation)
                    ? leftLink.request(operation) || utilities.Observable.of()
                    : rightLink.request(operation) || utilities.Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return test(operation)
                    ? leftLink.request(operation, forward) || utilities.Observable.of()
                    : rightLink.request(operation, forward) || utilities.Observable.of();
            });
        }
    };
    ApolloLink.execute = function (link, operation) {
        return (link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of());
    };
    ApolloLink.concat = function (first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
            __DEV__ && globals.invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
            return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
            return new ApolloLink(function (operation) {
                return firstLink.request(operation, function (op) { return nextLink.request(op) || utilities.Observable.of(); }) || utilities.Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return (firstLink.request(operation, function (op) {
                    return nextLink.request(op, forward) || utilities.Observable.of();
                }) || utilities.Observable.of());
            });
        }
    };
    ApolloLink.prototype.split = function (test, left, right) {
        return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));
    };
    ApolloLink.prototype.concat = function (next) {
        return ApolloLink.concat(this, next);
    };
    ApolloLink.prototype.request = function (operation, forward) {
        throw __DEV__ ? new globals.InvariantError('request is not implemented') : new globals.InvariantError(19);
    };
    ApolloLink.prototype.onError = function (error, observer) {
        if (observer && observer.error) {
            observer.error(error);
            return false;
        }
        throw error;
    };
    ApolloLink.prototype.setOnError = function (fn) {
        this.onError = fn;
        return this;
    };
    return ApolloLink;
}());

var empty = ApolloLink.empty;

var from = ApolloLink.from;

var split = ApolloLink.split;

var concat = ApolloLink.concat;

var execute = ApolloLink.execute;

exports.ApolloLink = ApolloLink;
exports.concat = concat;
exports.empty = empty;
exports.execute = execute;
exports.from = from;
exports.split = split;
//# sourceMappingURL=core.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/link/http/http.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/http.cjs ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/@apollo/client/link/utils/utils.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var graphql = __webpack_require__(/*! graphql */ "graphql");
var core = __webpack_require__(/*! ../core */ "./node_modules/@apollo/client/link/core/core.cjs");
var utilities = __webpack_require__(/*! ../../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");

var hasOwnProperty = Object.prototype.hasOwnProperty;
function parseAndCheckHttpResponse(operations) {
    return function (response) { return response
        .text()
        .then(function (bodyText) {
        try {
            return JSON.parse(bodyText);
        }
        catch (err) {
            var parseError = err;
            parseError.name = 'ServerParseError';
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
        }
    })
        .then(function (result) {
        if (response.status >= 300) {
            utils.throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
        }
        if (!Array.isArray(result) &&
            !hasOwnProperty.call(result, 'data') &&
            !hasOwnProperty.call(result, 'errors')) {
            utils.throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations)
                ? operations.map(function (op) { return op.operationName; })
                : operations.operationName, "'."));
        }
        return result;
    }); };
}

var serializeFetchParameter = function (p, label) {
    var serialized;
    try {
        serialized = JSON.stringify(p);
    }
    catch (e) {
        var parseError = __DEV__ ? new globals.InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e.message)) : new globals.InvariantError(21);
        parseError.parseError = e;
        throw parseError;
    }
    return serialized;
};

var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
};
var defaultHeaders = {
    accept: '*/*',
    'content-type': 'application/json',
};
var defaultOptions = {
    method: 'POST',
};
var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions,
};
var defaultPrinter = function (ast, printer) { return printer(ast); };
function selectHttpOptionsAndBody(operation, fallbackConfig) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    configs.unshift(fallbackConfig);
    return selectHttpOptionsAndBodyInternal.apply(void 0, tslib.__spreadArray([operation,
        defaultPrinter], configs, false));
}
function selectHttpOptionsAndBodyInternal(operation, printer) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    var options = {};
    var http = {};
    configs.forEach(function (config) {
        options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), headersToLowerCase(config.headers)) });
        if (config.credentials) {
            options.credentials = config.credentials;
        }
        http = tslib.__assign(tslib.__assign({}, http), config.http);
    });
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName, variables: variables };
    if (http.includeExtensions)
        body.extensions = extensions;
    if (http.includeQuery)
        body.query = printer(query, graphql.print);
    return {
        options: options,
        body: body,
    };
}
function headersToLowerCase(headers) {
    if (headers) {
        var normalized_1 = Object.create(null);
        Object.keys(Object(headers)).forEach(function (name) {
            normalized_1[name.toLowerCase()] = headers[name];
        });
        return normalized_1;
    }
    return headers;
}

var checkFetcher = function (fetcher) {
    if (!fetcher && typeof fetch === 'undefined') {
        throw __DEV__ ? new globals.InvariantError("\n\"fetch\" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    ") : new globals.InvariantError(20);
    }
};

var createSignalIfSupported = function () {
    if (typeof AbortController === 'undefined')
        return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller: controller, signal: signal };
};

var selectURI = function (operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
        return contextURI;
    }
    else if (typeof fallbackURI === 'function') {
        return fallbackURI(operation);
    }
    else {
        return fallbackURI || '/graphql';
    }
};

function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables) {
        var serializedVariables = void 0;
        try {
            serializedVariables = serializeFetchParameter(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    var fragment = '', preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}

var backupFetch = utilities.maybe(function () { return fetch; });
var createHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
    if (__DEV__) {
        checkFetcher(preferredFetch || backupFetch);
    }
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new core.ApolloLink(function (operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
            if (name_1) {
                clientAwarenessHeaders['apollographql-client-name'] = name_1;
            }
            if (version) {
                clientAwarenessHeaders['apollographql-client-version'] = version;
            }
        }
        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: contextHeaders,
        };
        var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        if (body.variables && !includeUnusedVariables) {
            var unusedNames_1 = new Set(Object.keys(body.variables));
            graphql.visit(operation.query, {
                Variable: function (node, _key, parent) {
                    if (parent && parent.kind !== 'VariableDefinition') {
                        unusedNames_1.delete(node.name.value);
                    }
                },
            });
            if (unusedNames_1.size) {
                body.variables = tslib.__assign({}, body.variables);
                unusedNames_1.forEach(function (name) {
                    delete body.variables[name];
                });
            }
        }
        var controller;
        if (!options.signal) {
            var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
            controller = _controller;
            if (controller)
                options.signal = signal;
        }
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
            if (parseError) {
                return utils.fromError(parseError);
            }
            chosenURI = newURI;
        }
        else {
            try {
                options.body = serializeFetchParameter(body, 'Payload');
            }
            catch (parseError) {
                return utils.fromError(parseError);
            }
        }
        return new utilities.Observable(function (observer) {
            var currentFetch = preferredFetch || utilities.maybe(function () { return fetch; }) || backupFetch;
            currentFetch(chosenURI, options)
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then(parseAndCheckHttpResponse(operation))
                .then(function (result) {
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                if (err.name === 'AbortError')
                    return;
                if (err.result && err.result.errors && err.result.data) {
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                if (controller)
                    controller.abort();
            };
        });
    });
};

var HttpLink = (function (_super) {
    tslib.__extends(HttpLink, _super);
    function HttpLink(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, createHttpLink(options).request) || this;
        _this.options = options;
        return _this;
    }
    return HttpLink;
}(core.ApolloLink));

exports.HttpLink = HttpLink;
exports.checkFetcher = checkFetcher;
exports.createHttpLink = createHttpLink;
exports.createSignalIfSupported = createSignalIfSupported;
exports.defaultPrinter = defaultPrinter;
exports.fallbackHttpConfig = fallbackHttpConfig;
exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;
exports.rewriteURIForGET = rewriteURIForGET;
exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;
exports.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal;
exports.selectURI = selectURI;
exports.serializeFetchParameter = serializeFetchParameter;
//# sourceMappingURL=http.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/link/utils/utils.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/utils.cjs ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var utilities = __webpack_require__(/*! ../../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");

function fromError(errorValue) {
    return new utilities.Observable(function (observer) {
        observer.error(errorValue);
    });
}

function toPromise(observable) {
    var completed = false;
    return new Promise(function (resolve, reject) {
        observable.subscribe({
            next: function (data) {
                if (completed) {
                    __DEV__ && globals.invariant.warn("Promise Wrapper does not support multiple results from Observable");
                }
                else {
                    completed = true;
                    resolve(data);
                }
            },
            error: reject,
        });
    });
}

function fromPromise(promise) {
    return new utilities.Observable(function (observer) {
        promise
            .then(function (value) {
            observer.next(value);
            observer.complete();
        })
            .catch(observer.error.bind(observer));
    });
}

var throwServerError = function (response, result, message) {
    var error = new Error(message);
    error.name = 'ServerError';
    error.response = response;
    error.statusCode = response.status;
    error.result = result;
    throw error;
};

function validateOperation(operation) {
    var OPERATION_FIELDS = [
        'query',
        'operationName',
        'variables',
        'extensions',
        'context',
    ];
    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw __DEV__ ? new globals.InvariantError("illegal argument: ".concat(key)) : new globals.InvariantError(24);
        }
    }
    return operation;
}

function createOperation(starting, operation) {
    var context = tslib.__assign({}, starting);
    var setContext = function (next) {
        if (typeof next === 'function') {
            context = tslib.__assign(tslib.__assign({}, context), next(context));
        }
        else {
            context = tslib.__assign(tslib.__assign({}, context), next);
        }
    };
    var getContext = function () { return (tslib.__assign({}, context)); };
    Object.defineProperty(operation, 'setContext', {
        enumerable: false,
        value: setContext,
    });
    Object.defineProperty(operation, 'getContext', {
        enumerable: false,
        value: getContext,
    });
    return operation;
}

function transformOperation(operation) {
    var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query,
    };
    if (!transformedOperation.operationName) {
        transformedOperation.operationName =
            typeof transformedOperation.query !== 'string'
                ? utilities.getOperationName(transformedOperation.query) || undefined
                : '';
    }
    return transformedOperation;
}

exports.createOperation = createOperation;
exports.fromError = fromError;
exports.fromPromise = fromPromise;
exports.throwServerError = throwServerError;
exports.toPromise = toPromise;
exports.transformOperation = transformOperation;
exports.validateOperation = validateOperation;
//# sourceMappingURL=utils.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/main.cjs":
/*!**********************************************!*\
  !*** ./node_modules/@apollo/client/main.cjs ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var core = __webpack_require__(/*! ./core */ "./node_modules/@apollo/client/core/core.cjs");
var react = __webpack_require__(/*! ./react */ "./node_modules/@apollo/client/react/react.cjs");



for (var k in core) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = core[k];
}
for (var k in react) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = react[k];
}
//# sourceMappingURL=main.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/react/context/context.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/react/context/context.cjs ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var React = __webpack_require__(/*! react */ "react");
var utilities = __webpack_require__(/*! ../../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        for (var k in e) {
            n[k] = e[k];
        }
    }
    n["default"] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var contextKey = utilities.canUseSymbol
    ? Symbol.for('__APOLLO_CONTEXT__')
    : '__APOLLO_CONTEXT__';
function getApolloContext() {
    var context = React__namespace.createContext[contextKey];
    if (!context) {
        Object.defineProperty(React__namespace.createContext, contextKey, {
            value: context = React__namespace.createContext({}),
            enumerable: false,
            writable: false,
            configurable: true,
        });
        context.displayName = 'ApolloContext';
    }
    return context;
}

var ApolloConsumer = function (props) {
    var ApolloContext = getApolloContext();
    return (React__namespace.createElement(ApolloContext.Consumer, null, function (context) {
        __DEV__ ? globals.invariant(context && context.client, 'Could not find "client" in the context of ApolloConsumer. ' +
            'Wrap the root component in an <ApolloProvider>.') : globals.invariant(context && context.client, 25);
        return props.children(context.client);
    }));
};

var ApolloProvider = function (_a) {
    var client = _a.client, children = _a.children;
    var ApolloContext = getApolloContext();
    return (React__namespace.createElement(ApolloContext.Consumer, null, function (context) {
        if (context === void 0) { context = {}; }
        if (client && context.client !== client) {
            context = Object.assign({}, context, { client: client });
        }
        __DEV__ ? globals.invariant(context.client, 'ApolloProvider was not passed a client instance. Make ' +
            'sure you pass in your client via the "client" prop.') : globals.invariant(context.client, 26);
        return (React__namespace.createElement(ApolloContext.Provider, { value: context }, children));
    }));
};

exports.ApolloConsumer = ApolloConsumer;
exports.ApolloProvider = ApolloProvider;
exports.getApolloContext = getApolloContext;
exports.resetApolloContext = getApolloContext;
//# sourceMappingURL=context.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/react/hooks/hooks.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/hooks.cjs ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var React = __webpack_require__(/*! react */ "react");
var context = __webpack_require__(/*! ../context */ "./node_modules/@apollo/client/react/context/context.cjs");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var utilities = __webpack_require__(/*! ../../utilities */ "./node_modules/@apollo/client/utilities/utilities.cjs");
var equality = __webpack_require__(/*! @wry/equality */ "@wry/equality");
var core = __webpack_require__(/*! ../../core */ "./node_modules/@apollo/client/core/core.cjs");
var errors = __webpack_require__(/*! ../../errors */ "./node_modules/@apollo/client/errors/errors.cjs");
var parser = __webpack_require__(/*! ../parser */ "./node_modules/@apollo/client/react/parser/parser.cjs");

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        for (var k in e) {
            n[k] = e[k];
        }
    }
    n["default"] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function useApolloClient(override) {
    var context$1 = React.useContext(context.getApolloContext());
    var client = override || context$1.client;
    __DEV__ ? globals.invariant(!!client, 'Could not find "client" in the context or passed in as an option. ' +
        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +
        'instance in via options.') : globals.invariant(!!client, 29);
    return client;
}

var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React__namespace[uSESKey];
var useSyncExternalStore = realHook || (function (subscribe, getSnapshot, getServerSnapshot) {
    var value = getSnapshot();
    if (__DEV__ &&
        !didWarnUncachedGetSnapshot &&
        value !== getSnapshot()) {
        didWarnUncachedGetSnapshot = true;
        __DEV__ && globals.invariant.error('The result of getSnapshot should be cached to avoid an infinite loop');
    }
    var _a = React__namespace.useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _a[0].inst, forceUpdate = _a[1];
    if (utilities.canUseLayoutEffect) {
        React__namespace.useLayoutEffect(function () {
            Object.assign(inst, { value: value, getSnapshot: getSnapshot });
            if (checkIfSnapshotChanged(inst)) {
                forceUpdate({ inst: inst });
            }
        }, [subscribe, value, getSnapshot]);
    }
    else {
        Object.assign(inst, { value: value, getSnapshot: getSnapshot });
    }
    React__namespace.useEffect(function () {
        if (checkIfSnapshotChanged(inst)) {
            forceUpdate({ inst: inst });
        }
        return subscribe(function handleStoreChange() {
            if (checkIfSnapshotChanged(inst)) {
                forceUpdate({ inst: inst });
            }
        });
    }, [subscribe]);
    return value;
});
function checkIfSnapshotChanged(_a) {
    var value = _a.value, getSnapshot = _a.getSnapshot;
    try {
        return value !== getSnapshot();
    }
    catch (_b) {
        return true;
    }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function useQuery(query, options) {
    if (options === void 0) { options = Object.create(null); }
    return useInternalState(useApolloClient(options.client), query).useQuery(options);
}
function useInternalState(client, query) {
    var stateRef = React.useRef();
    if (!stateRef.current ||
        client !== stateRef.current.client ||
        query !== stateRef.current.query) {
        stateRef.current = new InternalState(client, query, stateRef.current);
    }
    var state = stateRef.current;
    var _a = React.useState(0); _a[0]; var setTick = _a[1];
    state.forceUpdate = function () {
        setTick(function (tick) { return tick + 1; });
    };
    return state;
}
var InternalState = (function () {
    function InternalState(client, query, previous) {
        this.client = client;
        this.query = query;
        this.asyncResolveFns = new Set();
        this.optionsToIgnoreOnce = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.ssrDisabledResult = utilities.maybeDeepFreeze({
            loading: true,
            data: void 0,
            error: void 0,
            networkStatus: core.NetworkStatus.loading,
        });
        this.skipStandbyResult = utilities.maybeDeepFreeze({
            loading: false,
            data: void 0,
            error: void 0,
            networkStatus: core.NetworkStatus.ready,
        });
        this.toQueryResultCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
        parser.verifyDocumentType(query, parser.DocumentType.Query);
        var previousResult = previous && previous.result;
        var previousData = previousResult && previousResult.data;
        if (previousData) {
            this.previousData = previousData;
        }
    }
    InternalState.prototype.forceUpdate = function () {
        __DEV__ && globals.invariant.warn("Calling default no-op implementation of InternalState#forceUpdate");
    };
    InternalState.prototype.asyncUpdate = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.asyncResolveFns.add(resolve);
            _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);
            _this.forceUpdate();
        });
    };
    InternalState.prototype.useQuery = function (options) {
        var _this = this;
        this.renderPromises = React.useContext(context.getApolloContext()).renderPromises;
        this.useOptions(options);
        var obsQuery = this.useObservableQuery();
        var result = useSyncExternalStore(React.useCallback(function () {
            if (_this.renderPromises) {
                return function () { };
            }
            var onNext = function () {
                var previousResult = _this.result;
                var result = obsQuery.getCurrentResult();
                if (previousResult &&
                    previousResult.loading === result.loading &&
                    previousResult.networkStatus === result.networkStatus &&
                    equality.equal(previousResult.data, result.data)) {
                    return;
                }
                _this.setResult(result);
            };
            var onError = function (error) {
                var last = obsQuery["last"];
                subscription.unsubscribe();
                try {
                    obsQuery.resetLastResults();
                    subscription = obsQuery.subscribe(onNext, onError);
                }
                finally {
                    obsQuery["last"] = last;
                }
                if (!hasOwnProperty.call(error, 'graphQLErrors')) {
                    throw error;
                }
                var previousResult = _this.result;
                if (!previousResult ||
                    (previousResult && previousResult.loading) ||
                    !equality.equal(error, previousResult.error)) {
                    _this.setResult({
                        data: (previousResult && previousResult.data),
                        error: error,
                        loading: false,
                        networkStatus: core.NetworkStatus.error,
                    });
                }
            };
            var subscription = obsQuery.subscribe(onNext, onError);
            return function () { return subscription.unsubscribe(); };
        }, [
            obsQuery,
            this.renderPromises,
            this.client.disableNetworkFetches,
        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });
        this.unsafeHandlePartialRefetch(result);
        var queryResult = this.toQueryResult(result);
        if (!queryResult.loading && this.asyncResolveFns.size) {
            this.asyncResolveFns.forEach(function (resolve) { return resolve(queryResult); });
            this.asyncResolveFns.clear();
        }
        return queryResult;
    };
    InternalState.prototype.useOptions = function (options) {
        var _a;
        var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);
        var currentWatchQueryOptions = this.watchQueryOptions;
        if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||
            !equality.equal(watchQueryOptions, currentWatchQueryOptions)) {
            this.watchQueryOptions = watchQueryOptions;
            if (currentWatchQueryOptions && this.observable) {
                this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);
                this.observable.reobserve(this.getObsQueryOptions());
                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;
                this.result = void 0;
            }
        }
        this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;
        this.onError = options.onError || InternalState.prototype.onError;
        if ((this.renderPromises || this.client.disableNetworkFetches) &&
            this.queryHookOptions.ssr === false &&
            !this.queryHookOptions.skip) {
            this.result = this.ssrDisabledResult;
        }
        else if (this.queryHookOptions.skip ||
            this.watchQueryOptions.fetchPolicy === 'standby') {
            this.result = this.skipStandbyResult;
        }
        else if (this.result === this.ssrDisabledResult ||
            this.result === this.skipStandbyResult) {
            this.result = void 0;
        }
    };
    InternalState.prototype.getObsQueryOptions = function () {
        var toMerge = [];
        var globalDefaults = this.client.defaultOptions.watchQuery;
        if (globalDefaults)
            toMerge.push(globalDefaults);
        if (this.queryHookOptions.defaultOptions) {
            toMerge.push(this.queryHookOptions.defaultOptions);
        }
        toMerge.push(utilities.compact(this.observable && this.observable.options, this.watchQueryOptions));
        return toMerge.reduce(core.mergeOptions);
    };
    InternalState.prototype.createWatchQueryOptions = function (_a) {
        var _b;
        if (_a === void 0) { _a = {}; }
        var skip = _a.skip; _a.ssr; _a.onCompleted; _a.onError; _a.displayName; _a.defaultOptions; var otherOptions = tslib.__rest(_a, ["skip", "ssr", "onCompleted", "onError", "displayName", "defaultOptions"]);
        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });
        if (this.renderPromises &&
            (watchQueryOptions.fetchPolicy === 'network-only' ||
                watchQueryOptions.fetchPolicy === 'cache-and-network')) {
            watchQueryOptions.fetchPolicy = 'cache-first';
        }
        if (!watchQueryOptions.variables) {
            watchQueryOptions.variables = {};
        }
        if (skip) {
            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;
            Object.assign(watchQueryOptions, {
                initialFetchPolicy: initialFetchPolicy,
                fetchPolicy: 'standby',
            });
        }
        else if (!watchQueryOptions.fetchPolicy) {
            watchQueryOptions.fetchPolicy =
                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||
                    this.getDefaultFetchPolicy();
        }
        return watchQueryOptions;
    };
    InternalState.prototype.getDefaultFetchPolicy = function () {
        var _a, _b;
        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||
            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||
            "cache-first");
    };
    InternalState.prototype.onCompleted = function (data) { };
    InternalState.prototype.onError = function (error) { };
    InternalState.prototype.useObservableQuery = function () {
        var obsQuery = this.observable =
            this.renderPromises
                && this.renderPromises.getSSRObservable(this.watchQueryOptions)
                || this.observable
                || this.client.watchQuery(this.getObsQueryOptions());
        this.obsQueryFields = React.useMemo(function () { return ({
            refetch: obsQuery.refetch.bind(obsQuery),
            reobserve: obsQuery.reobserve.bind(obsQuery),
            fetchMore: obsQuery.fetchMore.bind(obsQuery),
            updateQuery: obsQuery.updateQuery.bind(obsQuery),
            startPolling: obsQuery.startPolling.bind(obsQuery),
            stopPolling: obsQuery.stopPolling.bind(obsQuery),
            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),
        }); }, [obsQuery]);
        var ssrAllowed = !(this.queryHookOptions.ssr === false ||
            this.queryHookOptions.skip);
        if (this.renderPromises && ssrAllowed) {
            this.renderPromises.registerSSRObservable(obsQuery);
            if (obsQuery.getCurrentResult().loading) {
                this.renderPromises.addObservableQueryPromise(obsQuery);
            }
        }
        return obsQuery;
    };
    InternalState.prototype.setResult = function (nextResult) {
        var previousResult = this.result;
        if (previousResult && previousResult.data) {
            this.previousData = previousResult.data;
        }
        this.result = nextResult;
        this.forceUpdate();
        this.handleErrorOrCompleted(nextResult);
    };
    InternalState.prototype.handleErrorOrCompleted = function (result) {
        if (!result.loading) {
            if (result.error) {
                this.onError(result.error);
            }
            else if (result.data) {
                this.onCompleted(result.data);
            }
        }
    };
    InternalState.prototype.getCurrentResult = function () {
        if (!this.result) {
            this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());
        }
        return this.result;
    };
    InternalState.prototype.toQueryResult = function (result) {
        var queryResult = this.toQueryResultCache.get(result);
        if (queryResult)
            return queryResult;
        var data = result.data; result.partial; var resultWithoutPartial = tslib.__rest(result, ["data", "partial"]);
        this.toQueryResultCache.set(result, queryResult = tslib.__assign(tslib.__assign(tslib.__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));
        if (!queryResult.error && utilities.isNonEmptyArray(result.errors)) {
            queryResult.error = new errors.ApolloError({ graphQLErrors: result.errors });
        }
        return queryResult;
    };
    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {
        if (result.partial &&
            this.queryHookOptions.partialRefetch &&
            !result.loading &&
            (!result.data || Object.keys(result.data).length === 0) &&
            this.observable.options.fetchPolicy !== 'cache-only') {
            Object.assign(result, {
                loading: true,
                networkStatus: core.NetworkStatus.refetch,
            });
            this.observable.refetch();
        }
    };
    return InternalState;
}());

var EAGER_METHODS = [
    'refetch',
    'reobserve',
    'fetchMore',
    'updateQuery',
    'startPolling',
    'subscribeToMore',
];
function useLazyQuery(query, options) {
    var internalState = useInternalState(useApolloClient(options && options.client), query);
    var execOptionsRef = React.useRef();
    var merged = execOptionsRef.current
        ? utilities.mergeOptions(options, execOptionsRef.current)
        : options;
    var useQueryResult = internalState.useQuery(tslib.__assign(tslib.__assign({}, merged), { skip: !execOptionsRef.current }));
    var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy ||
        internalState.getDefaultFetchPolicy();
    var result = Object.assign(useQueryResult, {
        called: !!execOptionsRef.current,
    });
    var eagerMethods = React.useMemo(function () {
        var eagerMethods = {};
        var _loop_1 = function (key) {
            var method = result[key];
            eagerMethods[key] = function () {
                if (!execOptionsRef.current) {
                    execOptionsRef.current = Object.create(null);
                    internalState.forceUpdate();
                }
                return method.apply(this, arguments);
            };
        };
        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
            var key = EAGER_METHODS_1[_i];
            _loop_1(key);
        }
        return eagerMethods;
    }, []);
    Object.assign(result, eagerMethods);
    var execute = React.useCallback(function (executeOptions) {
        execOptionsRef.current = executeOptions ? tslib.__assign(tslib.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
            fetchPolicy: initialFetchPolicy,
        };
        var promise = internalState
            .asyncUpdate()
            .then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });
        promise.catch(function () { });
        return promise;
    }, []);
    return [execute, result];
}

function useMutation(mutation, options) {
    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
    parser.verifyDocumentType(mutation, parser.DocumentType.Mutation);
    var _a = React.useState({
        called: false,
        loading: false,
        client: client,
    }), result = _a[0], setResult = _a[1];
    var ref = React.useRef({
        result: result,
        mutationId: 0,
        isMounted: true,
        client: client,
        mutation: mutation,
        options: options,
    });
    {
        Object.assign(ref.current, { client: client, options: options, mutation: mutation });
    }
    var execute = React.useCallback(function (executeOptions) {
        if (executeOptions === void 0) { executeOptions = {}; }
        var _a = ref.current, client = _a.client, options = _a.options, mutation = _a.mutation;
        var baseOptions = tslib.__assign(tslib.__assign({}, options), { mutation: mutation });
        if (!ref.current.result.loading && !baseOptions.ignoreResults) {
            setResult(ref.current.result = {
                loading: true,
                error: void 0,
                data: void 0,
                called: true,
                client: client,
            });
        }
        var mutationId = ++ref.current.mutationId;
        var clientOptions = core.mergeOptions(baseOptions, executeOptions);
        return client.mutate(clientOptions).then(function (response) {
            var _a, _b, _c;
            var data = response.data, errors$1 = response.errors;
            var error = errors$1 && errors$1.length > 0
                ? new errors.ApolloError({ graphQLErrors: errors$1 })
                : void 0;
            if (mutationId === ref.current.mutationId &&
                !clientOptions.ignoreResults) {
                var result_1 = {
                    called: true,
                    loading: false,
                    data: data,
                    error: error,
                    client: client,
                };
                if (ref.current.isMounted && !equality.equal(ref.current.result, result_1)) {
                    setResult(ref.current.result = result_1);
                }
            }
            (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, response.data);
            (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data);
            return response;
        }).catch(function (error) {
            var _a, _b, _c, _d;
            if (mutationId === ref.current.mutationId &&
                ref.current.isMounted) {
                var result_2 = {
                    loading: false,
                    error: error,
                    data: void 0,
                    called: true,
                    client: client,
                };
                if (!equality.equal(ref.current.result, result_2)) {
                    setResult(ref.current.result = result_2);
                }
            }
            if (((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) || clientOptions.onError) {
                (_c = (_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error);
                (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error);
                return { data: void 0, errors: error };
            }
            throw error;
        });
    }, []);
    var reset = React.useCallback(function () {
        setResult({ called: false, loading: false, client: client });
    }, []);
    React.useEffect(function () {
        ref.current.isMounted = true;
        return function () {
            ref.current.isMounted = false;
        };
    }, []);
    return [execute, tslib.__assign({ reset: reset }, result)];
}

function useSubscription(subscription, options) {
    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
    parser.verifyDocumentType(subscription, parser.DocumentType.Subscription);
    var _a = React.useState({
        loading: !(options === null || options === void 0 ? void 0 : options.skip),
        error: void 0,
        data: void 0,
        variables: options === null || options === void 0 ? void 0 : options.variables,
    }), result = _a[0], setResult = _a[1];
    var _b = React.useState(function () {
        if (options === null || options === void 0 ? void 0 : options.skip) {
            return null;
        }
        return client.subscribe({
            query: subscription,
            variables: options === null || options === void 0 ? void 0 : options.variables,
            fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
            context: options === null || options === void 0 ? void 0 : options.context,
        });
    }), observable = _b[0], setObservable = _b[1];
    var canResetObservableRef = React.useRef(false);
    React.useEffect(function () {
        return function () {
            canResetObservableRef.current = true;
        };
    }, []);
    var ref = React.useRef({ client: client, subscription: subscription, options: options });
    React.useEffect(function () {
        var _a, _b, _c, _d;
        var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;
        if (typeof shouldResubscribe === 'function') {
            shouldResubscribe = !!shouldResubscribe(options);
        }
        if (options === null || options === void 0 ? void 0 : options.skip) {
            if (!(options === null || options === void 0 ? void 0 : options.skip) !== !((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.skip) || canResetObservableRef.current) {
                setResult({
                    loading: false,
                    data: void 0,
                    error: void 0,
                    variables: options === null || options === void 0 ? void 0 : options.variables,
                });
                setObservable(null);
                canResetObservableRef.current = false;
            }
        }
        else if ((shouldResubscribe !== false &&
            (client !== ref.current.client ||
                subscription !== ref.current.subscription ||
                (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||
                !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) ||
                !equality.equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables))) ||
            canResetObservableRef.current) {
            setResult({
                loading: true,
                data: void 0,
                error: void 0,
                variables: options === null || options === void 0 ? void 0 : options.variables,
            });
            setObservable(client.subscribe({
                query: subscription,
                variables: options === null || options === void 0 ? void 0 : options.variables,
                fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
                context: options === null || options === void 0 ? void 0 : options.context,
            }));
            canResetObservableRef.current = false;
        }
        Object.assign(ref.current, { client: client, subscription: subscription, options: options });
    }, [client, subscription, options, canResetObservableRef.current]);
    React.useEffect(function () {
        if (!observable) {
            return;
        }
        var subscription = observable.subscribe({
            next: function (fetchResult) {
                var _a, _b;
                var result = {
                    loading: false,
                    data: fetchResult.data,
                    error: void 0,
                    variables: options === null || options === void 0 ? void 0 : options.variables,
                };
                setResult(result);
                (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onSubscriptionData) === null || _b === void 0 ? void 0 : _b.call(_a, {
                    client: client,
                    subscriptionData: result
                });
            },
            error: function (error) {
                setResult({
                    loading: false,
                    data: void 0,
                    error: error,
                    variables: options === null || options === void 0 ? void 0 : options.variables,
                });
            },
            complete: function () {
                var _a, _b;
                (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onSubscriptionComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
            },
        });
        return function () {
            subscription.unsubscribe();
        };
    }, [observable]);
    return result;
}

function useReactiveVar(rv) {
    var value = rv();
    var setValue = React.useState(value)[1];
    React.useEffect(function () {
        var probablySameValue = rv();
        if (value !== probablySameValue) {
            setValue(probablySameValue);
        }
        else {
            return rv.onNextChange(setValue);
        }
    }, [value]);
    return value;
}

exports.useApolloClient = useApolloClient;
exports.useLazyQuery = useLazyQuery;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useReactiveVar = useReactiveVar;
exports.useSubscription = useSubscription;
//# sourceMappingURL=hooks.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/react/parser/parser.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/react/parser/parser.cjs ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ../../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");

exports.DocumentType = void 0;
(function (DocumentType) {
    DocumentType[DocumentType["Query"] = 0] = "Query";
    DocumentType[DocumentType["Mutation"] = 1] = "Mutation";
    DocumentType[DocumentType["Subscription"] = 2] = "Subscription";
})(exports.DocumentType || (exports.DocumentType = {}));
var cache = new Map();
function operationName(type) {
    var name;
    switch (type) {
        case exports.DocumentType.Query:
            name = 'Query';
            break;
        case exports.DocumentType.Mutation:
            name = 'Mutation';
            break;
        case exports.DocumentType.Subscription:
            name = 'Subscription';
            break;
    }
    return name;
}
function parser(document) {
    var cached = cache.get(document);
    if (cached)
        return cached;
    var variables, type, name;
    __DEV__ ? globals.invariant(!!document && !!document.kind, "Argument of ".concat(document, " passed to parser was not a valid GraphQL ") +
        "DocumentNode. You may need to use 'graphql-tag' or another method " +
        "to convert your operation into a document") : globals.invariant(!!document && !!document.kind, 30);
    var fragments = [];
    var queries = [];
    var mutations = [];
    var subscriptions = [];
    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {
        var x = _a[_i];
        if (x.kind === 'FragmentDefinition') {
            fragments.push(x);
            continue;
        }
        if (x.kind === 'OperationDefinition') {
            switch (x.operation) {
                case 'query':
                    queries.push(x);
                    break;
                case 'mutation':
                    mutations.push(x);
                    break;
                case 'subscription':
                    subscriptions.push(x);
                    break;
            }
        }
    }
    __DEV__ ? globals.invariant(!fragments.length ||
        (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. " +
        "You must include a query, subscription or mutation as well") : globals.invariant(!fragments.length ||
        (queries.length || mutations.length || subscriptions.length), 31);
    __DEV__ ? globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " +
        "".concat(document, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") +
        "subscriptions and ".concat(mutations.length, " mutations. ") +
        "You can use 'compose' to join multiple operation types to a component") : globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, 32);
    type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;
    if (!queries.length && !mutations.length)
        type = exports.DocumentType.Subscription;
    var definitions = queries.length
        ? queries
        : mutations.length
            ? mutations
            : subscriptions;
    __DEV__ ? globals.invariant(definitions.length === 1, "react-apollo only supports one definition per HOC. ".concat(document, " had ") +
        "".concat(definitions.length, " definitions. ") +
        "You can use 'compose' to join multiple operation types to a component") : globals.invariant(definitions.length === 1, 33);
    var definition = definitions[0];
    variables = definition.variableDefinitions || [];
    if (definition.name && definition.name.kind === 'Name') {
        name = definition.name.value;
    }
    else {
        name = 'data';
    }
    var payload = { name: name, type: type, variables: variables };
    cache.set(document, payload);
    return payload;
}
function verifyDocumentType(document, type) {
    var operation = parser(document);
    var requiredOperationName = operationName(type);
    var usedOperationName = operationName(operation.type);
    __DEV__ ? globals.invariant(operation.type === type, "Running a ".concat(requiredOperationName, " requires a graphql ") +
        "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : globals.invariant(operation.type === type, 34);
}

exports.operationName = operationName;
exports.parser = parser;
exports.verifyDocumentType = verifyDocumentType;
//# sourceMappingURL=parser.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/react/react.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/react/react.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

__webpack_require__(/*! ../utilities/globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var context = __webpack_require__(/*! ./context */ "./node_modules/@apollo/client/react/context/context.cjs");
var hooks = __webpack_require__(/*! ./hooks */ "./node_modules/@apollo/client/react/hooks/hooks.cjs");
var parser = __webpack_require__(/*! ./parser */ "./node_modules/@apollo/client/react/parser/parser.cjs");



exports.ApolloConsumer = context.ApolloConsumer;
exports.ApolloProvider = context.ApolloProvider;
exports.getApolloContext = context.getApolloContext;
exports.resetApolloContext = context.resetApolloContext;
exports.DocumentType = parser.DocumentType;
exports.operationName = parser.operationName;
exports.parser = parser.parser;
for (var k in hooks) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = hooks[k];
}
//# sourceMappingURL=react.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/utilities/globals/globals.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/globals.cjs ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var tsInvariant = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.cjs");
var process$1 = __webpack_require__(/*! ts-invariant/process */ "./node_modules/ts-invariant/process/main.cjs");
var graphql = __webpack_require__(/*! graphql */ "graphql");

function maybe(thunk) {
    try {
        return thunk();
    }
    catch (_a) { }
}

var global$1 = (maybe(function () { return globalThis; }) ||
    maybe(function () { return window; }) ||
    maybe(function () { return self; }) ||
    maybe(function () { return global; }) ||
    maybe(function () { return maybe.constructor("return this")(); }));

var __ = "__";
var GLOBAL_KEY = [__, __].join("DEV");
function getDEV() {
    try {
        return Boolean(__DEV__);
    }
    catch (_a) {
        Object.defineProperty(global$1, GLOBAL_KEY, {
            value: maybe(function () { return "development"; }) !== "production",
            enumerable: false,
            configurable: true,
            writable: true,
        });
        return global$1[GLOBAL_KEY];
    }
}
var DEV = getDEV();

function removeTemporaryGlobals() {
    return typeof graphql.Source === "function" ? process$1.remove() : process$1.remove();
}

function checkDEV() {
    __DEV__ ? tsInvariant.invariant("boolean" === typeof DEV, DEV) : tsInvariant.invariant("boolean" === typeof DEV, 36);
}
removeTemporaryGlobals();
checkDEV();

exports.InvariantError = tsInvariant.InvariantError;
exports.invariant = tsInvariant.invariant;
exports.DEV = DEV;
exports.checkDEV = checkDEV;
exports.global = global$1;
exports.maybe = maybe;
//# sourceMappingURL=globals.cjs.map


/***/ }),

/***/ "./node_modules/@apollo/client/utilities/utilities.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/utilities.cjs ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var globals = __webpack_require__(/*! ./globals */ "./node_modules/@apollo/client/utilities/globals/globals.cjs");
var graphql = __webpack_require__(/*! graphql */ "graphql");
var tslib = __webpack_require__(/*! tslib */ "tslib");
var zenObservableTs = __webpack_require__(/*! zen-observable-ts */ "./node_modules/zen-observable-ts/index.cjs");
__webpack_require__(/*! symbol-observable */ "symbol-observable");

function shouldInclude(_a, variables) {
    var directives = _a.directives;
    if (!directives || !directives.length) {
        return true;
    }
    return getInclusionDirectives(directives).every(function (_a) {
        var directive = _a.directive, ifArgument = _a.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === 'Variable') {
            evaledValue = variables && variables[ifArgument.value.name.value];
            __DEV__ ? globals.invariant(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : globals.invariant(evaledValue !== void 0, 37);
        }
        else {
            evaledValue = ifArgument.value.value;
        }
        return directive.name.value === 'skip' ? !evaledValue : evaledValue;
    });
}
function getDirectiveNames(root) {
    var names = [];
    graphql.visit(root, {
        Directive: function (node) {
            names.push(node.name.value);
        },
    });
    return names;
}
function hasDirectives(names, root) {
    return getDirectiveNames(root).some(function (name) { return names.indexOf(name) > -1; });
}
function hasClientExports(document) {
    return (document &&
        hasDirectives(['client'], document) &&
        hasDirectives(['export'], document));
}
function isInclusionDirective(_a) {
    var value = _a.name.value;
    return value === 'skip' || value === 'include';
}
function getInclusionDirectives(directives) {
    var result = [];
    if (directives && directives.length) {
        directives.forEach(function (directive) {
            if (!isInclusionDirective(directive))
                return;
            var directiveArguments = directive.arguments;
            var directiveName = directive.name.value;
            __DEV__ ? globals.invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : globals.invariant(directiveArguments && directiveArguments.length === 1, 38);
            var ifArgument = directiveArguments[0];
            __DEV__ ? globals.invariant(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @".concat(directiveName, " directive.")) : globals.invariant(ifArgument.name && ifArgument.name.value === 'if', 39);
            var ifValue = ifArgument.value;
            __DEV__ ? globals.invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : globals.invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 40);
            result.push({ directive: directive, ifArgument: ifArgument });
        });
    }
    return result;
}

function getFragmentQueryDocument(document, fragmentName) {
    var actualFragmentName = fragmentName;
    var fragments = [];
    document.definitions.forEach(function (definition) {
        if (definition.kind === 'OperationDefinition') {
            throw __DEV__ ? new globals.InvariantError("Found a ".concat(definition.operation, " operation").concat(definition.name ? " named '".concat(definition.name.value, "'") : '', ". ") +
                'No operations are allowed when using a fragment as a query. Only fragments are allowed.') : new globals.InvariantError(41);
        }
        if (definition.kind === 'FragmentDefinition') {
            fragments.push(definition);
        }
    });
    if (typeof actualFragmentName === 'undefined') {
        __DEV__ ? globals.invariant(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : globals.invariant(fragments.length === 1, 42);
        actualFragmentName = fragments[0].name.value;
    }
    var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([
            {
                kind: 'OperationDefinition',
                operation: 'query',
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'FragmentSpread',
                            name: {
                                kind: 'Name',
                                value: actualFragmentName,
                            },
                        },
                    ],
                },
            }
        ], document.definitions, true) });
    return query;
}
function createFragmentMap(fragments) {
    if (fragments === void 0) { fragments = []; }
    var symTable = {};
    fragments.forEach(function (fragment) {
        symTable[fragment.name.value] = fragment;
    });
    return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
    switch (selection.kind) {
        case 'InlineFragment':
            return selection;
        case 'FragmentSpread': {
            var fragment = fragmentMap && fragmentMap[selection.name.value];
            __DEV__ ? globals.invariant(fragment, "No fragment named ".concat(selection.name.value, ".")) : globals.invariant(fragment, 43);
            return fragment;
        }
        default:
            return null;
    }
}

function isNonNullObject(obj) {
    return obj !== null && typeof obj === 'object';
}

function makeReference(id) {
    return { __ref: String(id) };
}
function isReference(obj) {
    return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');
}
function isDocumentNode(value) {
    return (isNonNullObject(value) &&
        value.kind === "Document" &&
        Array.isArray(value.definitions));
}
function isStringValue(value) {
    return value.kind === 'StringValue';
}
function isBooleanValue(value) {
    return value.kind === 'BooleanValue';
}
function isIntValue(value) {
    return value.kind === 'IntValue';
}
function isFloatValue(value) {
    return value.kind === 'FloatValue';
}
function isVariable(value) {
    return value.kind === 'Variable';
}
function isObjectValue(value) {
    return value.kind === 'ObjectValue';
}
function isListValue(value) {
    return value.kind === 'ListValue';
}
function isEnumValue(value) {
    return value.kind === 'EnumValue';
}
function isNullValue(value) {
    return value.kind === 'NullValue';
}
function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
    }
    else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function (obj) {
            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
    }
    else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
    }
    else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function (listValue) {
            var nestedArgArrayObj = {};
            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
            return nestedArgArrayObj[name.value];
        });
    }
    else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isNullValue(value)) {
        argObj[name.value] = null;
    }
    else {
        throw __DEV__ ? new globals.InvariantError("The inline argument \"".concat(name.value, "\" of kind \"").concat(value.kind, "\"") +
            'is not supported. Use variables instead of inline arguments to ' +
            'overcome this limitation.') : new globals.InvariantError(52);
    }
}
function storeKeyNameFromField(field, variables) {
    var directivesObj = null;
    if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function (directive) {
            directivesObj[directive.name.value] = {};
            if (directive.arguments) {
                directive.arguments.forEach(function (_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                });
            }
        });
    }
    var argObj = null;
    if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj, name, value, variables);
        });
    }
    return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
    'connection',
    'include',
    'skip',
    'client',
    'rest',
    'export',
];
var getStoreKeyName = Object.assign(function (fieldName, args, directives) {
    if (args &&
        directives &&
        directives['connection'] &&
        directives['connection']['key']) {
        if (directives['connection']['filter'] &&
            directives['connection']['filter'].length > 0) {
            var filterKeys = directives['connection']['filter']
                ? directives['connection']['filter']
                : [];
            filterKeys.sort();
            var filteredArgs_1 = {};
            filterKeys.forEach(function (key) {
                filteredArgs_1[key] = args[key];
            });
            return "".concat(directives['connection']['key'], "(").concat(stringify(filteredArgs_1), ")");
        }
        else {
            return directives['connection']['key'];
        }
    }
    var completeFieldName = fieldName;
    if (args) {
        var stringifiedArgs = stringify(args);
        completeFieldName += "(".concat(stringifiedArgs, ")");
    }
    if (directives) {
        Object.keys(directives).forEach(function (key) {
            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                return;
            if (directives[key] && Object.keys(directives[key]).length) {
                completeFieldName += "@".concat(key, "(").concat(stringify(directives[key]), ")");
            }
            else {
                completeFieldName += "@".concat(key);
            }
        });
    }
    return completeFieldName;
}, {
    setStringify: function (s) {
        var previous = stringify;
        stringify = s;
        return previous;
    },
});
var stringify = function defaultStringify(value) {
    return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
    if (isNonNullObject(value) && !Array.isArray(value)) {
        value = Object.keys(value).sort().reduce(function (copy, key) {
            copy[key] = value[key];
            return copy;
        }, {});
    }
    return value;
}
function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
    }
    return null;
}
function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
    if (typeof result.__typename === 'string') {
        return result.__typename;
    }
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (isField(selection)) {
            if (selection.name.value === '__typename') {
                return result[resultKeyNameFromField(selection)];
            }
        }
        else {
            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
            if (typeof typename === 'string') {
                return typename;
            }
        }
    }
}
function isField(selection) {
    return selection.kind === 'Field';
}
function isInlineFragment(selection) {
    return selection.kind === 'InlineFragment';
}

function checkDocument(doc) {
    __DEV__ ? globals.invariant(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql") : globals.invariant(doc && doc.kind === 'Document', 44);
    var operations = doc.definitions
        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
        .map(function (definition) {
        if (definition.kind !== 'OperationDefinition') {
            throw __DEV__ ? new globals.InvariantError("Schema type definitions not allowed in queries. Found: \"".concat(definition.kind, "\"")) : new globals.InvariantError(45);
        }
        return definition;
    });
    __DEV__ ? globals.invariant(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : globals.invariant(operations.length <= 1, 46);
    return doc;
}
function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
}
function getOperationName(doc) {
    return (doc.definitions
        .filter(function (definition) {
        return definition.kind === 'OperationDefinition' && definition.name;
    })
        .map(function (x) { return x.name.value; })[0] || null);
}
function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
}
function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
    __DEV__ ? globals.invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.') : globals.invariant(queryDef && queryDef.operation === 'query', 47);
    return queryDef;
}
function getFragmentDefinition(doc) {
    __DEV__ ? globals.invariant(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql") : globals.invariant(doc.kind === 'Document', 48);
    __DEV__ ? globals.invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.') : globals.invariant(doc.definitions.length <= 1, 49);
    var fragmentDef = doc.definitions[0];
    __DEV__ ? globals.invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.') : globals.invariant(fragmentDef.kind === 'FragmentDefinition', 50);
    return fragmentDef;
}
function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === 'OperationDefinition') {
            var operation = definition.operation;
            if (operation === 'query' ||
                operation === 'mutation' ||
                operation === 'subscription') {
                return definition;
            }
        }
        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
            fragmentDefinition = definition;
        }
    }
    if (fragmentDefinition) {
        return fragmentDefinition;
    }
    throw __DEV__ ? new globals.InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.') : new globals.InvariantError(51);
}
function getDefaultValues(definition) {
    var defaultValues = Object.create(null);
    var defs = definition && definition.variableDefinitions;
    if (defs && defs.length) {
        defs.forEach(function (def) {
            if (def.defaultValue) {
                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
            }
        });
    }
    return defaultValues;
}

function filterInPlace(array, test, context) {
    var target = 0;
    array.forEach(function (elem, i) {
        if (test.call(this, elem, i, array)) {
            array[target++] = elem;
        }
    }, context);
    array.length = target;
    return array;
}

var TYPENAME_FIELD = {
    kind: 'Field',
    name: {
        kind: 'Name',
        value: '__typename',
    },
};
function isEmpty(op, fragments) {
    return op.selectionSet.selections.every(function (selection) {
        return selection.kind === 'FragmentSpread' &&
            isEmpty(fragments[selection.name.value], fragments);
    });
}
function nullIfDocIsEmpty(doc) {
    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))
        ? null
        : doc;
}
function getDirectiveMatcher(directives) {
    return function directiveMatcher(directive) {
        return directives.some(function (dir) {
            return (dir.name && dir.name === directive.name.value) ||
                (dir.test && dir.test(directive));
        });
    };
}
function removeDirectivesFromDocument(directives, doc) {
    var variablesInUse = Object.create(null);
    var variablesToRemove = [];
    var fragmentSpreadsInUse = Object.create(null);
    var fragmentSpreadsToRemove = [];
    var modifiedDoc = nullIfDocIsEmpty(graphql.visit(doc, {
        Variable: {
            enter: function (node, _key, parent) {
                if (parent.kind !== 'VariableDefinition') {
                    variablesInUse[node.name.value] = true;
                }
            },
        },
        Field: {
            enter: function (node) {
                if (directives && node.directives) {
                    var shouldRemoveField = directives.some(function (directive) { return directive.remove; });
                    if (shouldRemoveField &&
                        node.directives &&
                        node.directives.some(getDirectiveMatcher(directives))) {
                        if (node.arguments) {
                            node.arguments.forEach(function (arg) {
                                if (arg.value.kind === 'Variable') {
                                    variablesToRemove.push({
                                        name: arg.value.name.value,
                                    });
                                }
                            });
                        }
                        if (node.selectionSet) {
                            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                                fragmentSpreadsToRemove.push({
                                    name: frag.name.value,
                                });
                            });
                        }
                        return null;
                    }
                }
            },
        },
        FragmentSpread: {
            enter: function (node) {
                fragmentSpreadsInUse[node.name.value] = true;
            },
        },
        Directive: {
            enter: function (node) {
                if (getDirectiveMatcher(directives)(node)) {
                    return null;
                }
            },
        },
    }));
    if (modifiedDoc &&
        filterInPlace(variablesToRemove, function (v) { return !!v.name && !variablesInUse[v.name]; }).length) {
        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
    }
    if (modifiedDoc &&
        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !!fs.name && !fragmentSpreadsInUse[fs.name]; })
            .length) {
        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
    }
    return modifiedDoc;
}
var addTypenameToDocument = Object.assign(function (doc) {
    return graphql.visit(doc, {
        SelectionSet: {
            enter: function (node, _key, parent) {
                if (parent &&
                    parent.kind === 'OperationDefinition') {
                    return;
                }
                var selections = node.selections;
                if (!selections) {
                    return;
                }
                var skip = selections.some(function (selection) {
                    return (isField(selection) &&
                        (selection.name.value === '__typename' ||
                            selection.name.value.lastIndexOf('__', 0) === 0));
                });
                if (skip) {
                    return;
                }
                var field = parent;
                if (isField(field) &&
                    field.directives &&
                    field.directives.some(function (d) { return d.name.value === 'export'; })) {
                    return;
                }
                return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
            },
        },
    });
}, {
    added: function (field) {
        return field === TYPENAME_FIELD;
    },
});
var connectionRemoveConfig = {
    test: function (directive) {
        var willRemove = directive.name.value === 'connection';
        if (willRemove) {
            if (!directive.arguments ||
                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                __DEV__ && globals.invariant.warn('Removing an @connection directive even though it does not have a key. ' +
                    'You may want to use the key parameter to specify a store key.');
            }
        }
        return willRemove;
    },
};
function removeConnectionDirectiveFromDocument(doc) {
    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
    return function argumentMatcher(argument) {
        return config.some(function (aConfig) {
            return argument.value &&
                argument.value.kind === 'Variable' &&
                argument.value.name &&
                (aConfig.name === argument.value.name.value ||
                    (aConfig.test && aConfig.test(argument)));
        });
    };
}
function removeArgumentsFromDocument(config, doc) {
    var argMatcher = getArgumentMatcher(config);
    return nullIfDocIsEmpty(graphql.visit(doc, {
        OperationDefinition: {
            enter: function (node) {
                return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {
                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });
                    }) : [] });
            },
        },
        Field: {
            enter: function (node) {
                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });
                if (shouldRemoveField) {
                    var argMatchCount_1 = 0;
                    if (node.arguments) {
                        node.arguments.forEach(function (arg) {
                            if (argMatcher(arg)) {
                                argMatchCount_1 += 1;
                            }
                        });
                    }
                    if (argMatchCount_1 === 1) {
                        return null;
                    }
                }
            },
        },
        Argument: {
            enter: function (node) {
                if (argMatcher(node)) {
                    return null;
                }
            },
        },
    }));
}
function removeFragmentSpreadFromDocument(config, doc) {
    function enter(node) {
        if (config.some(function (def) { return def.name === node.name.value; })) {
            return null;
        }
    }
    return nullIfDocIsEmpty(graphql.visit(doc, {
        FragmentSpread: { enter: enter },
        FragmentDefinition: { enter: enter },
    }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
    var allFragments = [];
    selectionSet.selections.forEach(function (selection) {
        if ((isField(selection) || isInlineFragment(selection)) &&
            selection.selectionSet) {
            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });
        }
        else if (selection.kind === 'FragmentSpread') {
            allFragments.push(selection);
        }
    });
    return allFragments;
}
function buildQueryFromSelectionSet(document) {
    var definition = getMainDefinition(document);
    var definitionOperation = definition.operation;
    if (definitionOperation === 'query') {
        return document;
    }
    var modifiedDoc = graphql.visit(document, {
        OperationDefinition: {
            enter: function (node) {
                return tslib.__assign(tslib.__assign({}, node), { operation: 'query' });
            },
        },
    });
    return modifiedDoc;
}
function removeClientSetsFromDocument(document) {
    checkDocument(document);
    var modifiedDoc = removeDirectivesFromDocument([
        {
            test: function (directive) { return directive.name.value === 'client'; },
            remove: true,
        },
    ], document);
    if (modifiedDoc) {
        modifiedDoc = graphql.visit(modifiedDoc, {
            FragmentDefinition: {
                enter: function (node) {
                    if (node.selectionSet) {
                        var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
                            return isField(selection) && selection.name.value === '__typename';
                        });
                        if (isTypenameOnly) {
                            return null;
                        }
                    }
                },
            },
        });
    }
    return modifiedDoc;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function mergeDeep() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
    var target = sources[0] || {};
    var count = sources.length;
    if (count > 1) {
        var merger = new DeepMerger();
        for (var i = 1; i < count; ++i) {
            target = merger.merge(target, sources[i]);
        }
    }
    return target;
}
var defaultReconciler = function (target, source, property) {
    return this.merge(target[property], source[property]);
};
var DeepMerger = (function () {
    function DeepMerger(reconciler) {
        if (reconciler === void 0) { reconciler = defaultReconciler; }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = new Set();
    }
    DeepMerger.prototype.merge = function (target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source) && isNonNullObject(target)) {
            Object.keys(source).forEach(function (sourceKey) {
                if (hasOwnProperty.call(target, sourceKey)) {
                    var targetValue = target[sourceKey];
                    if (source[sourceKey] !== targetValue) {
                        var result = _this.reconciler.apply(_this, tslib.__spreadArray([target, source, sourceKey], context, false));
                        if (result !== targetValue) {
                            target = _this.shallowCopyForMerge(target);
                            target[sourceKey] = result;
                        }
                    }
                }
                else {
                    target = _this.shallowCopyForMerge(target);
                    target[sourceKey] = source[sourceKey];
                }
            });
            return target;
        }
        return source;
    };
    DeepMerger.prototype.shallowCopyForMerge = function (value) {
        if (isNonNullObject(value)) {
            if (!this.pastCopies.has(value)) {
                if (Array.isArray(value)) {
                    value = value.slice(0);
                }
                else {
                    value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
                }
                this.pastCopies.add(value);
            }
        }
        return value;
    };
    return DeepMerger;
}());

function concatPagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        merge: function (existing, incoming) {
            return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
        },
    };
}
function offsetLimitPagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        merge: function (existing, incoming, _a) {
            var args = _a.args;
            var merged = existing ? existing.slice(0) : [];
            if (incoming) {
                if (args) {
                    var _b = args.offset, offset = _b === void 0 ? 0 : _b;
                    for (var i = 0; i < incoming.length; ++i) {
                        merged[offset + i] = incoming[i];
                    }
                }
                else {
                    merged.push.apply(merged, incoming);
                }
            }
            return merged;
        },
    };
}
function relayStylePagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        read: function (existing, _a) {
            var canRead = _a.canRead, readField = _a.readField;
            if (!existing)
                return existing;
            var edges = [];
            var firstEdgeCursor = "";
            var lastEdgeCursor = "";
            existing.edges.forEach(function (edge) {
                if (canRead(readField("node", edge))) {
                    edges.push(edge);
                    if (edge.cursor) {
                        firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                        lastEdgeCursor = edge.cursor || lastEdgeCursor;
                    }
                }
            });
            var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
            return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges: edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });
        },
        merge: function (existing, incoming, _a) {
            var args = _a.args, isReference = _a.isReference, readField = _a.readField;
            if (!existing) {
                existing = makeEmptyData();
            }
            if (!incoming) {
                return existing;
            }
            var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {
                if (isReference(edge = tslib.__assign({}, edge))) {
                    edge.cursor = readField("cursor", edge);
                }
                return edge;
            }) : [];
            if (incoming.pageInfo) {
                var pageInfo_1 = incoming.pageInfo;
                var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
                var firstEdge = incomingEdges[0];
                var lastEdge = incomingEdges[incomingEdges.length - 1];
                if (firstEdge && startCursor) {
                    firstEdge.cursor = startCursor;
                }
                if (lastEdge && endCursor) {
                    lastEdge.cursor = endCursor;
                }
                var firstCursor = firstEdge && firstEdge.cursor;
                if (firstCursor && !startCursor) {
                    incoming = mergeDeep(incoming, {
                        pageInfo: {
                            startCursor: firstCursor,
                        },
                    });
                }
                var lastCursor = lastEdge && lastEdge.cursor;
                if (lastCursor && !endCursor) {
                    incoming = mergeDeep(incoming, {
                        pageInfo: {
                            endCursor: lastCursor,
                        },
                    });
                }
            }
            var prefix = existing.edges;
            var suffix = [];
            if (args && args.after) {
                var index = prefix.findIndex(function (edge) { return edge.cursor === args.after; });
                if (index >= 0) {
                    prefix = prefix.slice(0, index + 1);
                }
            }
            else if (args && args.before) {
                var index = prefix.findIndex(function (edge) { return edge.cursor === args.before; });
                suffix = index < 0 ? prefix : prefix.slice(index);
                prefix = [];
            }
            else if (incoming.edges) {
                prefix = [];
            }
            var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
            var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
            if (incoming.pageInfo) {
                var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
                Object.assign(pageInfo, extras);
                if (!prefix.length) {
                    if (void 0 !== hasPreviousPage)
                        pageInfo.hasPreviousPage = hasPreviousPage;
                    if (void 0 !== startCursor)
                        pageInfo.startCursor = startCursor;
                }
                if (!suffix.length) {
                    if (void 0 !== hasNextPage)
                        pageInfo.hasNextPage = hasNextPage;
                    if (void 0 !== endCursor)
                        pageInfo.endCursor = endCursor;
                }
            }
            return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges: edges, pageInfo: pageInfo });
        },
    };
}
var getExtras = function (obj) { return tslib.__rest(obj, notExtras); };
var notExtras = ["edges", "pageInfo"];
function makeEmptyData() {
    return {
        edges: [],
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: "",
            endCursor: "",
        },
    };
}

var toString = Object.prototype.toString;
function cloneDeep(value) {
    return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
    switch (toString.call(val)) {
        case "[object Array]": {
            seen = seen || new Map;
            if (seen.has(val))
                return seen.get(val);
            var copy_1 = val.slice(0);
            seen.set(val, copy_1);
            copy_1.forEach(function (child, i) {
                copy_1[i] = cloneDeepHelper(child, seen);
            });
            return copy_1;
        }
        case "[object Object]": {
            seen = seen || new Map;
            if (seen.has(val))
                return seen.get(val);
            var copy_2 = Object.create(Object.getPrototypeOf(val));
            seen.set(val, copy_2);
            Object.keys(val).forEach(function (key) {
                copy_2[key] = cloneDeepHelper(val[key], seen);
            });
            return copy_2;
        }
        default:
            return val;
    }
}

function deepFreeze(value) {
    var workSet = new Set([value]);
    workSet.forEach(function (obj) {
        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
            Object.getOwnPropertyNames(obj).forEach(function (name) {
                if (isNonNullObject(obj[name]))
                    workSet.add(obj[name]);
            });
        }
    });
    return value;
}
function shallowFreeze(obj) {
    if (__DEV__ && !Object.isFrozen(obj)) {
        try {
            Object.freeze(obj);
        }
        catch (e) {
            if (e instanceof TypeError)
                return null;
            throw e;
        }
    }
    return obj;
}
function maybeDeepFreeze(obj) {
    if (__DEV__) {
        deepFreeze(obj);
    }
    return obj;
}

function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });
    observersWithMethod.forEach(function (obs) { return obs[method](argument); });
}

function asyncMap(observable, mapFn, catchFn) {
    return new zenObservableTs.Observable(function (observer) {
        var next = observer.next, error = observer.error, complete = observer.complete;
        var activeCallbackCount = 0;
        var completed = false;
        var promiseQueue = {
            then: function (callback) {
                return new Promise(function (resolve) { return resolve(callback()); });
            },
        };
        function makeCallback(examiner, delegate) {
            if (examiner) {
                return function (arg) {
                    ++activeCallbackCount;
                    var both = function () { return examiner(arg); };
                    promiseQueue = promiseQueue.then(both, both).then(function (result) {
                        --activeCallbackCount;
                        next && next.call(observer, result);
                        if (completed) {
                            handler.complete();
                        }
                    }, function (error) {
                        --activeCallbackCount;
                        throw error;
                    }).catch(function (caught) {
                        error && error.call(observer, caught);
                    });
                };
            }
            else {
                return function (arg) { return delegate && delegate.call(observer, arg); };
            }
        }
        var handler = {
            next: makeCallback(mapFn, next),
            error: makeCallback(catchFn, error),
            complete: function () {
                completed = true;
                if (!activeCallbackCount) {
                    complete && complete.call(observer);
                }
            },
        };
        var sub = observable.subscribe(handler);
        return function () { return sub.unsubscribe(); };
    });
}

var canUseWeakMap = typeof WeakMap === 'function' &&
    globals.maybe(function () { return navigator.product; }) !== 'ReactNative';
var canUseWeakSet = typeof WeakSet === 'function';
var canUseSymbol = typeof Symbol === 'function' &&
    typeof Symbol.for === 'function';
var canUseDOM = typeof globals.maybe(function () { return window.document.createElement; }) === "function";
var usingJSDOM = globals.maybe(function () { return navigator.userAgent.indexOf("jsdom") >= 0; }) || false;
var canUseLayoutEffect = canUseDOM && !usingJSDOM;

function fixObservableSubclass(subclass) {
    function set(key) {
        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
    }
    if (canUseSymbol && Symbol.species) {
        set(Symbol.species);
    }
    set("@@species");
    return subclass;
}

function isPromiseLike(value) {
    return value && typeof value.then === "function";
}
var Concast = (function (_super) {
    tslib.__extends(Concast, _super);
    function Concast(sources) {
        var _this = _super.call(this, function (observer) {
            _this.addObserver(observer);
            return function () { return _this.removeObserver(observer); };
        }) || this;
        _this.observers = new Set();
        _this.addCount = 0;
        _this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
        _this.handlers = {
            next: function (result) {
                if (_this.sub !== null) {
                    _this.latest = ["next", result];
                    iterateObserversSafely(_this.observers, "next", result);
                }
            },
            error: function (error) {
                var sub = _this.sub;
                if (sub !== null) {
                    if (sub)
                        setTimeout(function () { return sub.unsubscribe(); });
                    _this.sub = null;
                    _this.latest = ["error", error];
                    _this.reject(error);
                    iterateObserversSafely(_this.observers, "error", error);
                }
            },
            complete: function () {
                var sub = _this.sub;
                if (sub !== null) {
                    var value = _this.sources.shift();
                    if (!value) {
                        if (sub)
                            setTimeout(function () { return sub.unsubscribe(); });
                        _this.sub = null;
                        if (_this.latest &&
                            _this.latest[0] === "next") {
                            _this.resolve(_this.latest[1]);
                        }
                        else {
                            _this.resolve();
                        }
                        iterateObserversSafely(_this.observers, "complete");
                    }
                    else if (isPromiseLike(value)) {
                        value.then(function (obs) { return _this.sub = obs.subscribe(_this.handlers); });
                    }
                    else {
                        _this.sub = value.subscribe(_this.handlers);
                    }
                }
            },
        };
        _this.cancel = function (reason) {
            _this.reject(reason);
            _this.sources = [];
            _this.handlers.complete();
        };
        _this.promise.catch(function (_) { });
        if (typeof sources === "function") {
            sources = [new zenObservableTs.Observable(sources)];
        }
        if (isPromiseLike(sources)) {
            sources.then(function (iterable) { return _this.start(iterable); }, _this.handlers.error);
        }
        else {
            _this.start(sources);
        }
        return _this;
    }
    Concast.prototype.start = function (sources) {
        if (this.sub !== void 0)
            return;
        this.sources = Array.from(sources);
        this.handlers.complete();
    };
    Concast.prototype.deliverLastMessage = function (observer) {
        if (this.latest) {
            var nextOrError = this.latest[0];
            var method = observer[nextOrError];
            if (method) {
                method.call(observer, this.latest[1]);
            }
            if (this.sub === null &&
                nextOrError === "next" &&
                observer.complete) {
                observer.complete();
            }
        }
    };
    Concast.prototype.addObserver = function (observer) {
        if (!this.observers.has(observer)) {
            this.deliverLastMessage(observer);
            this.observers.add(observer);
            ++this.addCount;
        }
    };
    Concast.prototype.removeObserver = function (observer, quietly) {
        if (this.observers.delete(observer) &&
            --this.addCount < 1 &&
            !quietly) {
            this.handlers.complete();
        }
    };
    Concast.prototype.cleanup = function (callback) {
        var _this = this;
        var called = false;
        var once = function () {
            if (!called) {
                called = true;
                _this.observers.delete(observer);
                callback();
            }
        };
        var observer = {
            next: once,
            error: once,
            complete: once,
        };
        var count = this.addCount;
        this.addObserver(observer);
        this.addCount = count;
    };
    return Concast;
}(zenObservableTs.Observable));
fixObservableSubclass(Concast);

function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}

function graphQLResultHasError(result) {
    return (result.errors && result.errors.length > 0) || false;
}

function compact() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    var result = Object.create(null);
    objects.forEach(function (obj) {
        if (!obj)
            return;
        Object.keys(obj).forEach(function (key) {
            var value = obj[key];
            if (value !== void 0) {
                result[key] = value;
            }
        });
    });
    return result;
}

var prefixCounts = new Map();
function makeUniqueId(prefix) {
    var count = prefixCounts.get(prefix) || 1;
    prefixCounts.set(prefix, count + 1);
    return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}

function stringifyForDisplay(value) {
    var undefId = makeUniqueId("stringifyForDisplay");
    return JSON.stringify(value, function (key, value) {
        return value === void 0 ? undefId : value;
    }).split(JSON.stringify(undefId)).join("<undefined>");
}

function mergeOptions(defaults, options) {
    return compact(defaults, options, options.variables && {
        variables: tslib.__assign(tslib.__assign({}, (defaults && defaults.variables)), options.variables),
    });
}

exports.DEV = globals.DEV;
exports.maybe = globals.maybe;
exports.Observable = zenObservableTs.Observable;
exports.Concast = Concast;
exports.DeepMerger = DeepMerger;
exports.addTypenameToDocument = addTypenameToDocument;
exports.argumentsObjectFromField = argumentsObjectFromField;
exports.asyncMap = asyncMap;
exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
exports.canUseDOM = canUseDOM;
exports.canUseLayoutEffect = canUseLayoutEffect;
exports.canUseSymbol = canUseSymbol;
exports.canUseWeakMap = canUseWeakMap;
exports.canUseWeakSet = canUseWeakSet;
exports.checkDocument = checkDocument;
exports.cloneDeep = cloneDeep;
exports.compact = compact;
exports.concatPagination = concatPagination;
exports.createFragmentMap = createFragmentMap;
exports.fixObservableSubclass = fixObservableSubclass;
exports.getDefaultValues = getDefaultValues;
exports.getDirectiveNames = getDirectiveNames;
exports.getFragmentDefinition = getFragmentDefinition;
exports.getFragmentDefinitions = getFragmentDefinitions;
exports.getFragmentFromSelection = getFragmentFromSelection;
exports.getFragmentQueryDocument = getFragmentQueryDocument;
exports.getInclusionDirectives = getInclusionDirectives;
exports.getMainDefinition = getMainDefinition;
exports.getOperationDefinition = getOperationDefinition;
exports.getOperationName = getOperationName;
exports.getQueryDefinition = getQueryDefinition;
exports.getStoreKeyName = getStoreKeyName;
exports.getTypenameFromResult = getTypenameFromResult;
exports.graphQLResultHasError = graphQLResultHasError;
exports.hasClientExports = hasClientExports;
exports.hasDirectives = hasDirectives;
exports.isDocumentNode = isDocumentNode;
exports.isField = isField;
exports.isInlineFragment = isInlineFragment;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isNonNullObject = isNonNullObject;
exports.isReference = isReference;
exports.iterateObserversSafely = iterateObserversSafely;
exports.makeReference = makeReference;
exports.makeUniqueId = makeUniqueId;
exports.maybeDeepFreeze = maybeDeepFreeze;
exports.mergeDeep = mergeDeep;
exports.mergeDeepArray = mergeDeepArray;
exports.mergeOptions = mergeOptions;
exports.offsetLimitPagination = offsetLimitPagination;
exports.relayStylePagination = relayStylePagination;
exports.removeArgumentsFromDocument = removeArgumentsFromDocument;
exports.removeClientSetsFromDocument = removeClientSetsFromDocument;
exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
exports.resultKeyNameFromField = resultKeyNameFromField;
exports.shouldInclude = shouldInclude;
exports.storeKeyNameFromField = storeKeyNameFromField;
exports.stringifyForDisplay = stringifyForDisplay;
exports.valueToObjectRepresentation = valueToObjectRepresentation;
//# sourceMappingURL=utilities.cjs.map


/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "react"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

let cachedObserver;
const listeners = new Map();
const IntersectionObserver = false ? undefined : null;
const prefetched = {};

function getObserver() {
  // Return shared instance of IntersectionObserver if already created
  if (cachedObserver) {
    return cachedObserver;
  } // Only create shared IntersectionObserver if supported in browser


  if (!IntersectionObserver) {
    return undefined;
  }

  return cachedObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (!listeners.has(entry.target)) {
        return;
      }

      const cb = listeners.get(entry.target);

      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        cachedObserver.unobserve(entry.target);
        listeners.delete(entry.target);
        cb();
      }
    });
  }, {
    rootMargin: '200px'
  });
}

const listenToIntersections = (el, cb) => {
  const observer = getObserver();

  if (!observer) {
    return () => {};
  }

  observer.observe(el);
  listeners.set(el, cb);
  return () => {
    try {
      observer.unobserve(el);
    } catch (err) {
      console.error(err);
    }

    listeners.delete(el);
  };
};

function prefetch(router, href, as, options) {
  if (true) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options).catch(err => {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  }); // Join on an invalid URI character

  prefetched[href + '%' + as] = true;
}

function isModifiedEvent(event) {
  const {
    target
  } = event.currentTarget;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll) {
  const {
    nodeName
  } = e.currentTarget;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browsers default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow
  }).then(success => {
    if (!success) return;

    if (scroll) {
      window.scrollTo(0, 0);
      document.body.focus();
    }
  });
}

function Link(props) {
  if (true) {
    function createPropError(args) {
      return new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (false ? undefined : ''));
    } // TypeScript trick for type-guarding:


    const requiredPropsGuard = {
      href: true
    };
    const requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(key => {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // TypeScript trick for type-guarding:

    const optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true
    };
    const optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(key => {
      if (key === 'as') {
        if (props[key] && typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: typeof props[key]
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && typeof props[key] !== 'boolean') {
          throw createPropError({
            key,
            expected: '`boolean`',
            actual: typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    const hasWarned = _react.default.useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  const p = props.prefetch !== false;

  const [childElm, setChildElm] = _react.default.useState();

  const router = (0, _router2.useRouter)();
  const pathname = router && router.pathname || '/';

  const {
    href,
    as
  } = _react.default.useMemo(() => {
    const [resolvedHref, resolvedAs] = (0, _router.resolveHref)(pathname, props.href, true);
    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]);

  _react.default.useEffect(() => {
    if (p && IntersectionObserver && childElm && childElm.tagName && (0, _router.isLocalURL)(href)) {
      // Join on an invalid URI character
      const isPrefetched = prefetched[href + '%' + as];

      if (!isPrefetched) {
        return listenToIntersections(childElm, () => {
          prefetch(router, href, as);
        });
      }
    }
  }, [p, childElm, href, as, router]);

  let {
    children,
    replace,
    shallow,
    scroll
  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react.default.createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  const child = _react.Children.only(children);

  const childProps = {
    ref: el => {
      if (el) setChildElm(el);

      if (child && typeof child === 'object' && child.ref) {
        if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {
          child.ref.current = el;
        }
      }
    },
    onClick: e => {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll);
      }
    }
  };

  if (p) {
    childProps.onMouseEnter = e => {
      if (!(0, _router.isLocalURL)(href)) return;

      if (child.props && typeof child.props.onMouseEnter === 'function') {
        child.props.onMouseEnter(e);
      }

      prefetch(router, href, as, {
        priority: true
      });
    };
  } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    childProps.href = (0, _router.addBasePath)((0, _router.addLocale)(as, router && router.locale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react.default.cloneElement(child, childProps);
}

var _default = Link;
exports.default = _default;

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


const normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "react"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2.default;
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "../next-server/lib/router-context");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter.default;
/* global window */

const singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],

  ready(cb) {
    if (this.router) return cb();

    if (false) {}
  }

}; // Create public properties and methods of the router in the singletonRouter

const urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];
const routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
const coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get() {
    return _router2.default.events;
  }

});
urlPropertyFields.forEach(field => {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get() {
      const router = getRouter();
      return router[field];
    }

  });
});
coreMethodFields.forEach(field => {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = (...args) => {
    const router = getRouter();
    return router[field](...args);
  };
});
routerEvents.forEach(event => {
  singletonRouter.ready(() => {
    _router2.default.events.on(event, (...args) => {
      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;
      const _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField](...args);
        } catch (err) {
          console.error(`Error when running the Router event: ${eventField}`);
          console.error(`${err.message}\n${err.stack}`);
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    const message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports.default = _default;

function useRouter() {
  return _react.default.useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


const createRouter = (...args) => {
  singletonRouter.router = new _router2.default(...args);
  singletonRouter.readyCallbacks.forEach(cb => cb());
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  const _router = router;
  const instance = {};

  for (const property of urlPropertyFields) {
    if (typeof _router[property] === 'object') {
      instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

      continue;
    }

    instance[property] = _router[property];
  } // Events is a static property on the router, the router doesn't have to be initialized to use it


  instance.events = _router2.default.events;
  coreMethodFields.forEach(field => {
    instance[field] = (...args) => {
      return _router[field](...args);
    };
  });
  return instance;
}

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "react"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = `withRouter(${name})`;
  }

  return WithRouterWrapper;
}

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  const all = Object.create(null);
  return {
    on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },

    off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },

    emit(type, ...evts) {
      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(handler => {
        handler(...evts);
      });
    }

  };
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.markLoadingError = markLoadingError;
exports.default = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


const basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : `${prefix}${path}` : path;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    const locationOrigin = (0, _utils.getLocationOrigin)();
    const resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  let interpolatedRoute = '';
  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  const dynamicGroups = dynamicRegex.groups;
  const dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  const params = Object.keys(dynamicGroups);

  if (!params.every(param => {
    let value = dynamicMatches[param] || '';
    const {
      repeat,
      optional
    } = dynamicGroups[param]; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    let replaced = `[${repeat ? '...' : ''}${param}]`;

    if (optional) {
      replaced = `${!value ? '/' : ''}[${replaced}]`;
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters.default).join('/') : (0, _escapePathDelimiters.default)(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  const filteredQuery = {};
  Object.keys(query).forEach(key => {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  const base = new URL(currentPath, 'http://n');
  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href);

  try {
    const finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    let interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
      const {
        result,
        params
      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

const PAGE_LOAD_ERROR = Symbol('PAGE_LOAD_ERROR');

function markLoadingError(err) {
  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

const manualScrollRestoration =  false && false;

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` wont send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(res => {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      throw new Error(`Failed to load static props`);
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      markLoadingError(err);
    }

    throw err;
  });
}

class Router {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  constructor(_pathname, _query, _as, {
    initialProps,
    pageLoader,
    App,
    wrapApp,
    Component,
    initialStyleSheets,
    err,
    subscription,
    isFallback,
    locale,
    locales,
    defaultLocale
  }) {
    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;

    this.onPopState = e => {
      const state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        const {
          pathname,
          query
        } = this;
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(pathname),
          query
        }), (0, _utils.getURL)());
        return;
      }

      if (!state.__N) {
        return;
      }

      const {
        url,
        as,
        options
      } = state;
      const {
        pathname
      } = (0, _parseRelativeUrl.parseRelativeUrl)(url); // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site

      if (this.isSsr && as === this.asPath && pathname === this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (this._bps && !this._bps(state)) {
        return;
      }

      this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && this._shallow
      }));
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component,
        styleSheets: initialStyleSheets,
        props: initialProps,
        err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (false) {}

    if (false) {}
  }

  reload() {
    window.location.reload();
  }
  /**
  * Go back in history
  */


  back() {
    window.history.back();
  }
  /**
  * Performs a `pushState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  push(url, as = url, options = {}) {
    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('pushState', url, as, options);
  }
  /**
  * Performs a `replaceState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  replace(url, as = url, options = {}) {
    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('replaceState', url, as, options);
  }

  async change(method, url, as, options) {
    if (!isLocalURL(url)) {
      window.location.href = url;
      return false;
    }

    if (!options._h) {
      this.isSsr = false;
    } // marking route changes as a navigation start entry


    if (_utils.ST) {
      performance.mark('routeChange');
    }

    if (this._inFlightRoute) {
      this.abortComponentLoad(this._inFlightRoute);
    }

    as = addLocale(as, this.locale, this.defaultLocale);
    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
    this._inFlightRoute = as; // If the url change is only related to a hash change
    // We should not proceed. We should only change the state.
    // WARNING: `_h` is an internal option for handing Next.js client-side
    // hydration. Your app should _never_ use this property. It may change at
    // any time without notice.

    if (!options._h && this.onlyAHashChange(cleanedAs)) {
      this.asPath = cleanedAs;
      Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?

      this.changeState(method, url, as, options);
      this.scrollToHash(cleanedAs);
      this.notify(this.components[this.route]);
      Router.events.emit('hashChangeComplete', as);
      return true;
    } // The build manifest needs to be loaded before auto-static dynamic pages
    // get their query parameters to allow ensuring they can be parsed properly
    // when rewritten to


    const pages = await this.pageLoader.getPageList();
    const {
      __rewrites: rewrites
    } = await this.pageLoader.promisedBuildManifest;
    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname,
      query
    } = parsed;
    parsed = this._resolveHref(parsed, pages);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // url and as should always be prefixed with basePath by this
    // point by either next/link or router.push/replace so strip the
    // basePath from the pathname to match the pages dir 1-to-1


    pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
    // (not location.reload() but reload getInitialProps and other Next.js stuffs)
    // We also need to set the method = replaceState always
    // as this should not go into the history (That's how browsers work)
    // We should compare the new asPath to the current asPath, not the url

    if (!this.urlIsNew(cleanedAs)) {
      method = 'replaceState';
    }

    let route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
    const {
      shallow = false
    } = options; // we need to resolve the as value using rewrites for dynamic SSG
    // pages to allow building the data URL correctly

    let resolvedAs = as;

    if (true) {
      resolvedAs = (0, _resolveRewrites.default)((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, p => this._resolveHref({
        pathname: p
      }, pages).pathname);

      if (resolvedAs !== as) {
        const potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
          pathname: resolvedAs
        }), pages, false).pathname); // if this directly matches a page we need to update the href to
        // allow the correct page chunk to be loaded

        if (pages.includes(potentialHref)) {
          route = potentialHref;
          pathname = potentialHref;
          parsed.pathname = pathname;
          url = (0, _utils.formatWithValidation)(parsed);
        }
      }
    }

    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

    if ((0, _isDynamic.isDynamicRoute)(route)) {
      const parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
      const asPathname = parsedAs.pathname;
      const routeRegex = (0, _routeRegex.getRouteRegex)(route);
      const routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
      const shouldInterpolate = route === asPathname;
      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);

        if (missingParams.length > 0) {
          if (true) {
            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \`as\` and \`href\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \`href\`'s \`query\``);
          }

          throw new Error((shouldInterpolate ? `The provided \`href\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \`as\` value (${asPathname}) is incompatible with the \`href\` value (${route}). `) + `Read more: https://err.sh/vercel/next.js/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);
        }
      } else if (shouldInterpolate) {
        as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {
          pathname: interpolatedAs.result,
          query: omitParmsFromQuery(query, interpolatedAs.params)
        }));
      } else {
        // Merge params into `query`, overwriting any specified in search
        Object.assign(query, routeMatch);
      }
    }

    Router.events.emit('routeChangeStart', as);

    try {
      const routeInfo = await this.getRouteInfo(route, pathname, query, as, shallow);
      let {
        error,
        props,
        __N_SSG,
        __N_SSP
      } = routeInfo; // handle redirect on client-transition

      if ((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT) {
        const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
        // client-navigation if it is falling back to hard navigation if
        // it's not

        if (destination.startsWith('/')) {
          const parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

          this._resolveHref(parsedHref, pages);

          if (pages.includes(parsedHref.pathname)) {
            return this.change('replaceState', destination, destination, options);
          }
        }

        window.location.href = destination;
        return new Promise(() => {});
      }

      Router.events.emit('beforeHistoryChange', as);
      this.changeState(method, url, addLocale(as, this.locale, this.defaultLocale), options);

      if (true) {
        const appComp = this.components['/_app'].Component;
        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
      }

      await this.set(route, pathname, query, cleanedAs, routeInfo).catch(e => {
        if (e.cancelled) error = error || e;else throw e;
      });

      if (error) {
        Router.events.emit('routeChangeError', error, cleanedAs);
        throw error;
      }

      if (false) {}

      Router.events.emit('routeChangeComplete', as);
      return true;
    } catch (err) {
      if (err.cancelled) {
        return false;
      }

      throw err;
    }
  }

  changeState(method, url, as, options = {}) {
    if (true) {
      if (typeof window.history === 'undefined') {
        console.error(`Warning: window.history is not available.`);
        return;
      }

      if (typeof window.history[method] === 'undefined') {
        console.error(`Warning: window.history.${method} is not available`);
        return;
      }
    }

    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
      this._shallow = options.shallow;
      window.history[method]({
        url,
        as,
        options,
        __N: true
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      '', as);
    }
  }

  async handleRouteInfoError(err, pathname, query, as, loadErrorFail) {
    if (err.cancelled) {
      // bubble up cancellation errors
      throw err;
    }

    if (PAGE_LOAD_ERROR in err || loadErrorFail) {
      Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
      //  1. Page doesn't exists
      //  2. Page does exist in a different zone
      //  3. Internal error while loading the page
      // So, doing a hard reload is the proper way to deal with this.

      window.location.href = as; // Changing the URL doesn't block executing the current code path.
      // So let's throw a cancellation error stop the routing logic.

      throw buildCancellationError();
    }

    try {
      const {
        page: Component,
        styleSheets
      } = await this.fetchComponent('/_error');
      const routeInfo = {
        Component,
        styleSheets,
        err,
        error: err
      };

      try {
        routeInfo.props = await this.getInitialProps(Component, {
          err,
          pathname,
          query
        });
      } catch (gipErr) {
        console.error('Error in error page `getInitialProps`: ', gipErr);
        routeInfo.props = {};
      }

      return routeInfo;
    } catch (routeInfoErr) {
      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, true);
    }
  }

  async getRouteInfo(route, pathname, query, as, shallow = false) {
    try {
      const cachedRouteInfo = this.components[route];

      if (shallow && cachedRouteInfo && this.route === route) {
        return cachedRouteInfo;
      }

      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({
        Component: res.page,
        styleSheets: res.styleSheets,
        __N_SSG: res.mod.__N_SSG,
        __N_SSP: res.mod.__N_SSP
      }));
      const {
        Component,
        __N_SSG,
        __N_SSP
      } = routeInfo;

      if (true) {
        const {
          isValidElementType
        } = __webpack_require__(/*! react-is */ "react-is");

        if (!isValidElementType(Component)) {
          throw new Error(`The default export is not a React Component in page: "${pathname}"`);
        }
      }

      let dataHref;

      if (__N_SSG || __N_SSP) {
        dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
          pathname,
          query
        }), delBasePath(as), __N_SSG, this.locale, this.defaultLocale);
      }

      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
      {
        pathname,
        query,
        asPath: as
      }));
      routeInfo.props = props;
      this.components[route] = routeInfo;
      return routeInfo;
    } catch (err) {
      return this.handleRouteInfoError(err, pathname, query, as);
    }
  }

  set(route, pathname, query, as, data) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data);
  }
  /**
  * Callback to execute before replacing router state
  * @param cb callback to be executed
  */


  beforePopState(cb) {
    this._bps = cb;
  }

  onlyAHashChange(as) {
    if (!this.asPath) return false;
    const [oldUrlNoHash, oldHash] = this.asPath.split('#');
    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same

    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  }

  scrollToHash(as) {
    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value

    if (hash === '') {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    const idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    const nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  }

  urlIsNew(asPath) {
    return this.asPath !== asPath;
  }

  _resolveHref(parsedHref, pages, applyBasePath = true) {
    const {
      pathname
    } = parsedHref;
    const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

    if (cleanPathname === '/404' || cleanPathname === '/_error') {
      return parsedHref;
    } // handle resolving href for dynamic routes


    if (!pages.includes(cleanPathname)) {
      // eslint-disable-next-line array-callback-return
      pages.some(page => {
        if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
          parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
          return true;
        }
      });
    }

    return parsedHref;
  }
  /**
  * Prefetch page code, you may wait for the data during page rendering.
  * This feature only works in production!
  * @param url the href of prefetched page
  * @param asPath the as path of the prefetched page
  */


  async prefetch(url, asPath = url, options = {}) {
    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname
    } = parsed;
    const pages = await this.pageLoader.getPageList();
    parsed = this._resolveHref(parsed, pages);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // Prefetch is not supported in development mode because it would trigger on-demand-entries


    if (true) {
      return;
    }

    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
    await Promise.all([this.pageLoader.prefetchData(url, asPath, this.locale, this.defaultLocale), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);
  }

  async fetchComponent(route) {
    let cancelled = false;

    const cancel = this.clc = () => {
      cancelled = true;
    };

    const componentResult = await this.pageLoader.loadPage(route);

    if (cancelled) {
      const error = new Error(`Abort fetching component for route: "${route}"`);
      error.cancelled = true;
      throw error;
    }

    if (cancel === this.clc) {
      this.clc = null;
    }

    return componentResult;
  }

  _getData(fn) {
    let cancelled = false;

    const cancel = () => {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(data => {
      if (cancel === this.clc) {
        this.clc = null;
      }

      if (cancelled) {
        const err = new Error('Loading initial props cancelled');
        err.cancelled = true;
        throw err;
      }

      return data;
    });
  }

  _getStaticData(dataHref) {
    const {
      href: cacheKey
    } = new URL(dataHref, window.location.href);

    if (false) {}

    return fetchNextData(dataHref, this.isSsr).then(data => {
      this.sdc[cacheKey] = data;
      return data;
    });
  }

  _getServerData(dataHref) {
    return fetchNextData(dataHref, this.isSsr);
  }

  getInitialProps(Component, ctx) {
    const {
      Component: App
    } = this.components['/_app'];

    const AppTree = this._wrapApp(App);

    ctx.AppTree = AppTree;
    return (0, _utils.loadGetInitialProps)(App, {
      AppTree,
      Component,
      router: this,
      ctx
    });
  }

  abortComponentLoad(as) {
    if (this.clc) {
      Router.events.emit('routeChangeError', buildCancellationError(), as);
      this.clc();
      this.clc = null;
    }
  }

  notify(data) {
    return this.sub(data, this.components['/_app'].Component);
  }

}

exports.default = Router;
Router.events = (0, _mitt.default)();

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = escapePathDelimiters; // escape delimiters used by path-to-regexp

function escapePathDelimiters(segment) {
  return segment.replace(/[/#?]/g, char => encodeURIComponent(char));
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


const slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  let {
    auth,
    hostname
  } = urlObj;
  let protocol = urlObj.protocol || '';
  let pathname = urlObj.pathname || '';
  let hash = urlObj.hash || '';
  let query = urlObj.query || '';
  let host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  let search = urlObj.search || query && `?${query}` || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return `${protocol}${host}${pathname}${search}${hash}`;
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

const DUMMY_BASE = new URL(true ? 'http://n' : undefined);
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/

function parseRelativeUrl(url, base) {
  const resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;
  const {
    pathname,
    searchParams,
    search,
    hash,
    href,
    origin,
    protocol
  } = new URL(url, resolvedBase);

  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search,
    hash,
    href: href.slice(DUMMY_BASE.origin.length)
  };
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.__esModule = true;
exports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

const matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

const customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = (customRoute = false) => {
  return path => {
    const keys = [];
    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return (pathname, params) => {
      const res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        for (const key of keys) {
          // unnamed params should be removed as they
          // are not allowed to be used in the destination
          if (typeof key.name === 'number') {
            delete res.params[key.name];
          }
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.__esModule = true;
exports.default = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function prepareDestination(destination, params, query, appendParamsToQuery, basePath) {
  let parsedDestination = {};

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    const {
      pathname,
      searchParams,
      hash,
      hostname,
      port,
      protocol,
      search,
      href
    } = new URL(destination);
    parsedDestination = {
      pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash,
      protocol,
      hostname,
      port,
      search,
      href
    };
  }

  const destQuery = parsedDestination.query;
  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;
  const destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  const destPathParams = destPathParamKeys.map(key => key.name);
  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  let newUrl; // update any params in query values

  for (const [key, strOrArray] of Object.entries(destQuery)) {
    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = `/${value}`;
      const queryCompiler = pathToRegexp.compile(value, {
        validate: false
      });
      value = queryCompiler(params).substr(1);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  const paramKeys = Object.keys(params);

  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {
    for (const key of paramKeys) {
      if (!(key in destQuery)) {
        destQuery[key] = params[key];
      }
    }
  }

  const shouldAddBasePath = destination.startsWith('/') && basePath;

  try {
    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(params)}`;
    const [pathname, hash] = newUrl.split('#');
    parsedDestination.pathname = pathname;
    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error(`To use a multi-match in the destination you must add \`*\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl,
    parsedDestination
  };
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  const query = {};
  searchParams.forEach((value, key) => {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  const result = new URLSearchParams();
  Object.entries(urlQuery).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(item => result.append(key, stringifyUrlQueryParam(item)));
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target, ...searchParamsList) {
  searchParamsList.forEach(searchParams => {
    Array.from(searchParams.keys()).forEach(key => target.delete(key));
    searchParams.forEach((value, key) => target.append(key, value));
  });
  return target;
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const customRouteMatcher = (0, _pathMatch.default)(true);

function resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {
  if (!pages.includes(asPath)) {
    for (const rewrite of rewrites) {
      const matcher = customRouteMatcher(rewrite.source);
      const params = matcher(asPath);

      if (params) {
        if (!rewrite.destination) {
          // this is a proxied rewrite which isn't handled on the client
          break;
        }

        const destRes = (0, _prepareDestination.default)(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);
        asPath = destRes.parsedDestination.pathname;
        Object.assign(query, destRes.parsedDestination.query);

        if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {
          // check if we now match a page as this means we are done
          // resolving the rewrites
          break;
        } // check if we match a dynamic-route, if so we break the rewrites chain


        const resolvedHref = resolveHref(asPath);

        if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
          break;
        }
      }
    }
  }

  return asPath;
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  const {
    re,
    groups
  } = routeRegex;
  return pathname => {
    const routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    const decode = param => {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        const err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    const params = {};
    Object.keys(groups).forEach(slugName => {
      const g = groups[slugName];
      const m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  const optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  const repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat,
    optional
  };
}

function getRouteRegex(normalizedRoute) {
  const segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  const groups = {};
  let groupIndex = 1;
  const parameterizedRoute = segments.map(segment => {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      const {
        key,
        optional,
        repeat
      } = parseParameter(segment.slice(1, -1));
      groups[key] = {
        pos: groupIndex++,
        repeat,
        optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return `/${escapeRegex(segment)}`;
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (true) {
    let routeKeyCharCode = 97;
    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters

    const getSafeRouteKey = () => {
      let routeKey = '';

      for (let i = 0; i < routeKeyCharLength; i++) {
        routeKey += String.fromCharCode(routeKeyCharCode);
        routeKeyCharCode++;

        if (routeKeyCharCode > 122) {
          routeKeyCharLength++;
          routeKeyCharCode = 97;
        }
      }

      return routeKey;
    };

    const routeKeys = {};
    let namedParameterizedRoute = segments.map(segment => {
      if (segment.startsWith('[') && segment.endsWith(']')) {
        const {
          key,
          optional,
          repeat
        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break
        // the named regex

        let cleanedKey = key.replace(/\W/g, '');
        let invalidKey = false; // check if the key is still invalid and fallback to using a known
        // safe key

        if (cleanedKey.length === 0 || cleanedKey.length > 30) {
          invalidKey = true;
        }

        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {
          invalidKey = true;
        }

        if (invalidKey) {
          cleanedKey = getSafeRouteKey();
        }

        routeKeys[cleanedKey] = key;
        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;
      } else {
        return `/${escapeRegex(segment)}`;
      }
    }).join('');
    return {
      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),
      groups,
      routeKeys,
      namedRegex: `^${namedParameterizedRoute}(?:/)?$`
    };
  }

  return {
    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),
    groups
  };
}

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  let used = false;
  let result;
  return (...args) => {
    if (!used) {
      used = true;
      result = fn(...args);
    }

    return result;
  };
}

function getLocationOrigin() {
  const {
    protocol,
    hostname,
    port
  } = window.location;
  return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}

function getURL() {
  const {
    href
  } = window.location;
  const origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

async function loadGetInitialProps(App, ctx) {
  if (true) {
    var _App$prototype;

    if ((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps) {
      const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.`;
      throw new Error(message);
    }
  } // when called from _app `ctx` is nested in `ctx`


  const res = ctx.res || ctx.ctx && ctx.ctx.res;

  if (!App.getInitialProps) {
    if (ctx.ctx && ctx.Component) {
      // @ts-ignore pageProps default
      return {
        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
      };
    }

    return {};
  }

  const props = await App.getInitialProps(ctx);

  if (res && isResSent(res)) {
    return props;
  }

  if (!props) {
    const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
    throw new Error(message);
  }

  if (true) {
    if (Object.keys(props).length === 0 && !ctx.ctx) {
      console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps`);
    }
  }

  return props;
}

const urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(key => {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

const SP = typeof performance !== 'undefined';
exports.SP = SP;
const ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/ts-invariant/lib/invariant.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/ts-invariant/lib/invariant.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var tslib = __webpack_require__(/*! tslib */ "tslib");

var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
} : _a;
var InvariantError = /** @class */ (function (_super) {
    tslib.__extends(InvariantError, _super);
    function InvariantError(message) {
        if (message === void 0) { message = genericMessage; }
        var _this = _super.call(this, typeof message === "number"
            ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
            : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError.prototype);
        return _this;
    }
    return InvariantError;
}(Error));
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
    return function () {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
            // Default to console.log if this host environment happens not to provide
            // all the console.* methods we need.
            var method = console[name] || console.log;
            return method.apply(console, arguments);
        }
    };
}
(function (invariant) {
    invariant.debug = wrapConsoleMethod("debug");
    invariant.log = wrapConsoleMethod("log");
    invariant.warn = wrapConsoleMethod("warn");
    invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
function setVerbosity(level) {
    var old = verbosityLevels[verbosityLevel];
    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
    return old;
}
var invariant$1 = invariant;

exports.InvariantError = InvariantError;
exports["default"] = invariant$1;
exports.invariant = invariant;
exports.setVerbosity = setVerbosity;
//# sourceMappingURL=invariant.cjs.map


/***/ }),

/***/ "./node_modules/ts-invariant/process/main.cjs":
/*!****************************************************!*\
  !*** ./node_modules/ts-invariant/process/main.cjs ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function maybe(thunk) {
  try { return thunk() } catch (_) {}
}

var safeGlobal = (
  maybe(function() { return globalThis }) ||
  maybe(function() { return window }) ||
  maybe(function() { return self }) ||
  maybe(function() { return global }) ||
  // We don't expect the Function constructor ever to be invoked at runtime, as
  // long as at least one of globalThis, window, self, or global is defined, so
  // we are under no obligation to make it easy for static analysis tools to
  // detect syntactic usage of the Function constructor. If you think you can
  // improve your static analysis to detect this obfuscation, think again. This
  // is an arms race you cannot win, at least not in JavaScript.
  maybe(function() { return maybe.constructor("return this")() })
);

var needToRemove = false;

function install() {
  if (safeGlobal &&
      !maybe(function() { return "development" }) &&
      !maybe(function() { return process })) {
    Object.defineProperty(safeGlobal, "process", {
      value: {
        env: {
          // This default needs to be "production" instead of "development", to
          // avoid the problem https://github.com/graphql/graphql-js/pull/2894
          // will eventually solve, once merged and released.
          NODE_ENV: "production",
        },
      },
      // Let anyone else change global.process as they see fit, but hide it from
      // Object.keys(global) enumeration.
      configurable: true,
      enumerable: false,
      writable: true,
    });
    needToRemove = true;
  }
}

// Call install() at least once, when this module is imported.
install();

function remove() {
  if (needToRemove) {
    delete safeGlobal.process;
    needToRemove = false;
  }
}

exports.install = install;
exports.remove = remove;
//# sourceMappingURL=main.cjs.map


/***/ }),

/***/ "./node_modules/zen-observable-ts/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/index.cjs ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.Observable = __webpack_require__(/*! zen-observable/index.js */ "zen-observable/index.js");


/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_cart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/cart */ "./components/cart.js");
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @apollo/client */ "./node_modules/@apollo/client/main.cjs");
/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _components_restaurantList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/restaurantList */ "./components/restaurantList.js");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ "reactstrap");
/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "C:\\Users\\Sophie\\Desktop\\mitCert\\Part3-BackEnd\\28Week-FullstackRestaurant1\\next-restaurant\\restaurant-app\\pages\\index.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






const Home = () => {
  const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:1337";
  console.log(`URL: ${API_URL}`);
  const {
    0: query,
    1: setQuery
  } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])("");
  const link = new _apollo_client__WEBPACK_IMPORTED_MODULE_2__["HttpLink"]({
    uri: `${API_URL}/graphql`
  });
  const cache = new _apollo_client__WEBPACK_IMPORTED_MODULE_2__["InMemoryCache"]();
  const client = new _apollo_client__WEBPACK_IMPORTED_MODULE_2__["ApolloClient"]({
    link,
    cache
  });
  return __jsx(_apollo_client__WEBPACK_IMPORTED_MODULE_2__["ApolloProvider"], {
    client: client,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }
  }, __jsx("div", {
    className: "search",
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 9
    }
  }, __jsx("h2", {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 13
    }
  }, " Local Restaurants"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["InputGroup"], {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 15
    }
  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["InputGroupAddon"], {
    addonType: "append",
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 15
    }
  }, " Search "), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__["Input"], {
    onChange: e => setQuery(e.target.value.toLocaleLowerCase()),
    value: query,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 15
    }
  })), __jsx("br", {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 28
    }
  })), __jsx(_components_restaurantList__WEBPACK_IMPORTED_MODULE_3__["default"], {
    search: query,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 11
    }
  }), __jsx(_components_cart__WEBPACK_IMPORTED_MODULE_1__["default"], {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 32,
      columnNumber: 11
    }
  }, " "));
};

/* harmony default export */ __webpack_exports__["default"] = (Home);

/***/ }),

/***/ "@wry/context":
/*!*******************************!*\
  !*** external "@wry/context" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@wry/context");

/***/ }),

/***/ "@wry/equality":
/*!********************************!*\
  !*** external "@wry/equality" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@wry/equality");

/***/ }),

/***/ "@wry/trie":
/*!****************************!*\
  !*** external "@wry/trie" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@wry/trie");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("graphql");

/***/ }),

/***/ "graphql-tag":
/*!******************************!*\
  !*** external "graphql-tag" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("graphql-tag");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("next/router");

/***/ }),

/***/ "optimism":
/*!***************************!*\
  !*** external "optimism" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("optimism");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ "react-is":
/*!***************************!*\
  !*** external "react-is" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-is");

/***/ }),

/***/ "reactstrap":
/*!*****************************!*\
  !*** external "reactstrap" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("reactstrap");

/***/ }),

/***/ "styled-jsx/style":
/*!***********************************!*\
  !*** external "styled-jsx/style" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("styled-jsx/style");

/***/ }),

/***/ "symbol-observable":
/*!************************************!*\
  !*** external "symbol-observable" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("symbol-observable");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tslib");

/***/ }),

/***/ "zen-observable/index.js":
/*!******************************************!*\
  !*** external "zen-observable/index.js" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zen-observable/index.js");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC5qc1wiIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FydC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9kaXNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9yZXN0YXVyYW50TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvY2FjaGUuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL2NvcmUuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9lcnJvcnMvZXJyb3JzLmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9jb3JlL2NvcmUuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaHR0cC5janMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvdXRpbHMvdXRpbHMuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9tYWluLmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvY29udGV4dC9jb250ZXh0LmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvaG9va3MvaG9va3MuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9wYXJzZXIvcGFyc2VyLmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvcmVhY3QuY2pzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ2xvYmFscy9nbG9iYWxzLmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL3V0aWxpdGllcy5janMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvbWl0dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZXNjYXBlLXBhdGgtZGVsaW1pdGVycy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhdGgtbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcHJlcGFyZS1kZXN0aW5hdGlvbi50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzLWludmFyaWFudC9saWIvaW52YXJpYW50LmNqcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHMtaW52YXJpYW50L3Byb2Nlc3MvbWFpbi5janMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL2luZGV4LmNqcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAd3J5L2NvbnRleHRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAd3J5L2VxdWFsaXR5XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQHdyeS90cmllXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ3JhcGhxbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImdyYXBocWwtdGFnXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV4dC9yb3V0ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvcHRpbWlzbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicmVhY3QtaXNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdHN0cmFwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic3R5bGVkLWpzeC9zdHlsZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN5bWJvbC1vYnNlcnZhYmxlXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidHNsaWJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6ZW4tb2JzZXJ2YWJsZS9pbmRleC5qc1wiIl0sIm5hbWVzIjpbIkNhcnQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjYXJ0IiwiYWRkSXRlbSIsInJlbW92ZUl0ZW0iLCJ1c2VDb250ZXh0IiwiQXBwQ29udGV4dCIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwicm91dGVyIiwidXNlUm91dGVyIiwicmVuZGVySXRlbXMiLCJpdGVtcyIsImxlbmd0aCIsIml0ZW1MaXN0IiwibWFwIiwiaXRlbSIsInF1YW50aXR5IiwibWFyZ2luQm90dG9tIiwiaWQiLCJwcmljZSIsIm5hbWUiLCJoZWlnaHQiLCJwYWRkaW5nIiwid2lkdGgiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkxlZnQiLCJjaGVja291dEl0ZW1zIiwiZm9udFdlaWdodCIsImNvbG9yIiwidG90YWwiLCJtYXJnaW4iLCJhc1BhdGgiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VyIiwic2V0VXNlciIsIkRpc2hlcyIsInJlc3RJZCIsInJlc3RhdXJhbnRJRCIsInNldFJlc3RhdXJhbnRJRCIsInVzZVN0YXRlIiwiR0VUX1JFU1RBVVJBTlRfRElTSEVTIiwiZ3FsIiwibG9hZGluZyIsImVycm9yIiwiZGF0YSIsInVzZVF1ZXJ5IiwidmFyaWFibGVzIiwicmVzdGF1cmFudCIsImRpc2hlcyIsInJlcyIsImltYWdlIiwidXJsIiwiZGVzY3JpcHRpb24iLCJSZXN0YXVyYW50TGlzdCIsInByb3BzIiwic3RhdGUiLCJzZXRTdGF0ZSIsIkdFVF9SRVNUQVVSQU5UUyIsInJlc3RhdXJhbnRzIiwic2VhcmNoUXVlcnkiLCJmaWx0ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic2VhcmNoIiwicmVuZGVyRGlzaGVzIiwicmVzdExpc3QiLCJsaXN0ZW5lcnMiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIndpbmRvdyIsInByZWZldGNoZWQiLCJjYWNoZWRPYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImNiIiwicm9vdE1hcmdpbiIsImxpc3RlblRvSW50ZXJzZWN0aW9ucyIsIm9ic2VydmVyIiwiZ2V0T2JzZXJ2ZXIiLCJlcnIiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzdWNjZXNzIiwiZG9jdW1lbnQiLCJhcmdzIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0IiwiY3JlYXRlUHJvcEVycm9yIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInNoYWxsb3ciLCJwYXNzSHJlZiIsInByZWZldGNoIiwib3B0aW9uYWxQcm9wcyIsImhhc1dhcm5lZCIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZEVsbSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsImNoaWxkUHJvcHMiLCJyZWYiLCJlbCIsInNldENoaWxkRWxtIiwib25DbGljayIsImxpbmtDbGlja2VkIiwicHJpb3JpdHkiLCJMaW5rIiwicGF0aCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwicHJvY2VzcyIsInNpbmdsZXRvblJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJnZXQiLCJSb3V0ZXIiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwibWVzc2FnZSIsInN0YWNrIiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlciIsIl9yb3V0ZXIiLCJpbnN0YW5jZSIsIkFycmF5IiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsImFsbCIsIm9uIiwib2ZmIiwiZW1pdCIsImhhbmRsZXIiLCJiYXNlUGF0aCIsImNhbmNlbGxlZCIsInByZWZpeCIsImFkZFBhdGhQcmVmaXgiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbXMiLCJwYXJhbSIsInZhbHVlIiwicmVwbGFjZWQiLCJyZXBlYXQiLCJvcHRpb25hbCIsImVzY2FwZVBhdGhEZWxpbWl0ZXJzIiwicmVzdWx0IiwiZmlsdGVyZWRRdWVyeSIsInF1ZXJ5IiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJoYXNoIiwib21pdFBhcm1zRnJvbVF1ZXJ5IiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZUFzIiwiUEFHRV9MT0FEX0VSUk9SIiwiU3ltYm9sIiwiYWRkQmFzZVBhdGgiLCJyZXNvbHZlSHJlZiIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiY3JlZGVudGlhbHMiLCJhdHRlbXB0cyIsImZldGNoUmV0cnkiLCJpc1NlcnZlclJlbmRlciIsIm1hcmtMb2FkaW5nRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJvdXRlIiwiY29tcG9uZW50cyIsInNkYyIsInN1YiIsImNsYyIsInBhZ2VMb2FkZXIiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImlzRmFsbGJhY2siLCJfaW5GbGlnaHRSb3V0ZSIsIl9zaGFsbG93IiwibG9jYWxlIiwibG9jYWxlcyIsImRlZmF1bHRMb2NhbGUiLCJvcHRpb25zIiwic3R5bGVTaGVldHMiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsIkNvbXBvbmVudCIsIl9fTkVYVF9EQVRBX18iLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsInByZXBhcmVVcmxBcyIsImNoYW5nZSIsImlzTG9jYWxVUkwiLCJTVCIsInBlcmZvcm1hbmNlIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwiZGVsQmFzZVBhdGgiLCJwYWdlcyIsIl9fcmV3cml0ZXMiLCJwYXJzZWQiLCJtZXRob2QiLCJwb3RlbnRpYWxIcmVmIiwicGFyc2VkQXMiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsImFwcENvbXAiLCJjaGFuZ2VTdGF0ZSIsIl9fTiIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsInBhZ2UiLCJnZXRSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJyZXF1aXJlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZGF0YUhyZWYiLCJzZXQiLCJiZWZvcmVQb3BTdGF0ZSIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwic2Nyb2xsVG9IYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiX3Jlc29sdmVIcmVmIiwiYXBwbHlCYXNlUGF0aCIsImNsZWFuUGF0aG5hbWUiLCJQcm9taXNlIiwiZmV0Y2hDb21wb25lbnQiLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJfZ2V0RGF0YSIsImZuIiwiX2dldFN0YXRpY0RhdGEiLCJmZXRjaE5leHREYXRhIiwiX2dldFNlcnZlckRhdGEiLCJBcHBUcmVlIiwiY3R4IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5Iiwic2VnbWVudCIsImNoYXIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzbGFzaGVkUHJvdG9jb2xzIiwicHJvdG9jb2wiLCJ1cmxPYmoiLCJob3N0IiwiYXV0aCIsImhvc3RuYW1lIiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJURVNUX1JPVVRFIiwiRFVNTVlfQkFTRSIsInJlc29sdmVkQmFzZSIsIm9yaWdpbiIsIm1hdGNoZXJPcHRpb25zIiwic2Vuc2l0aXZlIiwiZGVsaW1pdGVyIiwiY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9ucyIsInN0cmljdCIsImN1c3RvbVJvdXRlIiwia2V5cyIsIm1hdGNoZXJSZWdleCIsInBhdGhUb1JlZ2V4cCIsIm1hdGNoZXIiLCJwYXJzZWREZXN0aW5hdGlvbiIsImRlc3RRdWVyeSIsImRlc3RQYXRoIiwiZGVzdFBhdGhQYXJhbUtleXMiLCJkZXN0UGF0aFBhcmFtcyIsImRlc3RpbmF0aW9uQ29tcGlsZXIiLCJ2YWxpZGF0ZSIsInN0ck9yQXJyYXkiLCJxdWVyeUNvbXBpbGVyIiwicGFyYW1LZXlzIiwiYXBwZW5kUGFyYW1zVG9RdWVyeSIsInNob3VsZEFkZEJhc2VQYXRoIiwibmV3VXJsIiwic2VhcmNoUGFyYW1zIiwiaXNOYU4iLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwic2VhcmNoUGFyYW1zTGlzdCIsImN1c3RvbVJvdXRlTWF0Y2hlciIsInJld3JpdGUiLCJkZXN0UmVzIiwicmUiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbHVnTmFtZSIsImciLCJncm91cHMiLCJtIiwic3RyIiwic2VnbWVudHMiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwicGFyc2VQYXJhbWV0ZXIiLCJwb3MiLCJlc2NhcGVSZWdleCIsInJvdXRlS2V5Q2hhckNvZGUiLCJyb3V0ZUtleUNoYXJMZW5ndGgiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleSIsImkiLCJyb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImNsZWFuZWRLZXkiLCJpbnZhbGlkS2V5IiwicGFyc2VJbnQiLCJuYW1lZFJlZ2V4IiwidXNlZCIsInBvcnQiLCJnZXRMb2NhdGlvbk9yaWdpbiIsIkFwcCIsImdldERpc3BsYXlOYW1lIiwicGFnZVByb3BzIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJTUCIsIkhvbWUiLCJBUElfVVJMIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInNldFF1ZXJ5IiwibGluayIsIkh0dHBMaW5rIiwidXJpIiwiY2FjaGUiLCJJbk1lbW9yeUNhY2hlIiwiY2xpZW50IiwiQXBvbGxvQ2xpZW50IiwidG9Mb2NhbGVMb3dlckNhc2UiXSwibWFwcGluZ3MiOiI7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7UUFDQTs7UUFFQTtRQUNBOztRQUVB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QTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLDBDQUEwQztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpVEFBaVQ7QUFDalQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RTs7Ozs7Ozs7Ozs7QUNwQ0EseUM7Ozs7Ozs7Ozs7O0FDQUEsMEM7Ozs7Ozs7Ozs7O0FDQUEsc0M7Ozs7Ozs7Ozs7O0FDQUEsb0M7Ozs7Ozs7Ozs7O0FDQUEsd0M7Ozs7Ozs7Ozs7O0FDQUEsd0M7Ozs7Ozs7Ozs7O0FDQUEscUM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEscUM7Ozs7Ozs7Ozs7O0FDQUEsdUM7Ozs7Ozs7Ozs7O0FDQUEsNkM7Ozs7Ozs7Ozs7O0FDQUEsOEM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsb0QiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHJlcXVpcmUoJy4uL3Nzci1tb2R1bGUtY2FjaGUuanMnKTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0dmFyIHRocmV3ID0gdHJ1ZTtcbiBcdFx0dHJ5IHtcbiBcdFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbiBcdFx0XHR0aHJldyA9IGZhbHNlO1xuIFx0XHR9IGZpbmFsbHkge1xuIFx0XHRcdGlmKHRocmV3KSBkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdH1cblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3BhZ2VzL2luZGV4LmpzXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC5qc1wiKTsiLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9yb3V0ZXJcIjtcclxuaW1wb3J0IHsgQnV0dG9uLCBDYXJkLCBDYXJkQm9keSwgQ2FyZFRpdGxlLCBCYWRnZSB9IGZyb20gXCJyZWFjdHN0cmFwXCI7XHJcbmltcG9ydCBBcHBDb250ZXh0IGZyb20gXCIuL2NvbnRleHRcIlxyXG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCJcclxuLy8gd2UgY2FuIHBhc3MgY2FydCBkYXRhIGluIHZpYSBwcm9wcyBtZXRob2QgXHJcbi8vIHRoZSBhbHRlcm5hdGl2ZSBpcyB1c2luZyB1c2VDb250ZXh0IGFzIGJlbG93XHJcbmZ1bmN0aW9uIENhcnQoKSB7XHJcbiAgbGV0IGlzQXV0aGVudGljYXRlZCA9IHRydWU7XHJcbiAgbGV0IHtjYXJ0LGFkZEl0ZW0scmVtb3ZlSXRlbX0gPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xyXG4gIC8vY29uc3QgW2NhcnRBLCBzZXRDYXJ0QV0gPSB1c2VTdGF0ZSh7Y2FydH0pXHJcbiAgLy9jYXJ0ID0gdmFsdWUuY2FydDtcclxuICAvL2NvbnNvbGUubG9nKCdwcm9wczonKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gIGNvbnNvbGUubG9nKGBpbiBDQVJUOiAke0pTT04uc3RyaW5naWZ5KGNhcnQpfWApXHJcbiAgXHJcbiAgLy8gICBwcm9ibGVtIGlzIHRoYXQgY2FydCBtYXkgbm90IGJlIHNldFxyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4gIGNvbnNvbGUubG9nKGBSb3V0ZXIgUGF0aDogJHtKU09OLnN0cmluZ2lmeShyb3V0ZXIpfWApXHJcbiAgY29uc3QgcmVuZGVySXRlbXMgPSAoKT0+e1xyXG4gIGxldCB7aXRlbXN9ID0gY2FydDtcclxuICAgY29uc29sZS5sb2coYGl0ZW1zOiAke0pTT04uc3RyaW5naWZ5KGl0ZW1zKX1gKVxyXG4gICAgaWYoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKXtcclxuICAgICAgdmFyIGl0ZW1MaXN0ID0gY2FydC5pdGVtcy5tYXAoKGl0ZW0pID0+IHtcclxuICAgICAgICAgIGlmIChpdGVtLnF1YW50aXR5ID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIml0ZW1zLW9uZVwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDE1IH19XHJcbiAgICAgICAgICAgICAgICBrZXk9e2l0ZW0uaWR9XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9XCJpdGVtLXByaWNlXCI+Jm5ic3A7ICR7aXRlbS5wcmljZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPVwiaXRlbS1uYW1lXCI+Jm5ic3A7IHtpdGVtLm5hbWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAxMCxcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGFkZEl0ZW0oaXRlbSl9XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJsaW5rXCJcclxuICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICtcclxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNSxcclxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZW1vdmVJdGVtKGl0ZW0pfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yPVwibGlua1wiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAtXHJcbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBtYXJnaW5MZWZ0OiA1IH19IGlkPVwiaXRlbS1xdWFudGl0eVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtpdGVtLnF1YW50aXR5fXhcclxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gaXRlbUxpc3Q7XHJcbiAgICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoPGRpdj48L2Rpdj4pXHJcbiAgICB9XHJcbiAgfVxyXG5jb25zdCBjaGVja291dEl0ZW1zID0gKCk9PntcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdj5cclxuICAgICAgPEJhZGdlIHN0eWxlPXt7IHdpZHRoOiAyMDAsIHBhZGRpbmc6IDEwIH19IGNvbG9yPVwibGlnaHRcIj5cclxuICAgICAgICA8aDUgc3R5bGU9e3sgZm9udFdlaWdodDogMTAwLCBjb2xvcjogXCJncmF5XCIgfX0+VG90YWw6PC9oNT5cclxuICAgICAgICA8aDM+JHtjYXJ0LnRvdGFsfTwvaDM+XHJcbiAgICAgIDwvQmFkZ2U+XHJcbiAgICAgICAgICA8TGluayBocmVmPVwiL2NoZWNrb3V0L1wiPlxyXG4gICAgICAgICAgICA8QnV0dG9uIHN0eWxlPXt7IHdpZHRoOiBcIjYwJVwiIH19IGNvbG9yPVwicHJpbWFyeVwiPlxyXG4gICAgICAgICAgICAgIDxhPk9yZGVyPC9hPlxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgIDwvTGluaz5cclxuICAgIDwvZGl2PlxyXG4gICl9XHJcblxyXG4vLyByZXR1cm4gQ2FydFxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICA8aDE+IENhcnQ8L2gxPlxyXG4gICAgICA8Q2FyZCBzdHlsZT17eyBwYWRkaW5nOiBcIjEwcHggNXB4XCIgfX0gY2xhc3NOYW1lPVwiY2FydFwiPlxyXG4gICAgICAgIDxDYXJkVGl0bGUgc3R5bGU9e3sgbWFyZ2luOiAxMCB9fT5Zb3VyIE9yZGVyOjwvQ2FyZFRpdGxlPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxDYXJkQm9keSBzdHlsZT17eyBwYWRkaW5nOiAxMCB9fT5cclxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiA2IH19PlxyXG4gICAgICAgICAgICA8c21hbGw+SXRlbXM6PC9zbWFsbD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAge3JlbmRlckl0ZW1zKCl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIHtjaGVja291dEl0ZW1zKCl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIFxyXG4gICAgICAgICAge2NvbnNvbGUubG9nKGBSb3V0ZXIgUGF0aDogJHtyb3V0ZXIuYXNQYXRofWApfVxyXG4gICAgICAgIDwvQ2FyZEJvZHk+XHJcbiAgICAgIDwvQ2FyZD5cclxuICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICNpdGVtLXByaWNlIHtcclxuICAgICAgICAgIGZvbnQtc2l6ZTogMS4zZW07XHJcbiAgICAgICAgICBjb2xvcjogcmdiYSg5NywgOTcsIDk3LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgI2l0ZW0tcXVhbnRpdHkge1xyXG4gICAgICAgICAgZm9udC1zaXplOiAwLjk1ZW07XHJcbiAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogNHB4O1xyXG4gICAgICAgICAgY29sb3I6IHJnYmEoMTU4LCAxNTgsIDE1OCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICNpdGVtLW5hbWUge1xyXG4gICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcclxuICAgICAgICAgIGNvbG9yOiByZ2JhKDk3LCA5NywgOTcsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgYH08L3N0eWxlPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBDYXJ0OyIsIi8qIC9jb250ZXh0L0FwcENvbnRleHQuanMgKi9cclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuLy8gY3JlYXRlIGF1dGggY29udGV4dCB3aXRoIGRlZmF1bHQgdmFsdWVcclxuXHJcbi8vIHNldCBiYWNrdXAgZGVmYXVsdCBmb3IgaXNBdXRoZW50aWNhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQgaW4gUHJvdmlkZXJcclxuY29uc3QgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXHJcbiAgICB7aXNBdXRoZW50aWNhdGVkOnRydWUsIFxyXG4gICAgICAgIGNhcnQ6IHtpdGVtczpbXSwgXHJcbiAgICAgICAgdG90YWw6MH0sXHJcbiAgICAgICAgYWRkSXRlbTooKT0+e30sXHJcbiAgICAgICAgcmVtb3ZlSXRlbTooKT0+e30sXHJcbiAgICAgICAgdXNlcjpmYWxzZSwgXHJcbiAgICAgICAgc2V0VXNlcjooKT0+e31cclxuICAgIH0pO1xyXG5leHBvcnQgZGVmYXVsdCBBcHBDb250ZXh0OyIsImltcG9ydCB7dXNlUm91dGVyfSBmcm9tIFwibmV4dC9yb3V0ZXJcIlxyXG5pbXBvcnQge2dxbCx1c2VRdWVyeX0gZnJvbSAnQGFwb2xsby9jbGllbnQnO1xyXG5pbXBvcnQge3VzZVN0YXRlLCB1c2VDb250ZXh0fSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IEFwcENvbnRleHQgZnJvbSBcIi4vY29udGV4dFwiXHJcbmltcG9ydCB7XHJcbiAgQnV0dG9uLFxyXG4gIENhcmQsXHJcbiAgQ2FyZEJvZHksXHJcbiAgQ2FyZEltZyxcclxuICBDYXJkVGV4dCxcclxuICBDYXJkVGl0bGUsXHJcbiAgUm93LFxyXG4gIENvbH0gZnJvbSBcInJlYWN0c3RyYXBcIjtcclxuZnVuY3Rpb24gRGlzaGVzKHtyZXN0SWR9KXtcclxuICBjb25zdCBbcmVzdGF1cmFudElELCBzZXRSZXN0YXVyYW50SURdID0gdXNlU3RhdGUoKVxyXG4gIGNvbnN0IHthZGRJdGVtfSA9IHVzZUNvbnRleHQoQXBwQ29udGV4dClcclxuXHJcbmNvbnN0IEdFVF9SRVNUQVVSQU5UX0RJU0hFUyA9IGdxbGBcclxuICBxdWVyeSgkaWQ6IElEISkge1xyXG4gICAgcmVzdGF1cmFudChpZDogJGlkKSB7XHJcbiAgICAgIGlkXHJcbiAgICAgIG5hbWVcclxuICAgICAgZGlzaGVzIHtcclxuICAgICAgICBpZFxyXG4gICAgICAgIG5hbWVcclxuICAgICAgICBkZXNjcmlwdGlvblxyXG4gICAgICAgIHByaWNlXHJcbiAgICAgICAgaW1hZ2Uge1xyXG4gICAgICAgICAgdXJsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5gO1xyXG5cclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgY29uc3QgeyBsb2FkaW5nLCBlcnJvciwgZGF0YSB9ID0gdXNlUXVlcnkoR0VUX1JFU1RBVVJBTlRfRElTSEVTLCB7XHJcbiAgICB2YXJpYWJsZXM6IHsgaWQ6IHJlc3RJZH0sXHJcbiAgfSk7XHJcblxyXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPHA+TG9hZGluZy4uLjwvcD47XHJcbiAgaWYgKGVycm9yKSByZXR1cm4gPHA+RVJST1IgaGVyZTwvcD47XHJcbiAgaWYgKCFkYXRhKSByZXR1cm4gPHA+Tm90IGZvdW5kPC9wPjtcclxuXHJcbiAgbGV0IHJlc3RhdXJhbnQgPSBkYXRhLnJlc3RhdXJhbnQ7XHJcblxyXG4gIGlmIChyZXN0SWQgPiAwKXtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8PlxyXG4gICAgICAgICAge3Jlc3RhdXJhbnQuZGlzaGVzLm1hcCgocmVzKSA9PiAoXHJcbiAgICAgICAgICAgIDxDb2wgeHM9XCI2XCIgc209XCI0XCIgc3R5bGU9e3sgcGFkZGluZzogMCB9fSBrZXk9e3Jlcy5pZH0+XHJcbiAgICAgICAgICAgICAgPENhcmQgc3R5bGU9e3sgbWFyZ2luOiBcIjAgMTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPENhcmRJbWdcclxuICAgICAgICAgICAgICAgICAgdG9wPXt0cnVlfVxyXG4gICAgICAgICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6MTUwIH19XHJcbiAgICAgICAgICAgICAgICAgIHNyYz17YGh0dHA6Ly9sb2NhbGhvc3Q6MTMzNyR7cmVzLmltYWdlLnVybH1gfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxDYXJkQm9keT5cclxuICAgICAgICAgICAgICAgICAgPENhcmRUaXRsZT57cmVzLm5hbWV9PC9DYXJkVGl0bGU+XHJcbiAgICAgICAgICAgICAgICAgIDxDYXJkVGV4dD57cmVzLmRlc2NyaXB0aW9ufTwvQ2FyZFRleHQ+XHJcbiAgICAgICAgICAgICAgICA8L0NhcmRCb2R5PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWZvb3RlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8QnV0dG9uIGNvbG9yPVwiaW5mb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljayA9IHsoKT0+IGFkZEl0ZW0ocmVzKX1cclxuICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICsgQWRkIFRvIENhcnRcclxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9DYXJkPlxyXG4gICAgICAgICAgICA8L0NvbD5cclxuICAgICAgICAgICkpfVxyXG4gICAgICAgIDwvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgIHJldHVybiA8aDE+IE5vIERpc2hlczwvaDE+XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0IGRlZmF1bHQgRGlzaGVzIiwiaW1wb3J0IHsgZ3FsLCB1c2VRdWVyeSB9IGZyb20gJ0BhcG9sbG8vY2xpZW50JztcclxuaW1wb3J0IERpc2hlcyBmcm9tIFwiLi9kaXNoZXNcIlxyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcblxyXG5pbXBvcnQgQXBwQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0XCJcclxuaW1wb3J0IHtcclxuICBCdXR0b24sXHJcbiAgQ2FyZCxcclxuICBDYXJkQm9keSxcclxuICBDYXJkSW1nLFxyXG4gIENhcmRUZXh0LFxyXG4gIENhcmRUaXRsZSxcclxuICBDb250YWluZXIsXHJcbiAgUm93LFxyXG4gIENvbFxyXG59IGZyb20gXCJyZWFjdHN0cmFwXCI7XHJcblxyXG5mdW5jdGlvbiBSZXN0YXVyYW50TGlzdChwcm9wcykge1xyXG4gIGNvbnN0IFtyZXN0YXVyYW50SUQsIHNldFJlc3RhdXJhbnRJRF0gPSB1c2VTdGF0ZSgwKVxyXG4gIGNvbnN0IHsgY2FydCB9ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcclxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKGNhcnQpXHJcbiAgY29uc3QgR0VUX1JFU1RBVVJBTlRTID0gZ3FsYFxyXG4gICAgcXVlcnkge1xyXG4gICAgICByZXN0YXVyYW50cyB7XHJcbiAgICAgICAgaWRcclxuICAgICAgICBuYW1lXHJcbiAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICBpbWFnZSB7XHJcbiAgICAgICAgICB1cmxcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBgO1xyXG4gIGNvbnN0IHsgbG9hZGluZywgZXJyb3IsIGRhdGEgfSA9IHVzZVF1ZXJ5KEdFVF9SRVNUQVVSQU5UUylcclxuICBpZiAobG9hZGluZykgcmV0dXJuIDxwPkxvYWRpbmcuLi48L3A+O1xyXG4gIGlmIChlcnJvcikgcmV0dXJuIDxwPkVSUk9SPC9wPjtcclxuICBpZiAoIWRhdGEpIHJldHVybiA8cD5Ob3QgZm91bmQ8L3A+O1xyXG4gIGNvbnNvbGUubG9nKGBRdWVyeSBEYXRhOiAke2RhdGEucmVzdGF1cmFudHN9YClcclxuXHJcblxyXG4gIGxldCBzZWFyY2hRdWVyeSA9IGRhdGEucmVzdGF1cmFudHMuZmlsdGVyKChyZXMpID0+IHtcclxuICAgIHJldHVybiByZXMubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHByb3BzLnNlYXJjaClcclxuICB9KSB8fCBbXTtcclxuXHJcbiAgbGV0IHJlc3RJZCA9IHNlYXJjaFF1ZXJ5WzBdID8gc2VhcmNoUXVlcnlbMF0uaWQgOiBudWxsO1xyXG5cclxuICAvLyBkZWZpbmV0IHJlbmRlcmVyIGZvciBEaXNoZXNcclxuICBjb25zdCByZW5kZXJEaXNoZXMgPSAocmVzdGF1cmFudElEKSA9PiB7XHJcbiAgICByZXR1cm4gKDxEaXNoZXMgcmVzdElkPXtyZXN0YXVyYW50SUR9PiA8L0Rpc2hlcz4pXHJcbiAgfTtcclxuICBpZiAoc2VhcmNoUXVlcnkubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgcmVzdExpc3QgPSBzZWFyY2hRdWVyeS5tYXAoKHJlcykgPT4gKFxyXG4gICAgICA8Q29sIHhzPVwiNlwiIHNtPVwiNFwiIGtleT17cmVzLmlkfT5cclxuICAgICAgICA8Q2FyZCBzdHlsZT17eyBtYXJnaW46IFwiMCAwLjVyZW0gMjBweCAwLjVyZW1cIiB9fT5cclxuICAgICAgICAgIDxDYXJkSW1nXHJcbiAgICAgICAgICAgIHRvcD17dHJ1ZX1cclxuICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAyMDAgfX1cclxuICAgICAgICAgICAgc3JjPXtcclxuICAgICAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDoxMzM3YCArIHJlcy5pbWFnZS51cmxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxDYXJkQm9keT5cclxuICAgICAgICAgICAgPENhcmRUZXh0PntyZXMuZGVzY3JpcHRpb259PC9DYXJkVGV4dD5cclxuICAgICAgICAgIDwvQ2FyZEJvZHk+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtZm9vdGVyXCI+XHJcblxyXG4gICAgICAgICAgICA8QnV0dG9uIGNvbG9yPVwiaW5mb1wiIG9uQ2xpY2s9eygpID0+IHNldFJlc3RhdXJhbnRJRChyZXMuaWQpfT57cmVzLm5hbWV9PC9CdXR0b24+XHJcblxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9DYXJkPlxyXG4gICAgICA8L0NvbD5cclxuICAgICkpXHJcblxyXG4gICAgcmV0dXJuIChcclxuXHJcbiAgICAgIDxDb250YWluZXI+XHJcbiAgICAgICAgPFJvdyB4cz0nMyc+XHJcbiAgICAgICAgICB7cmVzdExpc3R9XHJcbiAgICAgICAgPC9Sb3c+XHJcblxyXG4gICAgICAgIDxSb3cgeHM9JzMnPlxyXG4gICAgICAgICAge3JlbmRlckRpc2hlcyhyZXN0YXVyYW50SUQpfVxyXG4gICAgICAgIDwvUm93PlxyXG5cclxuICAgICAgPC9Db250YWluZXI+XHJcblxyXG4gICAgKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gPGgxPiBObyBSZXN0YXVyYW50cyBGb3VuZDwvaDE+XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFJlc3RhdXJhbnRMaXN0IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIG9wdGltaXNtID0gcmVxdWlyZSgnb3B0aW1pc20nKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMnKTtcbnZhciBlcXVhbGl0eSA9IHJlcXVpcmUoJ0B3cnkvZXF1YWxpdHknKTtcbnZhciB0cmllID0gcmVxdWlyZSgnQHdyeS90cmllJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJ0B3cnkvY29udGV4dCcpO1xuXG52YXIgQXBvbGxvQ2FjaGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwb2xsb0NhY2hlKCkge1xuICAgICAgICB0aGlzLmdldEZyYWdtZW50RG9jID0gb3B0aW1pc20ud3JhcCh1dGlsaXRpZXMuZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50KTtcbiAgICB9XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGltaXN0aWNJZCA9IHR5cGVvZiBvcHRpb25zLm9wdGltaXN0aWMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLm9wdGltaXN0aWMgOlxuICAgICAgICAgICAgb3B0aW9ucy5vcHRpbWlzdGljID09PSBmYWxzZSA/IG51bGwgOiB2b2lkIDA7XG4gICAgICAgIHZhciB1cGRhdGVSZXN1bHQ7XG4gICAgICAgIHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZVJlc3VsdCA9IG9wdGlvbnMudXBkYXRlKF90aGlzKTsgfSwgb3B0aW1pc3RpY0lkKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlc3VsdDtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5yZWNvcmRPcHRpbWlzdGljVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIG9wdGltaXN0aWNJZCkge1xuICAgICAgICB0aGlzLnBlcmZvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW1pc3RpY0lkKTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5nYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Gb3JMaW5rID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5yZWFkUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSAhIW9wdGlvbnMub3B0aW1pc3RpYzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyByb290SWQ6IG9wdGlvbnMuaWQgfHwgJ1JPT1RfUVVFUlknLCBvcHRpbWlzdGljOiBvcHRpbWlzdGljIH0pKTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5yZWFkRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSAhIW9wdGlvbnMub3B0aW1pc3RpYzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBxdWVyeTogdGhpcy5nZXRGcmFnbWVudERvYyhvcHRpb25zLmZyYWdtZW50LCBvcHRpb25zLmZyYWdtZW50TmFtZSksIHJvb3RJZDogb3B0aW9ucy5pZCwgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyB9KSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUud3JpdGVRdWVyeSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaWQgPSBfYS5pZCwgZGF0YSA9IF9hLmRhdGEsIG9wdGlvbnMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImlkXCIsIFwiZGF0YVwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgICAgZGF0YUlkOiBpZCB8fCAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICByZXN1bHQ6IGRhdGEsXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS53cml0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpZCA9IF9hLmlkLCBkYXRhID0gX2EuZGF0YSwgZnJhZ21lbnQgPSBfYS5mcmFnbWVudCwgZnJhZ21lbnROYW1lID0gX2EuZnJhZ21lbnROYW1lLCBvcHRpb25zID0gdHNsaWIuX19yZXN0KF9hLCBbXCJpZFwiLCBcImRhdGFcIiwgXCJmcmFnbWVudFwiLCBcImZyYWdtZW50TmFtZVwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuZ2V0RnJhZ21lbnREb2MoZnJhZ21lbnQsIGZyYWdtZW50TmFtZSksXG4gICAgICAgICAgICBkYXRhSWQ6IGlkLFxuICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUudXBkYXRlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgdXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoKHtcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FjaGUucmVhZFF1ZXJ5KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwIHx8IGRhdGEgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYWNoZS53cml0ZVF1ZXJ5KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkYXRhOiBkYXRhIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnVwZGF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaCh7XG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhY2hlLnJlYWRGcmFnbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCB8fCBkYXRhID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgY2FjaGUud3JpdGVGcmFnbWVudCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZGF0YTogZGF0YSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcG9sbG9DYWNoZTtcbn0oKSk7XG5cbmV4cG9ydHMuQ2FjaGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKENhY2hlKSB7XG59KShleHBvcnRzLkNhY2hlIHx8IChleHBvcnRzLkNhY2hlID0ge30pKTtcblxudmFyIE1pc3NpbmdGaWVsZEVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXNzaW5nRmllbGRFcnJvcihtZXNzYWdlLCBwYXRoLCBxdWVyeSwgdmFyaWFibGVzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgfVxuICAgIHJldHVybiBNaXNzaW5nRmllbGRFcnJvcjtcbn0oKSk7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gZGVmYXVsdERhdGFJZEZyb21PYmplY3QoX2EsIGNvbnRleHQpIHtcbiAgICB2YXIgX190eXBlbmFtZSA9IF9hLl9fdHlwZW5hbWUsIGlkID0gX2EuaWQsIF9pZCA9IF9hLl9pZDtcbiAgICBpZiAodHlwZW9mIF9fdHlwZW5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQua2V5T2JqZWN0ID1cbiAgICAgICAgICAgICAgICBpZCAhPT0gdm9pZCAwID8geyBpZDogaWQgfSA6XG4gICAgICAgICAgICAgICAgICAgIF9pZCAhPT0gdm9pZCAwID8geyBfaWQ6IF9pZCB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMClcbiAgICAgICAgICAgIGlkID0gX2lkO1xuICAgICAgICBpZiAoaWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF9fdHlwZW5hbWUsIFwiOlwiKS5jb25jYXQoKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIikgPyBpZCA6IEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBkYXRhSWRGcm9tT2JqZWN0OiBkZWZhdWx0RGF0YUlkRnJvbU9iamVjdCxcbiAgICBhZGRUeXBlbmFtZTogdHJ1ZSxcbiAgICByZXN1bHRDYWNoaW5nOiB0cnVlLFxuICAgIGNhbm9uaXplUmVzdWx0czogZmFsc2UsXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiB1dGlsaXRpZXMuY29tcGFjdChkZWZhdWx0Q29uZmlnLCBjb25maWcpO1xufVxuZnVuY3Rpb24gc2hvdWxkQ2Fub25pemVSZXN1bHRzKGNvbmZpZykge1xuICAgIHZhciB2YWx1ZSA9IGNvbmZpZy5jYW5vbml6ZVJlc3VsdHM7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBkZWZhdWx0Q29uZmlnLmNhbm9uaXplUmVzdWx0cyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZW5hbWVGcm9tU3RvcmVPYmplY3Qoc3RvcmUsIG9iamVjdE9yUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSlcbiAgICAgICAgPyBzdG9yZS5nZXQob2JqZWN0T3JSZWZlcmVuY2UuX19yZWYsIFwiX190eXBlbmFtZVwiKVxuICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlICYmIG9iamVjdE9yUmVmZXJlbmNlLl9fdHlwZW5hbWU7XG59XG52YXIgVHlwZU9yRmllbGROYW1lUmVnRXhwID0gL15bX2Etel1bXzAtOWEtel0qL2k7XG5mdW5jdGlvbiBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKSB7XG4gICAgdmFyIG1hdGNoID0gc3RvcmVGaWVsZE5hbWUubWF0Y2goVHlwZU9yRmllbGROYW1lUmVnRXhwKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6IHN0b3JlRmllbGROYW1lO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdChzZWxlY3Rpb25TZXQsIHJlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheShyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC5ldmVyeShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdChzZWxlY3Rpb25TZXQsIGl0ZW0sIHZhcmlhYmxlcyk7IH0pXG4gICAgICAgICAgICA6IHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNGaWVsZChmaWVsZCkgJiYgdXRpbGl0aWVzLnNob3VsZEluY2x1ZGUoZmllbGQsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHV0aWxpdGllcy5yZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKHJlc3VsdCwga2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmaWVsZC5zZWxlY3Rpb25TZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXRNYXRjaGVzUmVzdWx0KGZpZWxkLnNlbGVjdGlvblNldCwgcmVzdWx0W2tleV0sIHZhcmlhYmxlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAhdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSAmJlxuICAgICAgICAhaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCkge1xuICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLkRlZXBNZXJnZXI7XG59XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpOyB9O1xuXG52YXIgREVMRVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBkZWxNb2RpZmllciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERFTEVURTsgfTtcbnZhciBJTlZBTElEQVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuRW50aXR5U3RvcmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudGl0eVN0b3JlKHBvbGljaWVzLCBncm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvbGljaWVzID0gcG9saWNpZXM7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yb290SWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yZWZzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5nZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkgeyByZXR1cm4gdXRpbGl0aWVzLm1heWJlRGVlcEZyZWV6ZSh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2JqZWN0T3JSZWZlcmVuY2UpXG4gICAgICAgICAgICA/IF90aGlzLmdldChvYmplY3RPclJlZmVyZW5jZS5fX3JlZiwgc3RvcmVGaWVsZE5hbWUpXG4gICAgICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlICYmIG9iamVjdE9yUmVmZXJlbmNlW3N0b3JlRmllbGROYW1lXSk7IH07XG4gICAgICAgIHRoaXMuY2FuUmVhZCA9IGZ1bmN0aW9uIChvYmpPclJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmpPclJlZilcbiAgICAgICAgICAgICAgICA/IF90aGlzLmhhcyhvYmpPclJlZi5fX3JlZilcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmpPclJlZiA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmpPcklkT3JSZWYsIG1lcmdlSW50b1N0b3JlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iak9ySWRPclJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsaXRpZXMubWFrZVJlZmVyZW5jZShvYmpPcklkT3JSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmpPcklkT3JSZWYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iak9ySWRPclJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLnBvbGljaWVzLmlkZW50aWZ5KG9iak9ySWRPclJlZilbMF07XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZUludG9TdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXJnZShpZCwgb2JqT3JJZE9yUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24oe30sIHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAoZGF0YUlkLCB0cnVlKSAhPT0gdm9pZCAwO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkYXRhSWQsIGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLmdyb3VwLmRlcGVuZChkYXRhSWQsIGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU9iamVjdCA9IHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICAgICAgaWYgKHN0b3JlT2JqZWN0ICYmIGhhc093bi5jYWxsKHN0b3JlT2JqZWN0LCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlT2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gXCJfX3R5cGVuYW1lXCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMucG9saWNpZXMucm9vdFR5cGVuYW1lc0J5SWQsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChkYXRhSWQsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAoZGF0YUlkLCBkZXBlbmRPbkV4aXN0ZW5jZSkge1xuICAgICAgICBpZiAoZGVwZW5kT25FeGlzdGVuY2UpXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmRlcGVuZChkYXRhSWQsIFwiX19leGlzdHNcIik7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubG9va3VwKGRhdGFJZCwgZGVwZW5kT25FeGlzdGVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob2xkZXIsIG5ld2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhSWQ7XG4gICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2xkZXIpKVxuICAgICAgICAgICAgb2xkZXIgPSBvbGRlci5fX3JlZjtcbiAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShuZXdlcikpXG4gICAgICAgICAgICBuZXdlciA9IG5ld2VyLl9fcmVmO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0eXBlb2Ygb2xkZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gdGhpcy5sb29rdXAoZGF0YUlkID0gb2xkZXIpXG4gICAgICAgICAgICA6IG9sZGVyO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSB0eXBlb2YgbmV3ZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gdGhpcy5sb29rdXAoZGF0YUlkID0gbmV3ZXIpXG4gICAgICAgICAgICA6IG5ld2VyO1xuICAgICAgICBpZiAoIWluY29taW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQodHlwZW9mIGRhdGFJZCA9PT0gXCJzdHJpbmdcIiwgXCJzdG9yZS5tZXJnZSBleHBlY3RzIGEgc3RyaW5nIElEXCIpIDogZ2xvYmFscy5pbnZhcmlhbnQodHlwZW9mIGRhdGFJZCA9PT0gXCJzdHJpbmdcIiwgMSk7XG4gICAgICAgIHZhciBtZXJnZWQgPSBuZXcgdXRpbGl0aWVzLkRlZXBNZXJnZXIoc3RvcmVPYmplY3RSZWNvbmNpbGVyKS5tZXJnZShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IG1lcmdlZDtcbiAgICAgICAgaWYgKG1lcmdlZCAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzVG9EaXJ0eV8xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nKVxuICAgICAgICAgICAgICAgICAgICBmaWVsZHNUb0RpcnR5XzEuX19leGlzdHMgPSAxO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nIHx8IGV4aXN0aW5nW3N0b3JlRmllbGROYW1lXSAhPT0gbWVyZ2VkW3N0b3JlRmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzVG9EaXJ0eV8xW3N0b3JlRmllbGROYW1lXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSBzdG9yZUZpZWxkTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5wb2xpY2llcy5oYXNLZXlBcmdzKG1lcmdlZC5fX3R5cGVuYW1lLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzVG9EaXJ0eV8xW2ZpZWxkTmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZFtzdG9yZUZpZWxkTmFtZV0gPT09IHZvaWQgMCAmJiAhKF90aGlzIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlZFtzdG9yZUZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzVG9EaXJ0eV8xLl9fdHlwZW5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgIShleGlzdGluZyAmJiBleGlzdGluZy5fX3R5cGVuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0gPT09IG1lcmdlZC5fX3R5cGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNUb0RpcnR5XzEuX190eXBlbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzVG9EaXJ0eV8xKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHsgcmV0dXJuIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgZmllbGROYW1lKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoZGF0YUlkLCBmaWVsZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gdGhpcy5sb29rdXAoZGF0YUlkKTtcbiAgICAgICAgaWYgKHN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZEZpZWxkc18xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHZhciBuZWVkVG9NZXJnZV8xID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWxsRGVsZXRlZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzaGFyZWREZXRhaWxzXzEgPSB7XG4gICAgICAgICAgICAgICAgREVMRVRFOiBERUxFVEUsXG4gICAgICAgICAgICAgICAgSU5WQUxJREFURTogSU5WQUxJREFURSxcbiAgICAgICAgICAgICAgICBpc1JlZmVyZW5jZTogdXRpbGl0aWVzLmlzUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIHRvUmVmZXJlbmNlOiB0aGlzLnRvUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIGNhblJlYWQ6IHRoaXMuY2FuUmVhZCxcbiAgICAgICAgICAgICAgICByZWFkRmllbGQ6IGZ1bmN0aW9uIChmaWVsZE5hbWVPck9wdGlvbnMsIGZyb20pIHsgcmV0dXJuIF90aGlzLnBvbGljaWVzLnJlYWRGaWVsZCh0eXBlb2YgZmllbGROYW1lT3JPcHRpb25zID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSB8fCB1dGlsaXRpZXMubWFrZVJlZmVyZW5jZShkYXRhSWQpLFxuICAgICAgICAgICAgICAgIH0gOiBmaWVsZE5hbWVPck9wdGlvbnMsIHsgc3RvcmU6IF90aGlzIH0pOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRWYWx1ZSA9IHN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmeSA9IHR5cGVvZiBmaWVsZHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGZpZWxkc1tzdG9yZUZpZWxkTmFtZV0gfHwgZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBtb2RpZnkgPT09IGRlbE1vZGlmaWVyID8gREVMRVRFIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeSh1dGlsaXRpZXMubWF5YmVEZWVwRnJlZXplKGZpZWxkVmFsdWUpLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2hhcmVkRGV0YWlsc18xKSwgeyBmaWVsZE5hbWU6IGZpZWxkTmFtZSwgc3RvcmVGaWVsZE5hbWU6IHN0b3JlRmllbGROYW1lLCBzdG9yYWdlOiBfdGhpcy5nZXRTdG9yYWdlKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBJTlZBTElEQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xW3N0b3JlRmllbGROYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb01lcmdlXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERlbGV0ZWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5lZWRUb01lcmdlXzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlKGRhdGFJZCwgY2hhbmdlZEZpZWxkc18xKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGVsZXRlZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtkYXRhSWRdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGlydHkoZGF0YUlkLCBcIl9fZXhpc3RzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGRhdGFJZCwgZmllbGROYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gdGhpcy5sb29rdXAoZGF0YUlkKTtcbiAgICAgICAgaWYgKHN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWUgPSB0aGlzLmdldEZpZWxkVmFsdWUoc3RvcmVPYmplY3QsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIHZhciBzdG9yZUZpZWxkTmFtZSA9IGZpZWxkTmFtZSAmJiBhcmdzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnBvbGljaWVzLmdldFN0b3JlRmllbGROYW1lKHsgdHlwZW5hbWU6IHR5cGVuYW1lLCBmaWVsZE5hbWU6IGZpZWxkTmFtZSwgYXJnczogYXJncyB9KVxuICAgICAgICAgICAgICAgIDogZmllbGROYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUgPyAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtzdG9yZUZpZWxkTmFtZV0gPSBkZWxNb2RpZmllcixcbiAgICAgICAgICAgICAgICBfYSkgOiBkZWxNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGxpbWl0KSB7XG4gICAgICAgIHZhciBldmljdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwodGhpcy5kYXRhLCBvcHRpb25zLmlkKSkge1xuICAgICAgICAgICAgICAgIGV2aWN0ZWQgPSB0aGlzLmRlbGV0ZShvcHRpb25zLmlkLCBvcHRpb25zLmZpZWxkTmFtZSwgb3B0aW9ucy5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcyAhPT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBldmljdGVkID0gdGhpcy5wYXJlbnQuZXZpY3Qob3B0aW9ucywgbGltaXQpIHx8IGV2aWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWVsZE5hbWUgfHwgZXZpY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGlydHkob3B0aW9ucy5pZCwgb3B0aW9ucy5maWVsZE5hbWUgfHwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZpY3RlZDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIHZhciBleHRyYVJvb3RJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRSb290SWRTZXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChfdGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCwgaWQpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFSb290SWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4dHJhUm9vdElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5fX01FVEEgPSB7IGV4dHJhUm9vdElkczogZXh0cmFSb290SWRzLnNvcnQoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICBpZiAoIShuZXdEYXRhICYmIGhhc093bi5jYWxsKG5ld0RhdGEsIGRhdGFJZCkpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgdmFyIF9fTUVUQSA9IG5ld0RhdGEuX19NRVRBLCByZXN0XzEgPSB0c2xpYi5fX3Jlc3QobmV3RGF0YSwgW1wiX19NRVRBXCJdKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3RfMSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoZGF0YUlkLCByZXN0XzFbZGF0YUlkXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfX01FVEEpIHtcbiAgICAgICAgICAgICAgICBfX01FVEEuZXh0cmFSb290SWRzLmZvckVhY2godGhpcy5yZXRhaW4sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJvb3RJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290SWRzW3Jvb3RJZF0gPSAodGhpcy5yb290SWRzW3Jvb3RJZF0gfHwgMCkgKyAxO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAocm9vdElkKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RJZHNbcm9vdElkXSA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IC0tdGhpcy5yb290SWRzW3Jvb3RJZF07XG4gICAgICAgICAgICBpZiAoIWNvdW50KVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJvb3RJZHNbcm9vdElkXTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5nZXRSb290SWRTZXQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIGlmIChpZHMgPT09IHZvaWQgMCkgeyBpZHMgPSBuZXcgU2V0KCk7IH1cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yb290SWRzKS5mb3JFYWNoKGlkcy5hZGQsIGlkcyk7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFJvb3RJZFNldChpZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCkuZm9yRWFjaChpZHMuYWRkLCBpZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmdldFJvb3RJZFNldCgpO1xuICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKHNuYXBzaG90LCBpZCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5maW5kQ2hpbGRSZWZJZHMoaWQpKS5mb3JFYWNoKGlkcy5hZGQsIGlkcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNuYXBzaG90W2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKHNuYXBzaG90KTtcbiAgICAgICAgaWYgKGlkc1RvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJvb3RfMSA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocm9vdF8xIGluc3RhbmNlb2YgTGF5ZXIpXG4gICAgICAgICAgICAgICAgcm9vdF8xID0gcm9vdF8xLnBhcmVudDtcbiAgICAgICAgICAgIGlkc1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByb290XzEuZGVsZXRlKGlkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkc1RvUmVtb3ZlO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmZpbmRDaGlsZFJlZklkcyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0aGlzLnJlZnMsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZF8xID0gdGhpcy5yZWZzW2RhdGFJZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmICghcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRfMTtcbiAgICAgICAgICAgIHZhciB3b3JrU2V0XzEgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICAgICAgICB3b3JrU2V0XzEuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kXzFbb2JqLl9fcmVmXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1NldF8xLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNbZGF0YUlkXTtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5tYWtlQ2FjaGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwLmtleU1ha2VyLmxvb2t1cEFycmF5KGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gRW50aXR5U3RvcmU7XG59KCkpO1xudmFyIENhY2hlR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlR3JvdXAoY2FjaGluZywgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuY2FjaGluZyA9IGNhY2hpbmc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0Q2FjaGluZygpO1xuICAgIH1cbiAgICBDYWNoZUdyb3VwLnByb3RvdHlwZS5yZXNldENhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZCA9IHRoaXMuY2FjaGluZyA/IG9wdGltaXNtLmRlcCgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5rZXlNYWtlciA9IG5ldyB0cmllLlRyaWUodXRpbGl0aWVzLmNhblVzZVdlYWtNYXApO1xuICAgIH07XG4gICAgQ2FjaGVHcm91cC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZCkge1xuICAgICAgICAgICAgdGhpcy5kKG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmQobWFrZURlcEtleShkYXRhSWQsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGVwZW5kKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWNoZUdyb3VwLnByb3RvdHlwZS5kaXJ0eSA9IGZ1bmN0aW9uIChkYXRhSWQsIHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmQpIHtcbiAgICAgICAgICAgIHRoaXMuZC5kaXJ0eShtYWtlRGVwS2V5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpLCBzdG9yZUZpZWxkTmFtZSA9PT0gXCJfX2V4aXN0c1wiID8gXCJmb3JnZXRcIiA6IFwic2V0RGlydHlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZUdyb3VwO1xufSgpKTtcbmZ1bmN0aW9uIG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkge1xuICAgIHJldHVybiBzdG9yZUZpZWxkTmFtZSArICcjJyArIGRhdGFJZDtcbn1cbmZ1bmN0aW9uIG1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eShzdG9yZSwgZW50aXR5SWQpIHtcbiAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKHN0b3JlKSkge1xuICAgICAgICBzdG9yZS5ncm91cC5kZXBlbmQoZW50aXR5SWQsIFwiX19leGlzdHNcIik7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChFbnRpdHlTdG9yZSkge1xuICAgIHZhciBSb290ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWIuX19leHRlbmRzKFJvb3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3QoX2EpIHtcbiAgICAgICAgICAgIHZhciBwb2xpY2llcyA9IF9hLnBvbGljaWVzLCBfYiA9IF9hLnJlc3VsdENhY2hpbmcsIHJlc3VsdENhY2hpbmcgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBzZWVkID0gX2Euc2VlZDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBvbGljaWVzLCBuZXcgQ2FjaGVHcm91cChyZXN1bHRDYWNoaW5nKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnN0dW1wID0gbmV3IFN0dW1wKF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN0b3JhZ2VUcmllID0gbmV3IHRyaWUuVHJpZSh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCk7XG4gICAgICAgICAgICBpZiAoc2VlZClcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlKHNlZWQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFJvb3QucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKGxheWVySWQsIHJlcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1bXAuYWRkTGF5ZXIobGF5ZXJJZCwgcmVwbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm9vdC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgUm9vdC5wcm90b3R5cGUuZ2V0U3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VUcmllLmxvb2t1cEFycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb290O1xuICAgIH0oRW50aXR5U3RvcmUpKTtcbiAgICBFbnRpdHlTdG9yZS5Sb290ID0gUm9vdDtcbn0pKGV4cG9ydHMuRW50aXR5U3RvcmUgfHwgKGV4cG9ydHMuRW50aXR5U3RvcmUgPSB7fSkpO1xudmFyIExheWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5ZXIoaWQsIHBhcmVudCwgcmVwbGF5LCBncm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQucG9saWNpZXMsIGdyb3VwKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgX3RoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgcmVwbGF5KF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXllci5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJJZCwgcmVwbGF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXIobGF5ZXJJZCwgdGhpcywgcmVwbGF5LCB0aGlzLmdyb3VwKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIChsYXllcklkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudC5yZW1vdmVMYXllcihsYXllcklkKTtcbiAgICAgICAgaWYgKGxheWVySWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3duU3RvcmVPYmplY3QgPSBfdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdG9yZU9iamVjdCA9IHBhcmVudFtcImxvb2t1cFwiXShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3duU3RvcmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudFN0b3JlT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3duU3RvcmVPYmplY3QgIT09IHBhcmVudFN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvd25TdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5LmVxdWFsKG93blN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXSwgcGFyZW50U3RvcmVPYmplY3Rbc3RvcmVGaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gcGFyZW50LmFkZExheWVyKHRoaXMuaWQsIHRoaXMucmVwbGF5KTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnBhcmVudC50b09iamVjdCgpKSwgdGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5maW5kQ2hpbGRSZWZJZHMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHZhciBmcm9tUGFyZW50ID0gdGhpcy5wYXJlbnQuZmluZENoaWxkUmVmSWRzKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiBoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkgPyB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZnJvbVBhcmVudCksIF9zdXBlci5wcm90b3R5cGUuZmluZENoaWxkUmVmSWRzLmNhbGwodGhpcywgZGF0YUlkKSkgOiBmcm9tUGFyZW50O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwLnBhcmVudClcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHAuZ2V0U3RvcmFnZS5hcHBseShwLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIExheWVyO1xufShleHBvcnRzLkVudGl0eVN0b3JlKSk7XG52YXIgU3R1bXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTdHVtcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHVtcChyb290KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIkVudGl0eVN0b3JlLlN0dW1wXCIsIHJvb3QsIGZ1bmN0aW9uICgpIHsgfSwgbmV3IENhY2hlR3JvdXAocm9vdC5ncm91cC5jYWNoaW5nLCByb290Lmdyb3VwKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU3R1bXAucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0dW1wLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm1lcmdlLmFwcGx5KHRoaXMucGFyZW50LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0dW1wO1xufShMYXllcikpO1xuZnVuY3Rpb24gc3RvcmVPYmplY3RSZWNvbmNpbGVyKGV4aXN0aW5nT2JqZWN0LCBpbmNvbWluZ09iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICB2YXIgaW5jb21pbmdWYWx1ZSA9IGluY29taW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gZXF1YWxpdHkuZXF1YWwoZXhpc3RpbmdWYWx1ZSwgaW5jb21pbmdWYWx1ZSkgPyBleGlzdGluZ1ZhbHVlIDogaW5jb21pbmdWYWx1ZTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUmVzdWx0Q2FjaGluZyhzdG9yZSkge1xuICAgIHJldHVybiAhIShzdG9yZSBpbnN0YW5jZW9mIGV4cG9ydHMuRW50aXR5U3RvcmUgJiYgc3RvcmUuZ3JvdXAuY2FjaGluZyk7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZS5zbGljZSgwKVxuICAgICAgICAgICAgOiB0c2xpYi5fX2Fzc2lnbih7IF9fcHJvdG9fXzogT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSB9LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbnZhciBPYmplY3RDYW5vbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0Q2Fub24oKSB7XG4gICAgICAgIHRoaXMua25vd24gPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrU2V0ID8gV2Vha1NldCA6IFNldCkoKTtcbiAgICAgICAgdGhpcy5wb29sID0gbmV3IHRyaWUuVHJpZSh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCk7XG4gICAgICAgIHRoaXMucGFzc2VzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5rZXlzQnlKU09OID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVtcHR5ID0gdGhpcy5hZG1pdCh7fSk7XG4gICAgfVxuICAgIE9iamVjdENhbm9uLnByb3RvdHlwZS5pc0tub3duID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJiB0aGlzLmtub3duLmhhcyh2YWx1ZSk7XG4gICAgfTtcbiAgICBPYmplY3RDYW5vbi5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuc2V0KGNvcHksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdENhbm9uLnByb3RvdHlwZS5hZG1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMucGFzc2VzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFycmF5LnByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rbm93bi5oYXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB2YWx1ZS5tYXAodGhpcy5hZG1pdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wb29sLmxvb2t1cEFycmF5KGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtub3duLmFkZChub2RlLmFycmF5ID0gYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIGNhc2UgT2JqZWN0LnByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rbm93bi5oYXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdG9fMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheV8xID0gW3Byb3RvXzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuc29ydGVkS2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5XzEucHVzaChrZXlzLmpzb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RWYWx1ZUluZGV4XzEgPSBhcnJheV8xLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zb3J0ZWQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheV8xLnB1c2goX3RoaXMuYWRtaXQodmFsdWVba2V5XSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBvb2wubG9va3VwQXJyYXkoYXJyYXlfMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpfMSA9IG5vZGUub2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShwcm90b18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua25vd24uYWRkKG9ial8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuc29ydGVkLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial8xW2tleV0gPSBhcnJheV8xW2ZpcnN0VmFsdWVJbmRleF8xICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShvYmpfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUub2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBPYmplY3RDYW5vbi5wcm90b3R5cGUuc29ydGVkS2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucG9vbC5sb29rdXBBcnJheShrZXlzKTtcbiAgICAgICAgaWYgKCFub2RlLmtleXMpIHtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShrZXlzKTtcbiAgICAgICAgICAgIGlmICghKG5vZGUua2V5cyA9IHRoaXMua2V5c0J5SlNPTi5nZXQoanNvbikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzQnlKU09OLnNldChqc29uLCBub2RlLmtleXMgPSB7IHNvcnRlZDoga2V5cywganNvbjoganNvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5rZXlzO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdENhbm9uO1xufSgpKTtcbnZhciBjYW5vbmljYWxTdHJpbmdpZnkgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoc3RyaW5naWZ5Q2Fub24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzZXRDYW5vbmljYWxTdHJpbmdpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2Fub25pY2FsID0gc3RyaW5naWZ5Q2Fub24uYWRtaXQodmFsdWUpO1xuICAgICAgICB2YXIganNvbiA9IHN0cmluZ2lmeUNhY2hlLmdldChjYW5vbmljYWwpO1xuICAgICAgICBpZiAoanNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlDYWNoZS5zZXQoY2Fub25pY2FsLCBqc29uID0gSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59LCB7XG4gICAgcmVzZXQ6IHJlc2V0Q2Fub25pY2FsU3RyaW5naWZ5LFxufSk7XG52YXIgc3RyaW5naWZ5Q2Fub247XG52YXIgc3RyaW5naWZ5Q2FjaGU7XG5mdW5jdGlvbiByZXNldENhbm9uaWNhbFN0cmluZ2lmeSgpIHtcbiAgICBzdHJpbmdpZnlDYW5vbiA9IG5ldyBPYmplY3RDYW5vbjtcbiAgICBzdHJpbmdpZnlDYWNoZSA9IG5ldyAodXRpbGl0aWVzLmNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xufVxuXG5mdW5jdGlvbiBleGVjU2VsZWN0aW9uU2V0S2V5QXJncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25TZXQsXG4gICAgICAgIG9wdGlvbnMub2JqZWN0T3JSZWZlcmVuY2UsXG4gICAgICAgIG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgb3B0aW9ucy5jb250ZXh0LmNhbm9uaXplUmVzdWx0cyxcbiAgICBdO1xufVxudmFyIFN0b3JlUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZVJlYWRlcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5rbm93blJlc3VsdHMgPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrTWFwID8gV2Vha01hcCA6IE1hcCkoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB1dGlsaXRpZXMuY29tcGFjdChjb25maWcsIHtcbiAgICAgICAgICAgIGFkZFR5cGVuYW1lOiBjb25maWcuYWRkVHlwZW5hbWUgIT09IGZhbHNlLFxuICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiBzaG91bGRDYW5vbml6ZVJlc3VsdHMoY29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2Fub24gPSBjb25maWcuY2Fub24gfHwgbmV3IE9iamVjdENhbm9uO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQgPSBvcHRpbWlzbS53cmFwKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY2Fub25pemVSZXN1bHRzID0gb3B0aW9ucy5jb250ZXh0LmNhbm9uaXplUmVzdWx0cztcbiAgICAgICAgICAgIHZhciBwZWVrQXJncyA9IGV4ZWNTZWxlY3Rpb25TZXRLZXlBcmdzKG9wdGlvbnMpO1xuICAgICAgICAgICAgcGVla0FyZ3NbM10gPSAhY2Fub25pemVSZXN1bHRzO1xuICAgICAgICAgICAgdmFyIG90aGVyID0gKF9hID0gX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCkucGVlay5hcHBseShfYSwgcGVla0FyZ3MpO1xuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm9uaXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG90aGVyKSwgeyByZXN1bHQ6IF90aGlzLmNhbm9uLmFkbWl0KG90aGVyLnJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eShvcHRpb25zLmNvbnRleHQuc3RvcmUsIG9wdGlvbnMuZW5jbG9zaW5nUmVmLl9fcmVmKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5leGVjU2VsZWN0aW9uU2V0SW1wbChvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBrZXlBcmdzOiBleGVjU2VsZWN0aW9uU2V0S2V5QXJncyxcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKHNlbGVjdGlvblNldCwgcGFyZW50LCBjb250ZXh0LCBjYW5vbml6ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0b3JlLm1ha2VDYWNoZUtleShzZWxlY3Rpb25TZXQsIHV0aWxpdGllcy5pc1JlZmVyZW5jZShwYXJlbnQpID8gcGFyZW50Ll9fcmVmIDogcGFyZW50LCBjb250ZXh0LnZhclN0cmluZywgY2Fub25pemVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5ID0gb3B0aW1pc20ud3JhcChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgbWF5YmVEZXBlbmRPbkV4aXN0ZW5jZU9mRW50aXR5KG9wdGlvbnMuY29udGV4dC5zdG9yZSwgb3B0aW9ucy5lbmNsb3NpbmdSZWYuX19yZWYpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4ZWNTdWJTZWxlY3RlZEFycmF5SW1wbChvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCBhcnJheSA9IF9hLmFycmF5LCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0b3JlLm1ha2VDYWNoZUtleShmaWVsZCwgYXJyYXksIGNvbnRleHQudmFyU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUucmVzZXRDYW5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5vbiA9IG5ldyBPYmplY3RDYW5vbjtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gX2Euc3RvcmUsIHF1ZXJ5ID0gX2EucXVlcnksIF9iID0gX2Eucm9vdElkLCByb290SWQgPSBfYiA9PT0gdm9pZCAwID8gJ1JPT1RfUVVFUlknIDogX2IsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2MgPSBfYS5yZXR1cm5QYXJ0aWFsRGF0YSwgcmV0dXJuUGFydGlhbERhdGEgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IF9hLmNhbm9uaXplUmVzdWx0cywgY2Fub25pemVSZXN1bHRzID0gX2QgPT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLmNhbm9uaXplUmVzdWx0cyA6IF9kO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNvbmZpZy5jYWNoZS5wb2xpY2llcztcbiAgICAgICAgdmFyaWFibGVzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHV0aWxpdGllcy5nZXREZWZhdWx0VmFsdWVzKHV0aWxpdGllcy5nZXRRdWVyeURlZmluaXRpb24ocXVlcnkpKSksIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciByb290UmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2Uocm9vdElkKTtcbiAgICAgICAgdmFyIGV4ZWNSZXN1bHQgPSB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiB1dGlsaXRpZXMuZ2V0TWFpbkRlZmluaXRpb24ocXVlcnkpLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG9iamVjdE9yUmVmZXJlbmNlOiByb290UmVmLFxuICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiByb290UmVmLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgcG9saWNpZXM6IHBvbGljaWVzLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIHZhclN0cmluZzogY2Fub25pY2FsU3RyaW5naWZ5KHZhcmlhYmxlcyksXG4gICAgICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiBjYW5vbml6ZVJlc3VsdHMsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRNYXA6IHV0aWxpdGllcy5jcmVhdGVGcmFnbWVudE1hcCh1dGlsaXRpZXMuZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhxdWVyeSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtaXNzaW5nO1xuICAgICAgICBpZiAoZXhlY1Jlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICBtaXNzaW5nID0gW25ldyBNaXNzaW5nRmllbGRFcnJvcihmaXJzdE1pc3NpbmcoZXhlY1Jlc3VsdC5taXNzaW5nKSwgZXhlY1Jlc3VsdC5taXNzaW5nLCBxdWVyeSwgdmFyaWFibGVzKV07XG4gICAgICAgICAgICBpZiAoIXJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbWlzc2luZ1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBleGVjUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAhbWlzc2luZyxcbiAgICAgICAgICAgIG1pc3Npbmc6IG1pc3NpbmcsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUuaXNGcmVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIHBhcmVudCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc3VsdENhY2hpbmcoY29udGV4dC5zdG9yZSkgJiZcbiAgICAgICAgICAgIHRoaXMua25vd25SZXN1bHRzLmdldChyZXN1bHQpID09PSBzZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIHZhciBsYXRlc3QgPSB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQucGVlayhzZWxlY3Rpb25TZXQsIHBhcmVudCwgY29udGV4dCwgdGhpcy5jYW5vbi5pc0tub3duKHJlc3VsdCkpO1xuICAgICAgICAgICAgaWYgKGxhdGVzdCAmJiByZXN1bHQgPT09IGxhdGVzdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUuZXhlY1NlbGVjdGlvblNldEltcGwgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgb2JqZWN0T3JSZWZlcmVuY2UgPSBfYS5vYmplY3RPclJlZmVyZW5jZSwgZW5jbG9zaW5nUmVmID0gX2EuZW5jbG9zaW5nUmVmLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSkgJiZcbiAgICAgICAgICAgICFjb250ZXh0LnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW29iamVjdE9yUmVmZXJlbmNlLl9fcmVmXSAmJlxuICAgICAgICAgICAgIWNvbnRleHQuc3RvcmUuaGFzKG9iamVjdE9yUmVmZXJlbmNlLl9fcmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRoaXMuY2Fub24uZW1wdHksXG4gICAgICAgICAgICAgICAgbWlzc2luZzogXCJEYW5nbGluZyByZWZlcmVuY2UgdG8gbWlzc2luZyBcIi5jb25jYXQob2JqZWN0T3JSZWZlcmVuY2UuX19yZWYsIFwiIG9iamVjdFwiKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IGNvbnRleHQudmFyaWFibGVzLCBwb2xpY2llcyA9IGNvbnRleHQucG9saWNpZXMsIHN0b3JlID0gY29udGV4dC5zdG9yZTtcbiAgICAgICAgdmFyIHR5cGVuYW1lID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShvYmplY3RPclJlZmVyZW5jZSwgXCJfX3R5cGVuYW1lXCIpO1xuICAgICAgICB2YXIgb2JqZWN0c1RvTWVyZ2UgPSBbXTtcbiAgICAgICAgdmFyIG1pc3Npbmc7XG4gICAgICAgIHZhciBtaXNzaW5nTWVyZ2VyID0gbmV3IHV0aWxpdGllcy5EZWVwTWVyZ2VyKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hZGRUeXBlbmFtZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHR5cGVuYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhcG9saWNpZXMucm9vdElkc0J5VHlwZW5hbWVbdHlwZW5hbWVdKSB7XG4gICAgICAgICAgICBvYmplY3RzVG9NZXJnZS5wdXNoKHsgX190eXBlbmFtZTogdHlwZW5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTWlzc2luZyhyZXN1bHQsIHJlc3VsdE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBtaXNzaW5nTWVyZ2VyLm1lcmdlKG1pc3NpbmcsIChfYSA9IHt9LCBfYVtyZXN1bHROYW1lXSA9IHJlc3VsdC5taXNzaW5nLCBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmtTZXQgPSBuZXcgU2V0KHNlbGVjdGlvblNldC5zZWxlY3Rpb25zKTtcbiAgICAgICAgd29ya1NldC5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIXV0aWxpdGllcy5zaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZFZhbHVlID0gcG9saWNpZXMucmVhZEZpZWxkKHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBzZWxlY3Rpb24ubmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb250ZXh0LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogb2JqZWN0T3JSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdE5hbWUgPSB1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsaXRpZXMuYWRkVHlwZW5hbWVUb0RvY3VtZW50LmFkZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBtaXNzaW5nTWVyZ2VyLm1lcmdlKG1pc3NpbmcsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hW3Jlc3VsdE5hbWVdID0gXCJDYW4ndCBmaW5kIGZpZWxkICdcIi5jb25jYXQoc2VsZWN0aW9uLm5hbWUudmFsdWUsIFwiJyBvbiBcIikuY29uY2F0KHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvYmplY3RPclJlZmVyZW5jZS5fX3JlZiArIFwiIG9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJvYmplY3QgXCIgKyBKU09OLnN0cmluZ2lmeShvYmplY3RPclJlZmVyZW5jZSwgbnVsbCwgMikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gaGFuZGxlTWlzc2luZyhfdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNsb3NpbmdSZWY6IGVuY2xvc2luZ1JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pLCByZXN1bHROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2Fub25pemVSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gX3RoaXMuY2Fub24ucGFzcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RPclJlZmVyZW5jZTogZmllbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY2xvc2luZ1JlZjogdXRpbGl0aWVzLmlzUmVmZXJlbmNlKGZpZWxkVmFsdWUpID8gZmllbGRWYWx1ZSA6IGVuY2xvc2luZ1JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pLCByZXN1bHROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RzVG9NZXJnZS5wdXNoKChfYiA9IHt9LCBfYltyZXN1bHROYW1lXSA9IGZpZWxkVmFsdWUsIF9iKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdXRpbGl0aWVzLmdldEZyYWdtZW50RnJvbVNlbGVjdGlvbihzZWxlY3Rpb24sIGNvbnRleHQuZnJhZ21lbnRNYXApO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAmJiBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMoZnJhZ21lbnQsIHR5cGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5mb3JFYWNoKHdvcmtTZXQuYWRkLCB3b3JrU2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbGl0aWVzLm1lcmdlRGVlcEFycmF5KG9iamVjdHNUb01lcmdlKTtcbiAgICAgICAgdmFyIGZpbmFsUmVzdWx0ID0geyByZXN1bHQ6IHJlc3VsdCwgbWlzc2luZzogbWlzc2luZyB9O1xuICAgICAgICB2YXIgZnJvemVuID0gY29udGV4dC5jYW5vbml6ZVJlc3VsdHNcbiAgICAgICAgICAgID8gdGhpcy5jYW5vbi5hZG1pdChmaW5hbFJlc3VsdClcbiAgICAgICAgICAgIDogdXRpbGl0aWVzLm1heWJlRGVlcEZyZWV6ZShmaW5hbFJlc3VsdCk7XG4gICAgICAgIGlmIChmcm96ZW4ucmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmtub3duUmVzdWx0cy5zZXQoZnJvemVuLnJlc3VsdCwgc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvemVuO1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWNTdWJTZWxlY3RlZEFycmF5SW1wbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgYXJyYXkgPSBfYS5hcnJheSwgZW5jbG9zaW5nUmVmID0gX2EuZW5jbG9zaW5nUmVmLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG1pc3Npbmc7XG4gICAgICAgIHZhciBtaXNzaW5nTWVyZ2VyID0gbmV3IHV0aWxpdGllcy5EZWVwTWVyZ2VyKCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmcoY2hpbGRSZXN1bHQsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmdNZXJnZXIubWVyZ2UobWlzc2luZywgKF9hID0ge30sIF9hW2ldID0gY2hpbGRSZXN1bHQubWlzc2luZywgX2EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheS5maWx0ZXIoY29udGV4dC5zdG9yZS5jYW5SZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheSA9IGFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBlbmNsb3NpbmdSZWY6IGVuY2xvc2luZ1JlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogZmllbGQuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RPclJlZmVyZW5jZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiB1dGlsaXRpZXMuaXNSZWZlcmVuY2UoaXRlbSkgPyBpdGVtIDogZW5jbG9zaW5nUmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShjb250ZXh0LnN0b3JlLCBmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGNvbnRleHQuY2Fub25pemVSZXN1bHRzID8gdGhpcy5jYW5vbi5hZG1pdChhcnJheSkgOiBhcnJheSxcbiAgICAgICAgICAgIG1pc3Npbmc6IG1pc3NpbmcsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVSZWFkZXI7XG59KCkpO1xuZnVuY3Rpb24gZmlyc3RNaXNzaW5nKHRyZWUpIHtcbiAgICB0cnkge1xuICAgICAgICBKU09OLnN0cmluZ2lmeSh0cmVlLCBmdW5jdGlvbiAoXywgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShzdG9yZSwgZmllbGQsIGZpZWxkVmFsdWUpIHtcbiAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICB2YXIgd29ya1NldF8xID0gbmV3IFNldChbZmllbGRWYWx1ZV0pO1xuICAgICAgICB3b3JrU2V0XzEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSwgXCJNaXNzaW5nIHNlbGVjdGlvbiBzZXQgZm9yIG9iamVjdCBvZiB0eXBlIFwiLmNvbmNhdChnZXRUeXBlbmFtZUZyb21TdG9yZU9iamVjdChzdG9yZSwgdmFsdWUpLCBcIiByZXR1cm5lZCBmb3IgcXVlcnkgZmllbGQgXCIpLmNvbmNhdChmaWVsZC5uYW1lLnZhbHVlKSkgOiBnbG9iYWxzLmludmFyaWFudCghdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSwgNSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh2YWx1ZSkuZm9yRWFjaCh3b3JrU2V0XzEuYWRkLCB3b3JrU2V0XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbnZhciBjYWNoZVNsb3QgPSBuZXcgY29udGV4dC5TbG90KCk7XG52YXIgY2FjaGVJbmZvTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlSW5mbyhjYWNoZSkge1xuICAgIHZhciBpbmZvID0gY2FjaGVJbmZvTWFwLmdldChjYWNoZSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNhY2hlSW5mb01hcC5zZXQoY2FjaGUsIGluZm8gPSB7XG4gICAgICAgICAgICB2YXJzOiBuZXcgU2V0LFxuICAgICAgICAgICAgZGVwOiBvcHRpbWlzbS5kZXAoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gZm9yZ2V0Q2FjaGUoY2FjaGUpIHtcbiAgICBnZXRDYWNoZUluZm8oY2FjaGUpLnZhcnMuZm9yRWFjaChmdW5jdGlvbiAocnYpIHsgcmV0dXJuIHJ2LmZvcmdldENhY2hlKGNhY2hlKTsgfSk7XG59XG5mdW5jdGlvbiByZWNhbGxDYWNoZShjYWNoZSkge1xuICAgIGdldENhY2hlSW5mbyhjYWNoZSkudmFycy5mb3JFYWNoKGZ1bmN0aW9uIChydikgeyByZXR1cm4gcnYuYXR0YWNoQ2FjaGUoY2FjaGUpOyB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VWYXIodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgY2FjaGVzLmZvckVhY2goZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldENhY2hlSW5mbyhjYWNoZSkuZGVwLmRpcnR5KHJ2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0KGNhY2hlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlU2xvdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoKGNhY2hlKTtcbiAgICAgICAgICAgICAgICBnZXRDYWNoZUluZm8oY2FjaGUpLmRlcChydik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcnYub25OZXh0Q2hhbmdlID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoID0gcnYuYXR0YWNoQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVzLmFkZChjYWNoZSk7XG4gICAgICAgIGdldENhY2hlSW5mbyhjYWNoZSkudmFycy5hZGQocnYpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfTtcbiAgICBydi5mb3JnZXRDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSkgeyByZXR1cm4gY2FjaGVzLmRlbGV0ZShjYWNoZSk7IH07XG4gICAgcmV0dXJuIHJ2O1xufVxuZnVuY3Rpb24gYnJvYWRjYXN0KGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlLmJyb2FkY2FzdFdhdGNoZXMpIHtcbiAgICAgICAgY2FjaGUuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgIH1cbn1cblxudmFyIHNwZWNpZmllckluZm9DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBsb29rdXBTcGVjaWZpZXJJbmZvKHNwZWMpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShzcGVjKTtcbiAgICByZXR1cm4gc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSB8fFxuICAgICAgICAoc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24ga2V5RmllbGRzRm5Gcm9tU3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIHZhciBpbmZvID0gbG9va3VwU3BlY2lmaWVySW5mbyhzcGVjaWZpZXIpO1xuICAgIHJldHVybiBpbmZvLmtleUZpZWxkc0ZuIHx8IChpbmZvLmtleUZpZWxkc0ZuID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFjdCA9IGZ1bmN0aW9uIChmcm9tLCBrZXkpIHsgcmV0dXJuIGNvbnRleHQucmVhZEZpZWxkKGtleSwgZnJvbSk7IH07XG4gICAgICAgIHZhciBrZXlPYmplY3QgPSBjb250ZXh0LmtleU9iamVjdCA9IGNvbGxlY3RTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIsIGZ1bmN0aW9uIChzY2hlbWFLZXlQYXRoKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkID0gZXh0cmFjdEtleVBhdGgoY29udGV4dC5zdG9yZU9iamVjdCwgc2NoZW1hS2V5UGF0aCwgZXh0cmFjdCk7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdGVkID09PSB2b2lkIDAgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QgIT09IGNvbnRleHQuc3RvcmVPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBoYXNPd24uY2FsbChvYmplY3QsIHNjaGVtYUtleVBhdGhbMF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkID0gZXh0cmFjdEtleVBhdGgob2JqZWN0LCBzY2hlbWFLZXlQYXRoLCBleHRyYWN0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChleHRyYWN0ZWQgIT09IHZvaWQgMCwgXCJNaXNzaW5nIGZpZWxkICdcIi5jb25jYXQoc2NoZW1hS2V5UGF0aC5qb2luKCcuJyksIFwiJyB3aGlsZSBleHRyYWN0aW5nIGtleUZpZWxkcyBmcm9tIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSkpIDogZ2xvYmFscy5pbnZhcmlhbnQoZXh0cmFjdGVkICE9PSB2b2lkIDAsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjb250ZXh0LnR5cGVuYW1lLCBcIjpcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleU9iamVjdCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24ga2V5QXJnc0ZuRnJvbVNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICB2YXIgaW5mbyA9IGxvb2t1cFNwZWNpZmllckluZm8oc3BlY2lmaWVyKTtcbiAgICByZXR1cm4gaW5mby5rZXlBcmdzRm4gfHwgKGluZm8ua2V5QXJnc0ZuID0gZnVuY3Rpb24gKGFyZ3MsIF9hKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGZpZWxkTmFtZSA9IF9hLmZpZWxkTmFtZTtcbiAgICAgICAgdmFyIGNvbGxlY3RlZCA9IGNvbGxlY3RTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIsIGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RLZXkgPSBrZXlQYXRoWzBdO1xuICAgICAgICAgICAgdmFyIGZpcnN0Q2hhciA9IGZpcnN0S2V5LmNoYXJBdCgwKTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZmllbGQuZGlyZWN0aXZlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5hbWVfMSA9IGZpcnN0S2V5LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGZpZWxkLmRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnZhbHVlID09PSBkaXJlY3RpdmVOYW1lXzE7IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlQXJncyA9IGQgJiYgdXRpbGl0aWVzLmFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXJncyAmJiBleHRyYWN0S2V5UGF0aChkaXJlY3RpdmVBcmdzLCBrZXlQYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gZmlyc3RLZXkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcyAmJiBoYXNPd24uY2FsbCh2YXJpYWJsZXMsIHZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcktleVBhdGggPSBrZXlQYXRoLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICB2YXJLZXlQYXRoWzBdID0gdmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdEtleVBhdGgodmFyaWFibGVzLCB2YXJLZXlQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdEtleVBhdGgoYXJncywga2V5UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VmZml4ID0gSlNPTi5zdHJpbmdpZnkoY29sbGVjdGVkKTtcbiAgICAgICAgaWYgKGFyZ3MgfHwgc3VmZml4ICE9PSBcInt9XCIpIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSArPSBcIjpcIiArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29sbGVjdFNwZWNpZmllclBhdGhzKHNwZWNpZmllciwgZXh0cmFjdG9yKSB7XG4gICAgdmFyIG1lcmdlciA9IG5ldyB1dGlsaXRpZXMuRGVlcE1lcmdlcjtcbiAgICByZXR1cm4gZ2V0U3BlY2lmaWVyUGF0aHMoc3BlY2lmaWVyKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbGxlY3RlZCwgcGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB0b01lcmdlID0gZXh0cmFjdG9yKHBhdGgpO1xuICAgICAgICBpZiAodG9NZXJnZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHRvTWVyZ2UgPSAoX2EgPSB7fSwgX2FbcGF0aFtpXV0gPSB0b01lcmdlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0ZWQgPSBtZXJnZXIubWVyZ2UoY29sbGVjdGVkLCB0b01lcmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lmaWVyUGF0aHMoc3BlYykge1xuICAgIHZhciBpbmZvID0gbG9va3VwU3BlY2lmaWVySW5mbyhzcGVjKTtcbiAgICBpZiAoIWluZm8ucGF0aHMpIHtcbiAgICAgICAgdmFyIHBhdGhzXzEgPSBpbmZvLnBhdGhzID0gW107XG4gICAgICAgIHZhciBjdXJyZW50UGF0aF8xID0gW107XG4gICAgICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkocykpIHtcbiAgICAgICAgICAgICAgICBnZXRTcGVjaWZpZXJQYXRocyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5jb25jYXQocCkpOyB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHNwZWNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoXzEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5mby5wYXRocztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5mdW5jdGlvbiBleHRyYWN0S2V5UGF0aChvYmplY3QsIHBhdGgsIGV4dHJhY3QpIHtcbiAgICBleHRyYWN0ID0gZXh0cmFjdCB8fCBleHRyYWN0S2V5O1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aC5yZWR1Y2UoZnVuY3Rpb24gcmVkdWNlcihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopXG4gICAgICAgICAgICA/IG9iai5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiByZWR1Y2VyKGNoaWxkLCBrZXkpOyB9KVxuICAgICAgICAgICAgOiBvYmogJiYgZXh0cmFjdChvYmosIGtleSk7XG4gICAgfSwgb2JqZWN0KSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodmFsdWUpIHtcbiAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKG5vcm1hbGl6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3RTcGVjaWZpZXJQYXRocyhPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLCBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gZXh0cmFjdEtleVBhdGgodmFsdWUsIHBhdGgpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG51dGlsaXRpZXMuZ2V0U3RvcmVLZXlOYW1lLnNldFN0cmluZ2lmeShjYW5vbmljYWxTdHJpbmdpZnkpO1xuZnVuY3Rpb24gYXJnc0Zyb21GaWVsZFNwZWNpZmllcihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMuYXJncyAhPT0gdm9pZCAwID8gc3BlYy5hcmdzIDpcbiAgICAgICAgc3BlYy5maWVsZCA/IHV0aWxpdGllcy5hcmd1bWVudHNPYmplY3RGcm9tRmllbGQoc3BlYy5maWVsZCwgc3BlYy52YXJpYWJsZXMpIDogbnVsbDtcbn1cbnZhciBudWxsS2V5RmllbGRzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2b2lkIDA7IH07XG52YXIgc2ltcGxlS2V5QXJnc0ZuID0gZnVuY3Rpb24gKF9hcmdzLCBjb250ZXh0KSB7IHJldHVybiBjb250ZXh0LmZpZWxkTmFtZTsgfTtcbnZhciBtZXJnZVRydWVGbiA9IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcsIF9hKSB7XG4gICAgdmFyIG1lcmdlT2JqZWN0cyA9IF9hLm1lcmdlT2JqZWN0cztcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGV4aXN0aW5nLCBpbmNvbWluZyk7XG59O1xudmFyIG1lcmdlRmFsc2VGbiA9IGZ1bmN0aW9uIChfLCBpbmNvbWluZykgeyByZXR1cm4gaW5jb21pbmc7IH07XG52YXIgUG9saWNpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbGljaWVzKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy50eXBlUG9saWNpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRvQmVBZGRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuc3VwZXJ0eXBlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZ1enp5U3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucm9vdElkc0J5VHlwZW5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy51c2luZ1Bvc3NpYmxlVHlwZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB0c2xpYi5fX2Fzc2lnbih7IGRhdGFJZEZyb21PYmplY3Q6IGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0IH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNvbmZpZy5jYWNoZTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJRdWVyeVwiKTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJNdXRhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJTdWJzY3JpcHRpb25cIik7XG4gICAgICAgIGlmIChjb25maWcucG9zc2libGVUeXBlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRQb3NzaWJsZVR5cGVzKGNvbmZpZy5wb3NzaWJsZVR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnR5cGVQb2xpY2llcykge1xuICAgICAgICAgICAgdGhpcy5hZGRUeXBlUG9saWNpZXMoY29uZmlnLnR5cGVQb2xpY2llcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG9iamVjdCwgcGFydGlhbENvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSBwYXJ0aWFsQ29udGV4dCAmJiAocGFydGlhbENvbnRleHQudHlwZW5hbWUgfHxcbiAgICAgICAgICAgICgoX2EgPSBwYXJ0aWFsQ29udGV4dC5zdG9yZU9iamVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fdHlwZW5hbWUpKSB8fCBvYmplY3QuX190eXBlbmFtZTtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkLlJPT1RfUVVFUlkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXCJST09UX1FVRVJZXCJdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9yZU9iamVjdCA9IHBhcnRpYWxDb250ZXh0ICYmIHBhcnRpYWxDb250ZXh0LnN0b3JlT2JqZWN0IHx8IG9iamVjdDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcGFydGlhbENvbnRleHQpLCB7IHR5cGVuYW1lOiB0eXBlbmFtZSwgc3RvcmVPYmplY3Q6IHN0b3JlT2JqZWN0LCByZWFkRmllbGQ6IHBhcnRpYWxDb250ZXh0ICYmIHBhcnRpYWxDb250ZXh0LnJlYWRGaWVsZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKGFyZ3VtZW50cywgc3RvcmVPYmplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogcG9saWNpZXMuY2FjaGVbXCJkYXRhXCJdLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgcG9saWN5ID0gdHlwZW5hbWUgJiYgdGhpcy5nZXRUeXBlUG9saWN5KHR5cGVuYW1lKTtcbiAgICAgICAgdmFyIGtleUZuID0gcG9saWN5ICYmIHBvbGljeS5rZXlGbiB8fCB0aGlzLmNvbmZpZy5kYXRhSWRGcm9tT2JqZWN0O1xuICAgICAgICB3aGlsZSAoa2V5Rm4pIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWZpZXJPcklkID0ga2V5Rm4ob2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHNwZWNpZmllck9ySWQpKSB7XG4gICAgICAgICAgICAgICAga2V5Rm4gPSBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoc3BlY2lmaWVyT3JJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IHNwZWNpZmllck9ySWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBpZCA/IFN0cmluZyhpZCkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmtleU9iamVjdCA/IFtpZCwgY29udGV4dC5rZXlPYmplY3RdIDogW2lkXTtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5hZGRUeXBlUG9saWNpZXMgPSBmdW5jdGlvbiAodHlwZVBvbGljaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVQb2xpY2llcykuZm9yRWFjaChmdW5jdGlvbiAodHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHR5cGVQb2xpY2llc1t0eXBlbmFtZV0sIHF1ZXJ5VHlwZSA9IF9hLnF1ZXJ5VHlwZSwgbXV0YXRpb25UeXBlID0gX2EubXV0YXRpb25UeXBlLCBzdWJzY3JpcHRpb25UeXBlID0gX2Euc3Vic2NyaXB0aW9uVHlwZSwgaW5jb21pbmcgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInF1ZXJ5VHlwZVwiLCBcIm11dGF0aW9uVHlwZVwiLCBcInN1YnNjcmlwdGlvblR5cGVcIl0pO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5VHlwZSlcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRSb290VHlwZW5hbWUoXCJRdWVyeVwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIk11dGF0aW9uXCIsIHR5cGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIlN1YnNjcmlwdGlvblwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoX3RoaXMudG9CZUFkZGVkLCB0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b0JlQWRkZWRbdHlwZW5hbWVdLnB1c2goaW5jb21pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudG9CZUFkZGVkW3R5cGVuYW1lXSA9IFtpbmNvbWluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnVwZGF0ZVR5cGVQb2xpY3kgPSBmdW5jdGlvbiAodHlwZW5hbWUsIGluY29taW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0VHlwZVBvbGljeSh0eXBlbmFtZSk7XG4gICAgICAgIHZhciBrZXlGaWVsZHMgPSBpbmNvbWluZy5rZXlGaWVsZHMsIGZpZWxkcyA9IGluY29taW5nLmZpZWxkcztcbiAgICAgICAgZnVuY3Rpb24gc2V0TWVyZ2UoZXhpc3RpbmcsIG1lcmdlKSB7XG4gICAgICAgICAgICBleGlzdGluZy5tZXJnZSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG1lcmdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXJnZSA6XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlID09PSB0cnVlID8gbWVyZ2VUcnVlRm4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPT09IGZhbHNlID8gbWVyZ2VGYWxzZUZuIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5tZXJnZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRNZXJnZShleGlzdGluZywgaW5jb21pbmcubWVyZ2UpO1xuICAgICAgICBleGlzdGluZy5rZXlGbiA9XG4gICAgICAgICAgICBrZXlGaWVsZHMgPT09IGZhbHNlID8gbnVsbEtleUZpZWxkc0ZuIDpcbiAgICAgICAgICAgICAgICBpc0FycmF5KGtleUZpZWxkcykgPyBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoa2V5RmllbGRzKSA6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBrZXlGaWVsZHMgPT09IFwiZnVuY3Rpb25cIiA/IGtleUZpZWxkcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5rZXlGbjtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBfdGhpcy5nZXRGaWVsZFBvbGljeSh0eXBlbmFtZSwgZmllbGROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jb21pbmcgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluY29taW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucmVhZCA9IGluY29taW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFyZ3MgPSBpbmNvbWluZy5rZXlBcmdzLCByZWFkID0gaW5jb21pbmcucmVhZCwgbWVyZ2UgPSBpbmNvbWluZy5tZXJnZTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5QXJncyA9PT0gZmFsc2UgPyBzaW1wbGVLZXlBcmdzRm4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoa2V5QXJncykgPyBrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyKGtleUFyZ3MpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGtleUFyZ3MgPT09IFwiZnVuY3Rpb25cIiA/IGtleUFyZ3MgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZWFkID0gcmVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRNZXJnZShleGlzdGluZywgbWVyZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcucmVhZCAmJiBleGlzdGluZy5tZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5rZXlGbiA9IGV4aXN0aW5nLmtleUZuIHx8IHNpbXBsZUtleUFyZ3NGbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnNldFJvb3RUeXBlbmFtZSA9IGZ1bmN0aW9uICh3aGljaCwgdHlwZW5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB2b2lkIDApIHsgdHlwZW5hbWUgPSB3aGljaDsgfVxuICAgICAgICB2YXIgcm9vdElkID0gXCJST09UX1wiICsgd2hpY2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMucm9vdFR5cGVuYW1lc0J5SWRbcm9vdElkXTtcbiAgICAgICAgaWYgKHR5cGVuYW1lICE9PSBvbGQpIHtcbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghb2xkIHx8IG9sZCA9PT0gd2hpY2gsIFwiQ2Fubm90IGNoYW5nZSByb290IFwiLmNvbmNhdCh3aGljaCwgXCIgX190eXBlbmFtZSBtb3JlIHRoYW4gb25jZVwiKSkgOiBnbG9iYWxzLmludmFyaWFudCghb2xkIHx8IG9sZCA9PT0gd2hpY2gsIDMpO1xuICAgICAgICAgICAgaWYgKG9sZClcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yb290SWRzQnlUeXBlbmFtZVtvbGRdO1xuICAgICAgICAgICAgdGhpcy5yb290SWRzQnlUeXBlbmFtZVt0eXBlbmFtZV0gPSByb290SWQ7XG4gICAgICAgICAgICB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkW3Jvb3RJZF0gPSB0eXBlbmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmFkZFBvc3NpYmxlVHlwZXMgPSBmdW5jdGlvbiAocG9zc2libGVUeXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVzaW5nUG9zc2libGVUeXBlcyA9IHRydWU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBvc3NpYmxlVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHN1cGVydHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuZ2V0U3VwZXJ0eXBlU2V0KHN1cGVydHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzW3N1cGVydHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoc3VidHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldFN1cGVydHlwZVNldChzdWJ0eXBlLCB0cnVlKS5hZGQoc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdWJ0eXBlLm1hdGNoKFR5cGVPckZpZWxkTmFtZVJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXSAhPT0gc3VidHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mdXp6eVN1YnR5cGVzLnNldChzdWJ0eXBlLCBuZXcgUmVnRXhwKHN1YnR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuZ2V0VHlwZVBvbGljeSA9IGZ1bmN0aW9uICh0eXBlbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRoaXMudHlwZVBvbGljaWVzLCB0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBwb2xpY3lfMSA9IHRoaXMudHlwZVBvbGljaWVzW3R5cGVuYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBwb2xpY3lfMS5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIHN1cGVydHlwZXMgPSB0aGlzLnN1cGVydHlwZU1hcC5nZXQodHlwZW5hbWUpO1xuICAgICAgICAgICAgaWYgKHN1cGVydHlwZXMgJiYgc3VwZXJ0eXBlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJ0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdXBlcnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZ2V0VHlwZVBvbGljeShzdXBlcnR5cGUpLCBmaWVsZHMgPSBfYS5maWVsZHMsIHJlc3QgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImZpZWxkc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocG9saWN5XzEsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBvbGljeV8xLmZpZWxkcywgZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5ib3ggPSB0aGlzLnRvQmVBZGRlZFt0eXBlbmFtZV07XG4gICAgICAgIGlmIChpbmJveCAmJiBpbmJveC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluYm94LnNwbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChwb2xpY3kpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUeXBlUG9saWN5KHR5cGVuYW1lLCBwb2xpY3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZVBvbGljaWVzW3R5cGVuYW1lXTtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRGaWVsZFBvbGljeSA9IGZ1bmN0aW9uICh0eXBlbmFtZSwgZmllbGROYW1lLCBjcmVhdGVJZk1pc3NpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRQb2xpY2llcyA9IHRoaXMuZ2V0VHlwZVBvbGljeSh0eXBlbmFtZSkuZmllbGRzO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkUG9saWNpZXNbZmllbGROYW1lXSB8fCAoY3JlYXRlSWZNaXNzaW5nICYmIChmaWVsZFBvbGljaWVzW2ZpZWxkTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRTdXBlcnR5cGVTZXQgPSBmdW5jdGlvbiAoc3VidHlwZSwgY3JlYXRlSWZNaXNzaW5nKSB7XG4gICAgICAgIHZhciBzdXBlcnR5cGVTZXQgPSB0aGlzLnN1cGVydHlwZU1hcC5nZXQoc3VidHlwZSk7XG4gICAgICAgIGlmICghc3VwZXJ0eXBlU2V0ICYmIGNyZWF0ZUlmTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5zdXBlcnR5cGVNYXAuc2V0KHN1YnR5cGUsIHN1cGVydHlwZVNldCA9IG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVydHlwZVNldDtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5mcmFnbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAoZnJhZ21lbnQsIHR5cGVuYW1lLCByZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWZyYWdtZW50LnR5cGVDb25kaXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0eXBlbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHN1cGVydHlwZSA9IGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSBzdXBlcnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNpbmdQb3NzaWJsZVR5cGVzICYmXG4gICAgICAgICAgICB0aGlzLnN1cGVydHlwZU1hcC5oYXMoc3VwZXJ0eXBlKSkge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lU3VwZXJ0eXBlU2V0ID0gdGhpcy5nZXRTdXBlcnR5cGVTZXQodHlwZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHdvcmtRdWV1ZV8xID0gW3R5cGVuYW1lU3VwZXJ0eXBlU2V0XTtcbiAgICAgICAgICAgIHZhciBtYXliZUVucXVldWVfMSA9IGZ1bmN0aW9uIChzdWJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVydHlwZVNldCA9IF90aGlzLmdldFN1cGVydHlwZVNldChzdWJ0eXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1cGVydHlwZVNldCAmJlxuICAgICAgICAgICAgICAgICAgICBzdXBlcnR5cGVTZXQuc2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrUXVldWVfMS5pbmRleE9mKHN1cGVydHlwZVNldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtRdWV1ZV8xLnB1c2goc3VwZXJ0eXBlU2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyA9ICEhKHJlc3VsdCAmJiB0aGlzLmZ1enp5U3VidHlwZXMuc2l6ZSk7XG4gICAgICAgICAgICB2YXIgY2hlY2tpbmdGdXp6eVN1YnR5cGVzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtRdWV1ZV8xLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVydHlwZVNldCA9IHdvcmtRdWV1ZV8xW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdXBlcnR5cGVTZXQuaGFzKHN1cGVydHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlbmFtZVN1cGVydHlwZVNldC5oYXMoc3VwZXJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNraW5nRnV6enlTdWJ0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkluZmVycmluZyBzdWJ0eXBlIFwiLmNvbmNhdCh0eXBlbmFtZSwgXCIgb2Ygc3VwZXJ0eXBlIFwiKS5jb25jYXQoc3VwZXJ0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlbmFtZVN1cGVydHlwZVNldC5hZGQoc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VwZXJ0eXBlU2V0LmZvckVhY2gobWF5YmVFbnF1ZXVlXzEpO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkVG9DaGVja0Z1enp5U3VidHlwZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA9PT0gd29ya1F1ZXVlXzEubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXRNYXRjaGVzUmVzdWx0KGZyYWdtZW50LnNlbGVjdGlvblNldCwgcmVzdWx0LCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2luZ0Z1enp5U3VidHlwZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1enp5U3VidHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnRXhwLCBmdXp6eVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHlwZW5hbWUubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXSA9PT0gdHlwZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZUVucXVldWVfMShmdXp6eVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuaGFzS2V5QXJncyA9IGZ1bmN0aW9uICh0eXBlbmFtZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICEhKHBvbGljeSAmJiBwb2xpY3kua2V5Rm4pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmdldFN0b3JlRmllbGROYW1lID0gZnVuY3Rpb24gKGZpZWxkU3BlYykge1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSBmaWVsZFNwZWMudHlwZW5hbWUsIGZpZWxkTmFtZSA9IGZpZWxkU3BlYy5maWVsZE5hbWU7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lO1xuICAgICAgICB2YXIga2V5Rm4gPSBwb2xpY3kgJiYgcG9saWN5LmtleUZuO1xuICAgICAgICBpZiAoa2V5Rm4gJiYgdHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lOiB0eXBlbmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRTcGVjLmZpZWxkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBmaWVsZFNwZWMudmFyaWFibGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpO1xuICAgICAgICAgICAgd2hpbGUgKGtleUZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpZmllck9yU3RyaW5nID0ga2V5Rm4oYXJncywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3BlY2lmaWVyT3JTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUZuID0ga2V5QXJnc0ZuRnJvbVNwZWNpZmllcihzcGVjaWZpZXJPclN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZUZpZWxkTmFtZSA9IHNwZWNpZmllck9yU3RyaW5nIHx8IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUZpZWxkTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdG9yZUZpZWxkTmFtZSA9IGZpZWxkU3BlYy5maWVsZFxuICAgICAgICAgICAgICAgID8gdXRpbGl0aWVzLnN0b3JlS2V5TmFtZUZyb21GaWVsZChmaWVsZFNwZWMuZmllbGQsIGZpZWxkU3BlYy52YXJpYWJsZXMpXG4gICAgICAgICAgICAgICAgOiB1dGlsaXRpZXMuZ2V0U3RvcmVLZXlOYW1lKGZpZWxkTmFtZSwgYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVGaWVsZE5hbWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZE5hbWUgPT09IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpXG4gICAgICAgICAgICA/IHN0b3JlRmllbGROYW1lXG4gICAgICAgICAgICA6IGZpZWxkTmFtZSArIFwiOlwiICsgc3RvcmVGaWVsZE5hbWU7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUucmVhZEZpZWxkID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG9iamVjdE9yUmVmZXJlbmNlID0gb3B0aW9ucy5mcm9tO1xuICAgICAgICBpZiAoIW9iamVjdE9yUmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZU9yRmllbGQgPSBvcHRpb25zLmZpZWxkIHx8IG9wdGlvbnMuZmllbGROYW1lO1xuICAgICAgICBpZiAoIW5hbWVPckZpZWxkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWUgPSBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUob2JqZWN0T3JSZWZlcmVuY2UsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlbmFtZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGVuYW1lID0gdHlwZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lID0gdGhpcy5nZXRTdG9yZUZpZWxkTmFtZShvcHRpb25zKTtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUob2JqZWN0T3JSZWZlcmVuY2UsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgdmFyIHBvbGljeSA9IHRoaXMuZ2V0RmllbGRQb2xpY3kob3B0aW9ucy50eXBlbmFtZSwgZmllbGROYW1lLCBmYWxzZSk7XG4gICAgICAgIHZhciByZWFkID0gcG9saWN5ICYmIHBvbGljeS5yZWFkO1xuICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgICAgdmFyIHJlYWRPcHRpb25zID0gbWFrZUZpZWxkRnVuY3Rpb25PcHRpb25zKHRoaXMsIG9iamVjdE9yUmVmZXJlbmNlLCBvcHRpb25zLCBjb250ZXh0LCBjb250ZXh0LnN0b3JlLmdldFN0b3JhZ2UodXRpbGl0aWVzLmlzUmVmZXJlbmNlKG9iamVjdE9yUmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0T3JSZWZlcmVuY2UuX19yZWZcbiAgICAgICAgICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlU2xvdC53aXRoVmFsdWUodGhpcy5jYWNoZSwgcmVhZCwgW2V4aXN0aW5nLCByZWFkT3B0aW9uc10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRSZWFkRnVuY3Rpb24gPSBmdW5jdGlvbiAodHlwZW5hbWUsIGZpZWxkTmFtZSkge1xuICAgICAgICB2YXIgcG9saWN5ID0gdGhpcy5nZXRGaWVsZFBvbGljeSh0eXBlbmFtZSwgZmllbGROYW1lLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBwb2xpY3kgJiYgcG9saWN5LnJlYWQ7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuZ2V0TWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChwYXJlbnRUeXBlbmFtZSwgZmllbGROYW1lLCBjaGlsZFR5cGVuYW1lKSB7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHBhcmVudFR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdmFyIG1lcmdlID0gcG9saWN5ICYmIHBvbGljeS5tZXJnZTtcbiAgICAgICAgaWYgKCFtZXJnZSAmJiBjaGlsZFR5cGVuYW1lKSB7XG4gICAgICAgICAgICBwb2xpY3kgPSB0aGlzLmdldFR5cGVQb2xpY3koY2hpbGRUeXBlbmFtZSk7XG4gICAgICAgICAgICBtZXJnZSA9IHBvbGljeSAmJiBwb2xpY3kubWVyZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnJ1bk1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nLCBfYSwgY29udGV4dCwgc3RvcmFnZSkge1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgdHlwZW5hbWUgPSBfYS50eXBlbmFtZSwgbWVyZ2UgPSBfYS5tZXJnZTtcbiAgICAgICAgaWYgKG1lcmdlID09PSBtZXJnZVRydWVGbikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VNZXJnZU9iamVjdHNGdW5jdGlvbihjb250ZXh0LnN0b3JlKShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZSA9PT0gbWVyZ2VGYWxzZUZuKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQub3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBleGlzdGluZyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLCBtYWtlRmllbGRGdW5jdGlvbk9wdGlvbnModGhpcywgdm9pZCAwLCB7IHR5cGVuYW1lOiB0eXBlbmFtZSwgZmllbGROYW1lOiBmaWVsZC5uYW1lLnZhbHVlLCBmaWVsZDogZmllbGQsIHZhcmlhYmxlczogY29udGV4dC52YXJpYWJsZXMgfSwgY29udGV4dCwgc3RvcmFnZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9saWNpZXM7XG59KCkpO1xuZnVuY3Rpb24gbWFrZUZpZWxkRnVuY3Rpb25PcHRpb25zKHBvbGljaWVzLCBvYmplY3RPclJlZmVyZW5jZSwgZmllbGRTcGVjLCBjb250ZXh0LCBzdG9yYWdlKSB7XG4gICAgdmFyIHN0b3JlRmllbGROYW1lID0gcG9saWNpZXMuZ2V0U3RvcmVGaWVsZE5hbWUoZmllbGRTcGVjKTtcbiAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgdmFyIHZhcmlhYmxlcyA9IGZpZWxkU3BlYy52YXJpYWJsZXMgfHwgY29udGV4dC52YXJpYWJsZXM7XG4gICAgdmFyIF9hID0gY29udGV4dC5zdG9yZSwgdG9SZWZlcmVuY2UgPSBfYS50b1JlZmVyZW5jZSwgY2FuUmVhZCA9IF9hLmNhblJlYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJnczogYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpLFxuICAgICAgICBmaWVsZDogZmllbGRTcGVjLmZpZWxkIHx8IG51bGwsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICBzdG9yZUZpZWxkTmFtZTogc3RvcmVGaWVsZE5hbWUsXG4gICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICBpc1JlZmVyZW5jZTogdXRpbGl0aWVzLmlzUmVmZXJlbmNlLFxuICAgICAgICB0b1JlZmVyZW5jZTogdG9SZWZlcmVuY2UsXG4gICAgICAgIHN0b3JhZ2U6IHN0b3JhZ2UsXG4gICAgICAgIGNhY2hlOiBwb2xpY2llcy5jYWNoZSxcbiAgICAgICAgY2FuUmVhZDogY2FuUmVhZCxcbiAgICAgICAgcmVhZEZpZWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9saWNpZXMucmVhZEZpZWxkKG5vcm1hbGl6ZVJlYWRGaWVsZE9wdGlvbnMoYXJndW1lbnRzLCBvYmplY3RPclJlZmVyZW5jZSwgdmFyaWFibGVzKSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlT2JqZWN0czogbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKGNvbnRleHQuc3RvcmUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKHJlYWRGaWVsZEFyZ3MsIG9iamVjdE9yUmVmZXJlbmNlLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZmllbGROYW1lT3JPcHRpb25zID0gcmVhZEZpZWxkQXJnc1swXSwgZnJvbSA9IHJlYWRGaWVsZEFyZ3NbMV0sIGFyZ2MgPSByZWFkRmllbGRBcmdzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZpZWxkTmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWVPck9wdGlvbnMsXG4gICAgICAgICAgICBmcm9tOiBhcmdjID4gMSA/IGZyb20gOiBvYmplY3RPclJlZmVyZW5jZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgZmllbGROYW1lT3JPcHRpb25zKTtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbChvcHRpb25zLCBcImZyb21cIikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZnJvbSA9IG9iamVjdE9yUmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfX0RFVl9fICYmIG9wdGlvbnMuZnJvbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIlVuZGVmaW5lZCAnZnJvbScgcGFzc2VkIHRvIHJlYWRGaWVsZCB3aXRoIGFyZ3VtZW50cyBcIi5jb25jYXQodXRpbGl0aWVzLnN0cmluZ2lmeUZvckRpc3BsYXkoQXJyYXkuZnJvbShyZWFkRmllbGRBcmdzKSkpKTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCA9PT0gb3B0aW9ucy52YXJpYWJsZXMpIHtcbiAgICAgICAgb3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKHN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZXhpc3RpbmcpIHx8IGlzQXJyYXkoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJDYW5ub3QgYXV0b21hdGljYWxseSBtZXJnZSBhcnJheXNcIikgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdChleGlzdGluZykgJiZcbiAgICAgICAgICAgIHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB2YXIgZVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGV4aXN0aW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgaVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGluY29taW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgdHlwZXNEaWZmZXIgPSBlVHlwZSAmJiBpVHlwZSAmJiBlVHlwZSAhPT0gaVR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZXNEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKGV4aXN0aW5nKSAmJlxuICAgICAgICAgICAgICAgIHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGluY29taW5nKSkge1xuICAgICAgICAgICAgICAgIHN0b3JlLm1lcmdlKGV4aXN0aW5nLl9fcmVmLCBpbmNvbWluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGV4aXN0aW5nKSAmJlxuICAgICAgICAgICAgICAgIHV0aWxpdGllcy5pc1JlZmVyZW5jZShpbmNvbWluZykpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5tZXJnZShleGlzdGluZywgaW5jb21pbmcuX19yZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChleGlzdGluZykgJiZcbiAgICAgICAgICAgICAgICBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChpbmNvbWluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV4aXN0aW5nKSwgaW5jb21pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rmxhdm9yKGNvbnRleHQsIGNsaWVudE9ubHksIGRlZmVycmVkKSB7XG4gICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGNsaWVudE9ubHkpLmNvbmNhdChkZWZlcnJlZCk7XG4gICAgdmFyIGZsYXZvcmVkID0gY29udGV4dC5mbGF2b3JzLmdldChrZXkpO1xuICAgIGlmICghZmxhdm9yZWQpIHtcbiAgICAgICAgY29udGV4dC5mbGF2b3JzLnNldChrZXksIGZsYXZvcmVkID0gKGNvbnRleHQuY2xpZW50T25seSA9PT0gY2xpZW50T25seSAmJlxuICAgICAgICAgICAgY29udGV4dC5kZWZlcnJlZCA9PT0gZGVmZXJyZWQpID8gY29udGV4dCA6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBjbGllbnRPbmx5OiBjbGllbnRPbmx5LCBkZWZlcnJlZDogZGVmZXJyZWQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxhdm9yZWQ7XG59XG52YXIgU3RvcmVXcml0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlV3JpdGVyKGNhY2hlLCByZWFkZXIpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICB9XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlVG9TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSwgX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHJlc3VsdCA9IF9hLnJlc3VsdCwgZGF0YUlkID0gX2EuZGF0YUlkLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIG92ZXJ3cml0ZSA9IF9hLm92ZXJ3cml0ZTtcbiAgICAgICAgdmFyIG9wZXJhdGlvbkRlZmluaXRpb24gPSB1dGlsaXRpZXMuZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHZhciBtZXJnZXIgPSBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCk7XG4gICAgICAgIHZhcmlhYmxlcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB1dGlsaXRpZXMuZ2V0RGVmYXVsdFZhbHVlcyhvcGVyYXRpb25EZWZpbml0aW9uKSksIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgd3JpdHRlbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlci5tZXJnZShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgdmFyU3RyaW5nOiBjYW5vbmljYWxTdHJpbmdpZnkodmFyaWFibGVzKSxcbiAgICAgICAgICAgIGZyYWdtZW50TWFwOiB1dGlsaXRpZXMuY3JlYXRlRnJhZ21lbnRNYXAodXRpbGl0aWVzLmdldEZyYWdtZW50RGVmaW5pdGlvbnMocXVlcnkpKSxcbiAgICAgICAgICAgIG92ZXJ3cml0ZTogISFvdmVyd3JpdGUsXG4gICAgICAgICAgICBpbmNvbWluZ0J5SWQ6IG5ldyBNYXAsXG4gICAgICAgICAgICBjbGllbnRPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGRlZmVycmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZsYXZvcnM6IG5ldyBNYXAsXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnByb2Nlc3NTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBvcGVyYXRpb25EZWZpbml0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG1lcmdlVHJlZTogeyBtYXA6IG5ldyBNYXAgfSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXV0aWxpdGllcy5pc1JlZmVyZW5jZShyZWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJDb3VsZCBub3QgaWRlbnRpZnkgb2JqZWN0IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShyZXN1bHQpKSkgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig2KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmluY29taW5nQnlJZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgZGF0YUlkKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSBfYS5zdG9yZU9iamVjdCwgbWVyZ2VUcmVlID0gX2EubWVyZ2VUcmVlLCBmaWVsZE5vZGVTZXQgPSBfYS5maWVsZE5vZGVTZXQ7XG4gICAgICAgICAgICB2YXIgZW50aXR5UmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoZGF0YUlkKTtcbiAgICAgICAgICAgIGlmIChtZXJnZVRyZWUgJiYgbWVyZ2VUcmVlLm1hcC5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGxpZWQgPSBfdGhpcy5hcHBseU1lcmdlcyhtZXJnZVRyZWUsIGVudGl0eVJlZiwgc3RvcmVPYmplY3QsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2UoYXBwbGllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9yZU9iamVjdCA9IGFwcGxpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19ERVZfXyAmJiAhY29udGV4dC5vdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzV2l0aFNlbGVjdGlvblNldHNfMSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgZmllbGROb2RlU2V0LmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1dpdGhTZWxlY3Rpb25TZXRzXzFbZmllbGQubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NlbGVjdGlvblNldF8xID0gZnVuY3Rpb24gKHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZHNXaXRoU2VsZWN0aW9uU2V0c18xW2ZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpXSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBoYXNNZXJnZUZ1bmN0aW9uXzEgPSBmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IG1lcmdlVHJlZSAmJiBtZXJnZVRyZWUubWFwLmdldChzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGNoaWxkVHJlZSAmJiBjaGlsZFRyZWUuaW5mbyAmJiBjaGlsZFRyZWUuaW5mby5tZXJnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NlbGVjdGlvblNldF8xKHN0b3JlRmllbGROYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWhhc01lcmdlRnVuY3Rpb25fMShzdG9yZUZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5BYm91dERhdGFMb3NzKGVudGl0eVJlZiwgc3RvcmVPYmplY3QsIHN0b3JlRmllbGROYW1lLCBjb250ZXh0LnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUubWVyZ2UoZGF0YUlkLCBzdG9yZU9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9yZS5yZXRhaW4ocmVmLl9fcmVmKTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzU2VsZWN0aW9uU2V0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhSWQgPSBfYS5kYXRhSWQsIHJlc3VsdCA9IF9hLnJlc3VsdCwgc2VsZWN0aW9uU2V0ID0gX2Euc2VsZWN0aW9uU2V0LCBjb250ZXh0ID0gX2EuY29udGV4dCwgbWVyZ2VUcmVlID0gX2EubWVyZ2VUcmVlO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNhY2hlLnBvbGljaWVzO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSAoZGF0YUlkICYmIHBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0pIHx8XG4gICAgICAgICAgICB1dGlsaXRpZXMuZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0LmZyYWdtZW50TWFwKSB8fFxuICAgICAgICAgICAgKGRhdGFJZCAmJiBjb250ZXh0LnN0b3JlLmdldChkYXRhSWQsIFwiX190eXBlbmFtZVwiKSk7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZW5hbWUpIHtcbiAgICAgICAgICAgIGluY29taW5nLl9fdHlwZW5hbWUgPSB0eXBlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKGFyZ3VtZW50cywgaW5jb21pbmcsIGNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob3B0aW9ucy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY29udGV4dC5pbmNvbWluZ0J5SWQuZ2V0KG9wdGlvbnMuZnJvbS5fX3JlZik7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gcG9saWNpZXMucmVhZEZpZWxkKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tOiBpbmZvLnN0b3JlT2JqZWN0IH0pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaWVsZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZmxhdHRlbkZpZWxkcyhzZWxlY3Rpb25TZXQsIHJlc3VsdCwgY29udGV4dCwgdHlwZW5hbWUpLmZvckVhY2goZnVuY3Rpb24gKGNvbnRleHQsIGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcmVzdWx0RmllbGRLZXkgPSB1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbcmVzdWx0RmllbGRLZXldO1xuICAgICAgICAgICAgZmllbGROb2RlU2V0LmFkZChmaWVsZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZUZpZWxkTmFtZSA9IHBvbGljaWVzLmdldFN0b3JlRmllbGROYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb250ZXh0LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gZ2V0Q2hpbGRNZXJnZVRyZWUobWVyZ2VUcmVlLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGluY29taW5nVmFsdWUgPSBfdGhpcy5wcm9jZXNzRmllbGRWYWx1ZSh2YWx1ZSwgZmllbGQsIGZpZWxkLnNlbGVjdGlvblNldFxuICAgICAgICAgICAgICAgICAgICA/IGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHQsIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVHlwZW5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCAmJlxuICAgICAgICAgICAgICAgICAgICAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKGluY29taW5nVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChpbmNvbWluZ1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlbmFtZSA9IHJlYWRGaWVsZChcIl9fdHlwZW5hbWVcIiwgaW5jb21pbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtZXJnZSA9IHBvbGljaWVzLmdldE1lcmdlRnVuY3Rpb24odHlwZW5hbWUsIGZpZWxkLm5hbWUudmFsdWUsIGNoaWxkVHlwZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFRyZWUuaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lOiB0eXBlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtzdG9yZUZpZWxkTmFtZV0gPSBpbmNvbWluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX19ERVZfXyAmJlxuICAgICAgICAgICAgICAgICFjb250ZXh0LmNsaWVudE9ubHkgJiZcbiAgICAgICAgICAgICAgICAhY29udGV4dC5kZWZlcnJlZCAmJlxuICAgICAgICAgICAgICAgICF1dGlsaXRpZXMuYWRkVHlwZW5hbWVUb0RvY3VtZW50LmFkZGVkKGZpZWxkKSAmJlxuICAgICAgICAgICAgICAgICFwb2xpY2llcy5nZXRSZWFkRnVuY3Rpb24odHlwZW5hbWUsIGZpZWxkLm5hbWUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5lcnJvcihcIk1pc3NpbmcgZmllbGQgJ1wiLmNvbmNhdCh1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCksIFwiJyB3aGlsZSB3cml0aW5nIHJlc3VsdCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMikpLnN1YnN0cmluZygwLCAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9iID0gcG9saWNpZXMuaWRlbnRpZnkocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBjb250ZXh0LmZyYWdtZW50TWFwLFxuICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0OiBpbmNvbWluZyxcbiAgICAgICAgICAgICAgICByZWFkRmllbGQ6IHJlYWRGaWVsZCxcbiAgICAgICAgICAgIH0pLCBpZCA9IF9iWzBdLCBrZXlPYmplY3QgPSBfYlsxXTtcbiAgICAgICAgICAgIGRhdGFJZCA9IGRhdGFJZCB8fCBpZDtcbiAgICAgICAgICAgIGlmIChrZXlPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIGtleU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghZGF0YUlkKVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhSWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBzZXRzID0gY29udGV4dC53cml0dGVuW2RhdGFJZF0gfHwgKGNvbnRleHQud3JpdHRlbltkYXRhSWRdID0gW10pO1xuICAgICAgICAgICAgaWYgKHNldHMuaW5kZXhPZihzZWxlY3Rpb25TZXQpID49IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFSZWY7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlciAmJiB0aGlzLnJlYWRlci5pc0ZyZXNoKHJlc3VsdCwgZGF0YVJlZiwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzXzEgPSBjb250ZXh0LmluY29taW5nQnlJZC5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c18xKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNfMS5zdG9yZU9iamVjdCA9IGNvbnRleHQubWVyZ2UocHJldmlvdXNfMS5zdG9yZU9iamVjdCwgaW5jb21pbmcpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzXzEubWVyZ2VUcmVlID0gbWVyZ2VNZXJnZVRyZWVzKHByZXZpb3VzXzEubWVyZ2VUcmVlLCBtZXJnZVRyZWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkTm9kZVNldC5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gcHJldmlvdXNfMS5maWVsZE5vZGVTZXQuYWRkKGZpZWxkKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluY29taW5nQnlJZC5zZXQoZGF0YUlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0OiBpbmNvbWluZyxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUcmVlOiBtZXJnZVRyZWVJc0VtcHR5KG1lcmdlVHJlZSkgPyB2b2lkIDAgOiBtZXJnZVRyZWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTm9kZVNldDogZmllbGROb2RlU2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLnByb2Nlc3NGaWVsZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBmaWVsZCwgY29udGV4dCwgbWVyZ2VUcmVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0IHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX19ERVZfXyA/IHV0aWxpdGllcy5jbG9uZURlZXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMucHJvY2Vzc0ZpZWxkVmFsdWUoaXRlbSwgZmllbGQsIGNvbnRleHQsIGdldENoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSkpO1xuICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1NlbGVjdGlvblNldCh7XG4gICAgICAgICAgICByZXN1bHQ6IHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbWVyZ2VUcmVlOiBtZXJnZVRyZWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLmZsYXR0ZW5GaWVsZHMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uU2V0LCByZXN1bHQsIGNvbnRleHQsIHR5cGVuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlbmFtZSA9PT0gdm9pZCAwKSB7IHR5cGVuYW1lID0gdXRpbGl0aWVzLmdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIHNlbGVjdGlvblNldCwgY29udGV4dC5mcmFnbWVudE1hcCk7IH1cbiAgICAgICAgdmFyIGZpZWxkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNhY2hlLnBvbGljaWVzO1xuICAgICAgICB2YXIgbGltaXRpbmdUcmllID0gbmV3IHRyaWUuVHJpZShmYWxzZSk7XG4gICAgICAgIChmdW5jdGlvbiBmbGF0dGVuKHNlbGVjdGlvblNldCwgaW5oZXJpdGVkQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWROb2RlID0gbGltaXRpbmdUcmllLmxvb2t1cChzZWxlY3Rpb25TZXQsIGluaGVyaXRlZENvbnRleHQuY2xpZW50T25seSwgaW5oZXJpdGVkQ29udGV4dC5kZWZlcnJlZCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZE5vZGUudmlzaXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2aXNpdGVkTm9kZS52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbGl0aWVzLnNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCBjb250ZXh0LnZhcmlhYmxlcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50T25seSA9IGluaGVyaXRlZENvbnRleHQuY2xpZW50T25seSwgZGVmZXJyZWQgPSBpbmhlcml0ZWRDb250ZXh0LmRlZmVycmVkO1xuICAgICAgICAgICAgICAgIGlmICghKGNsaWVudE9ubHkgJiYgZGVmZXJyZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoc2VsZWN0aW9uLmRpcmVjdGl2ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkaXIubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImNsaWVudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiZGVmZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdXRpbGl0aWVzLmFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkaXIsIGNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5pZiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGZpZWxkTWFwLmdldChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9ubHkgPSBjbGllbnRPbmx5ICYmIGV4aXN0aW5nLmNsaWVudE9ubHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IGRlZmVycmVkICYmIGV4aXN0aW5nLmRlZmVycmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTWFwLnNldChzZWxlY3Rpb24sIGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgY2xpZW50T25seSwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHV0aWxpdGllcy5nZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBjb250ZXh0LmZyYWdtZW50TWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMoZnJhZ21lbnQsIHR5cGVuYW1lLCByZXN1bHQsIGNvbnRleHQudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbihmcmFnbWVudC5zZWxlY3Rpb25TZXQsIGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgY2xpZW50T25seSwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShzZWxlY3Rpb25TZXQsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZmllbGRNYXA7XG4gICAgfTtcbiAgICBTdG9yZVdyaXRlci5wcm90b3R5cGUuYXBwbHlNZXJnZXMgPSBmdW5jdGlvbiAobWVyZ2VUcmVlLCBleGlzdGluZywgaW5jb21pbmcsIGNvbnRleHQsIGdldFN0b3JhZ2VBcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG1lcmdlVHJlZS5tYXAuc2l6ZSAmJiAhdXRpbGl0aWVzLmlzUmVmZXJlbmNlKGluY29taW5nKSkge1xuICAgICAgICAgICAgdmFyIGVfMSA9ICghaXNBcnJheShpbmNvbWluZykgJiZcbiAgICAgICAgICAgICAgICAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKGV4aXN0aW5nKSB8fCBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChleGlzdGluZykpKSA/IGV4aXN0aW5nIDogdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGlfMSA9IGluY29taW5nO1xuICAgICAgICAgICAgaWYgKGVfMSAmJiAhZ2V0U3RvcmFnZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICBnZXRTdG9yYWdlQXJncyA9IFt1dGlsaXRpZXMuaXNSZWZlcmVuY2UoZV8xKSA/IGVfMS5fX3JlZiA6IGVfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhbmdlZEZpZWxkc18xO1xuICAgICAgICAgICAgdmFyIGdldFZhbHVlXzEgPSBmdW5jdGlvbiAoZnJvbSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KGZyb20pXG4gICAgICAgICAgICAgICAgICAgID8gKHR5cGVvZiBuYW1lID09PSBcIm51bWJlclwiID8gZnJvbVtuYW1lXSA6IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgICAgOiBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUoZnJvbSwgU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZXJnZVRyZWUubWFwLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVHJlZSwgc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZVZhbCA9IGdldFZhbHVlXzEoZV8xLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlWYWwgPSBnZXRWYWx1ZV8xKGlfMSwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGlWYWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0U3RvcmFnZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmFnZUFyZ3MucHVzaChzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhVmFsID0gX3RoaXMuYXBwbHlNZXJnZXMoY2hpbGRUcmVlLCBlVmFsLCBpVmFsLCBjb250ZXh0LCBnZXRTdG9yYWdlQXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKGFWYWwgIT09IGlWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xID0gY2hhbmdlZEZpZWxkc18xIHx8IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHNfMS5zZXQoc3RvcmVGaWVsZE5hbWUsIGFWYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2V0U3RvcmFnZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFscy5pbnZhcmlhbnQoZ2V0U3RvcmFnZUFyZ3MucG9wKCkgPT09IHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkRmllbGRzXzEpIHtcbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IChpc0FycmF5KGlfMSkgPyBpXzEuc2xpY2UoMCkgOiB0c2xpYi5fX2Fzc2lnbih7fSwgaV8xKSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lcmdlVHJlZS5pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5wb2xpY2llcy5ydW5NZXJnZUZ1bmN0aW9uKGV4aXN0aW5nLCBpbmNvbWluZywgbWVyZ2VUcmVlLmluZm8sIGNvbnRleHQsIGdldFN0b3JhZ2VBcmdzICYmIChfYSA9IGNvbnRleHQuc3RvcmUpLmdldFN0b3JhZ2UuYXBwbHkoX2EsIGdldFN0b3JhZ2VBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlV3JpdGVyO1xufSgpKTtcbnZhciBlbXB0eU1lcmdlVHJlZVBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldENoaWxkTWVyZ2VUcmVlKF9hLCBuYW1lKSB7XG4gICAgdmFyIG1hcCA9IF9hLm1hcDtcbiAgICBpZiAoIW1hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgbWFwLnNldChuYW1lLCBlbXB0eU1lcmdlVHJlZVBvb2wucG9wKCkgfHwgeyBtYXA6IG5ldyBNYXAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXAuZ2V0KG5hbWUpO1xufVxuZnVuY3Rpb24gbWVyZ2VNZXJnZVRyZWVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0IHx8ICFyaWdodCB8fCBtZXJnZVRyZWVJc0VtcHR5KHJpZ2h0KSlcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgaWYgKCFsZWZ0IHx8IG1lcmdlVHJlZUlzRW1wdHkobGVmdCkpXG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB2YXIgaW5mbyA9IGxlZnQuaW5mbyAmJiByaWdodC5pbmZvID8gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGxlZnQuaW5mbyksIHJpZ2h0LmluZm8pIDogbGVmdC5pbmZvIHx8IHJpZ2h0LmluZm87XG4gICAgdmFyIG5lZWRUb01lcmdlTWFwcyA9IGxlZnQubWFwLnNpemUgJiYgcmlnaHQubWFwLnNpemU7XG4gICAgdmFyIG1hcCA9IG5lZWRUb01lcmdlTWFwcyA/IG5ldyBNYXAgOlxuICAgICAgICBsZWZ0Lm1hcC5zaXplID8gbGVmdC5tYXAgOiByaWdodC5tYXA7XG4gICAgdmFyIG1lcmdlZCA9IHsgaW5mbzogaW5mbywgbWFwOiBtYXAgfTtcbiAgICBpZiAobmVlZFRvTWVyZ2VNYXBzKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdSaWdodEtleXNfMSA9IG5ldyBTZXQocmlnaHQubWFwLmtleXMoKSk7XG4gICAgICAgIGxlZnQubWFwLmZvckVhY2goZnVuY3Rpb24gKGxlZnRUcmVlLCBrZXkpIHtcbiAgICAgICAgICAgIG1lcmdlZC5tYXAuc2V0KGtleSwgbWVyZ2VNZXJnZVRyZWVzKGxlZnRUcmVlLCByaWdodC5tYXAuZ2V0KGtleSkpKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ1JpZ2h0S2V5c18xLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVtYWluaW5nUmlnaHRLZXlzXzEuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBtZXJnZWQubWFwLnNldChrZXksIG1lcmdlTWVyZ2VUcmVlcyhyaWdodC5tYXAuZ2V0KGtleSksIGxlZnQubWFwLmdldChrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZnVuY3Rpb24gbWVyZ2VUcmVlSXNFbXB0eSh0cmVlKSB7XG4gICAgcmV0dXJuICF0cmVlIHx8ICEodHJlZS5pbmZvIHx8IHRyZWUubWFwLnNpemUpO1xufVxuZnVuY3Rpb24gbWF5YmVSZWN5Y2xlQ2hpbGRNZXJnZVRyZWUoX2EsIG5hbWUpIHtcbiAgICB2YXIgbWFwID0gX2EubWFwO1xuICAgIHZhciBjaGlsZFRyZWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgIGlmIChjaGlsZFRyZWUgJiYgbWVyZ2VUcmVlSXNFbXB0eShjaGlsZFRyZWUpKSB7XG4gICAgICAgIGVtcHR5TWVyZ2VUcmVlUG9vbC5wdXNoKGNoaWxkVHJlZSk7XG4gICAgICAgIG1hcC5kZWxldGUobmFtZSk7XG4gICAgfVxufVxudmFyIHdhcm5pbmdzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2FybkFib3V0RGF0YUxvc3MoZXhpc3RpbmdSZWYsIGluY29taW5nT2JqLCBzdG9yZUZpZWxkTmFtZSwgc3RvcmUpIHtcbiAgICB2YXIgZ2V0Q2hpbGQgPSBmdW5jdGlvbiAob2JqT3JSZWYpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShvYmpPclJlZiwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkO1xuICAgIH07XG4gICAgdmFyIGV4aXN0aW5nID0gZ2V0Q2hpbGQoZXhpc3RpbmdSZWYpO1xuICAgIGlmICghZXhpc3RpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgaW5jb21pbmcgPSBnZXRDaGlsZChpbmNvbWluZ09iaik7XG4gICAgaWYgKCFpbmNvbWluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2UoZXhpc3RpbmcpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGVxdWFsaXR5LmVxdWFsKGV4aXN0aW5nLCBpbmNvbWluZykpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoT2JqZWN0LmtleXMoZXhpc3RpbmcpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHN0b3JlLmdldEZpZWxkVmFsdWUoaW5jb21pbmcsIGtleSkgIT09IHZvaWQgMDsgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyZW50VHlwZSA9IHN0b3JlLmdldEZpZWxkVmFsdWUoZXhpc3RpbmdSZWYsIFwiX190eXBlbmFtZVwiKSB8fFxuICAgICAgICBzdG9yZS5nZXRGaWVsZFZhbHVlKGluY29taW5nT2JqLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgIHZhciB0eXBlRG90TmFtZSA9IFwiXCIuY29uY2F0KHBhcmVudFR5cGUsIFwiLlwiKS5jb25jYXQoZmllbGROYW1lKTtcbiAgICBpZiAod2FybmluZ3MuaGFzKHR5cGVEb3ROYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5pbmdzLmFkZCh0eXBlRG90TmFtZSk7XG4gICAgdmFyIGNoaWxkVHlwZW5hbWVzID0gW107XG4gICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSAmJlxuICAgICAgICAhaXNBcnJheShpbmNvbWluZykpIHtcbiAgICAgICAgW2V4aXN0aW5nLCBpbmNvbWluZ10uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IHN0b3JlLmdldEZpZWxkVmFsdWUoY2hpbGQsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZW5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAhY2hpbGRUeXBlbmFtZXMuaW5jbHVkZXModHlwZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlbmFtZXMucHVzaCh0eXBlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50Lndhcm4oXCJDYWNoZSBkYXRhIG1heSBiZSBsb3N0IHdoZW4gcmVwbGFjaW5nIHRoZSBcIi5jb25jYXQoZmllbGROYW1lLCBcIiBmaWVsZCBvZiBhIFwiKS5jb25jYXQocGFyZW50VHlwZSwgXCIgb2JqZWN0LlxcblxcblRvIGFkZHJlc3MgdGhpcyBwcm9ibGVtICh3aGljaCBpcyBub3QgYSBidWcgaW4gQXBvbGxvIENsaWVudCksIFwiKS5jb25jYXQoY2hpbGRUeXBlbmFtZXMubGVuZ3RoXG4gICAgICAgID8gXCJlaXRoZXIgZW5zdXJlIGFsbCBvYmplY3RzIG9mIHR5cGUgXCIgK1xuICAgICAgICAgICAgY2hpbGRUeXBlbmFtZXMuam9pbihcIiBhbmQgXCIpICsgXCIgaGF2ZSBhbiBJRCBvciBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiwgb3IgXCJcbiAgICAgICAgOiBcIlwiLCBcImRlZmluZSBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBmb3IgdGhlIFwiKS5jb25jYXQodHlwZURvdE5hbWUsIFwiIGZpZWxkLCBzbyBJbk1lbW9yeUNhY2hlIGNhbiBzYWZlbHkgbWVyZ2UgdGhlc2Ugb2JqZWN0czpcXG5cXG4gIGV4aXN0aW5nOiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nKS5zbGljZSgwLCAxMDAwKSwgXCJcXG4gIGluY29taW5nOiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGluY29taW5nKS5zbGljZSgwLCAxMDAwKSwgXCJcXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVzZSBvcHRpb25zLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb246XFxuXFxuICAqIEVuc3VyaW5nIGVudGl0eSBvYmplY3RzIGhhdmUgSURzOiBodHRwczovL2dvLmFwb2xsby5kZXYvYy9nZW5lcmF0aW5nLXVuaXF1ZS1pZGVudGlmaWVyc1xcbiAgKiBEZWZpbmluZyBjdXN0b20gbWVyZ2UgZnVuY3Rpb25zOiBodHRwczovL2dvLmFwb2xsby5kZXYvYy9tZXJnaW5nLW5vbi1ub3JtYWxpemVkLW9iamVjdHNcXG5cIikpO1xufVxuXG52YXIgSW5NZW1vcnlDYWNoZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEluTWVtb3J5Q2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlDYWNoZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndhdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMubWFrZVZhciA9IG1ha2VWYXI7XG4gICAgICAgIF90aGlzLnR4Q291bnQgPSAwO1xuICAgICAgICBfdGhpcy5jb25maWcgPSBub3JtYWxpemVDb25maWcoY29uZmlnKTtcbiAgICAgICAgX3RoaXMuYWRkVHlwZW5hbWUgPSAhIV90aGlzLmNvbmZpZy5hZGRUeXBlbmFtZTtcbiAgICAgICAgX3RoaXMucG9saWNpZXMgPSBuZXcgUG9saWNpZXMoe1xuICAgICAgICAgICAgY2FjaGU6IF90aGlzLFxuICAgICAgICAgICAgZGF0YUlkRnJvbU9iamVjdDogX3RoaXMuY29uZmlnLmRhdGFJZEZyb21PYmplY3QsXG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzOiBfdGhpcy5jb25maWcucG9zc2libGVUeXBlcyxcbiAgICAgICAgICAgIHR5cGVQb2xpY2llczogX3RoaXMuY29uZmlnLnR5cGVQb2xpY2llcyxcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdFN0b3JlID0gdGhpcy5kYXRhID0gbmV3IGV4cG9ydHMuRW50aXR5U3RvcmUuUm9vdCh7XG4gICAgICAgICAgICBwb2xpY2llczogdGhpcy5wb2xpY2llcyxcbiAgICAgICAgICAgIHJlc3VsdENhY2hpbmc6IHRoaXMuY29uZmlnLnJlc3VsdENhY2hpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gcm9vdFN0b3JlLnN0dW1wO1xuICAgICAgICB0aGlzLnJlc2V0UmVzdWx0Q2FjaGUoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc2V0UmVzdWx0Q2FjaGUgPSBmdW5jdGlvbiAocmVzZXRSZXN1bHRJZGVudGl0aWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2aW91c1JlYWRlciA9IHRoaXMuc3RvcmVSZWFkZXI7XG4gICAgICAgIHRoaXMuc3RvcmVXcml0ZXIgPSBuZXcgU3RvcmVXcml0ZXIodGhpcywgdGhpcy5zdG9yZVJlYWRlciA9IG5ldyBTdG9yZVJlYWRlcih7XG4gICAgICAgICAgICBjYWNoZTogdGhpcyxcbiAgICAgICAgICAgIGFkZFR5cGVuYW1lOiB0aGlzLmFkZFR5cGVuYW1lLFxuICAgICAgICAgICAgcmVzdWx0Q2FjaGVNYXhTaXplOiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBjYW5vbml6ZVJlc3VsdHM6IHNob3VsZENhbm9uaXplUmVzdWx0cyh0aGlzLmNvbmZpZyksXG4gICAgICAgICAgICBjYW5vbjogcmVzZXRSZXN1bHRJZGVudGl0aWVzXG4gICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICA6IHByZXZpb3VzUmVhZGVyICYmIHByZXZpb3VzUmVhZGVyLmNhbm9uLFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMubWF5YmVCcm9hZGNhc3RXYXRjaCA9IG9wdGltaXNtLndyYXAoZnVuY3Rpb24gKGMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5icm9hZGNhc3RXYXRjaChjLCBvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gYy5vcHRpbWlzdGljID8gX3RoaXMub3B0aW1pc3RpY0RhdGEgOiBfdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc3VsdENhY2hpbmcoc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpbWlzdGljID0gYy5vcHRpbWlzdGljLCByb290SWQgPSBjLnJvb3RJZCwgdmFyaWFibGVzID0gYy52YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5tYWtlQ2FjaGVLZXkoYy5xdWVyeSwgYy5jYWxsYmFjaywgY2Fub25pY2FsU3RyaW5naWZ5KHsgb3B0aW1pc3RpYzogb3B0aW1pc3RpYywgcm9vdElkOiByb290SWQsIHZhcmlhYmxlczogdmFyaWFibGVzIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZXcgU2V0KFtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5ncm91cCxcbiAgICAgICAgICAgIHRoaXMub3B0aW1pc3RpY0RhdGEuZ3JvdXAsXG4gICAgICAgIF0pLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7IHJldHVybiBncm91cC5yZXNldENhY2hpbmcoKTsgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgdGhpcy5kYXRhLnJlcGxhY2UoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiAob3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEpLmV4dHJhY3QoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLnJldHVyblBhcnRpYWxEYXRhLCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVSZWFkZXIuZGlmZlF1ZXJ5QWdhaW5zdFN0b3JlKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzdG9yZTogb3B0aW9ucy5vcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSwgY29uZmlnOiB0aGlzLmNvbmZpZywgcmV0dXJuUGFydGlhbERhdGE6IHJldHVyblBhcnRpYWxEYXRhIH0pKS5yZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNaXNzaW5nRmllbGRFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKyt0aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVdyaXRlci53cml0ZVRvU3RvcmUodGhpcy5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghLS10aGlzLnR4Q291bnQgJiYgb3B0aW9ucy5icm9hZGNhc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChvcHRpb25zLCBcImlkXCIpICYmICFvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3JlID0gb3B0aW9ucy5vcHRpbWlzdGljXG4gICAgICAgICAgICA/IHRoaXMub3B0aW1pc3RpY0RhdGFcbiAgICAgICAgICAgIDogdGhpcy5kYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKyt0aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUubW9kaWZ5KG9wdGlvbnMuaWQgfHwgXCJST09UX1FVRVJZXCIsIG9wdGlvbnMuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghLS10aGlzLnR4Q291bnQgJiYgb3B0aW9ucy5icm9hZGNhc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVJlYWRlci5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHN0b3JlOiBvcHRpb25zLm9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhLCByb290SWQ6IG9wdGlvbnMuaWQgfHwgXCJST09UX1FVRVJZXCIsIGNvbmZpZzogdGhpcy5jb25maWcgfSkpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAod2F0Y2gpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLndhdGNoZXMuc2l6ZSkge1xuICAgICAgICAgICAgcmVjYWxsQ2FjaGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaGVzLmFkZCh3YXRjaCk7XG4gICAgICAgIGlmICh3YXRjaC5pbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVCcm9hZGNhc3RXYXRjaCh3YXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy53YXRjaGVzLmRlbGV0ZSh3YXRjaCkgJiYgIV90aGlzLndhdGNoZXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGZvcmdldENhY2hlKF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1heWJlQnJvYWRjYXN0V2F0Y2guZm9yZ2V0KHdhdGNoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmdjID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgY2Fub25pY2FsU3RyaW5naWZ5LnJlc2V0KCk7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLm9wdGltaXN0aWNEYXRhLmdjKCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmICF0aGlzLnR4Q291bnQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc2V0UmVzdWx0Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UmVzdWx0Q2FjaGUob3B0aW9ucy5yZXNldFJlc3VsdElkZW50aXRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5yZXNldFJlc3VsdElkZW50aXRpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlUmVhZGVyLnJlc2V0Q2Fub24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJvb3RJZCwgb3B0aW1pc3RpYykge1xuICAgICAgICByZXR1cm4gKG9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhKS5yZXRhaW4ocm9vdElkKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAocm9vdElkLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIHJldHVybiAob3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEpLnJlbGVhc2Uocm9vdElkKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKG9iamVjdCkpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0Ll9fcmVmO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9saWNpZXMuaWRlbnRpZnkob2JqZWN0KVswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5ldmljdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pZCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9wdGlvbnMsIFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGlkOiBcIlJPT1RfUVVFUllcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKyt0aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpbWlzdGljRGF0YS5ldmljdChvcHRpb25zLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCEtLXRoaXMudHhDb3VudCAmJiBvcHRpb25zLmJyb2FkY2FzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgY2Fub25pY2FsU3RyaW5naWZ5LnJlc2V0KCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGlzY2FyZFdhdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YXRjaCkgeyByZXR1cm4gX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaC5mb3JnZXQod2F0Y2gpOyB9KTtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5jbGVhcigpO1xuICAgICAgICAgICAgZm9yZ2V0Q2FjaGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZW1vdmVPcHRpbWlzdGljID0gZnVuY3Rpb24gKGlkVG9SZW1vdmUpIHtcbiAgICAgICAgdmFyIG5ld09wdGltaXN0aWNEYXRhID0gdGhpcy5vcHRpbWlzdGljRGF0YS5yZW1vdmVMYXllcihpZFRvUmVtb3ZlKTtcbiAgICAgICAgaWYgKG5ld09wdGltaXN0aWNEYXRhICE9PSB0aGlzLm9wdGltaXN0aWNEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gbmV3T3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlID0gb3B0aW9ucy51cGRhdGUsIF9hID0gb3B0aW9ucy5vcHRpbWlzdGljLCBvcHRpbWlzdGljID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYSwgcmVtb3ZlT3B0aW1pc3RpYyA9IG9wdGlvbnMucmVtb3ZlT3B0aW1pc3RpYywgb25XYXRjaFVwZGF0ZWQgPSBvcHRpb25zLm9uV2F0Y2hVcGRhdGVkO1xuICAgICAgICB2YXIgdXBkYXRlUmVzdWx0O1xuICAgICAgICB2YXIgcGVyZm9ybSA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIGRhdGEgPSBfYS5kYXRhLCBvcHRpbWlzdGljRGF0YSA9IF9hLm9wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgKytfdGhpcy50eENvdW50O1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YSA9IF90aGlzLm9wdGltaXN0aWNEYXRhID0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXN1bHQgPSB1cGRhdGUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLS1fdGhpcy50eENvdW50O1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGltaXN0aWNEYXRhID0gb3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhbHJlYWR5RGlydHkgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbldhdGNoVXBkYXRlZCAmJiAhdGhpcy50eENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXModHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG9uV2F0Y2hVcGRhdGVkOiBmdW5jdGlvbiAod2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeURpcnR5LmFkZCh3YXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGltaXN0aWMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gdGhpcy5vcHRpbWlzdGljRGF0YS5hZGRMYXllcihvcHRpbWlzdGljLCBwZXJmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpbWlzdGljID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGVyZm9ybSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyZm9ybSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVtb3ZlT3B0aW1pc3RpYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpbWlzdGljRGF0YSA9IHRoaXMub3B0aW1pc3RpY0RhdGEucmVtb3ZlTGF5ZXIocmVtb3ZlT3B0aW1pc3RpYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uV2F0Y2hVcGRhdGVkICYmIGFscmVhZHlEaXJ0eS5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXModHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG9uV2F0Y2hVcGRhdGVkOiBmdW5jdGlvbiAod2F0Y2gsIGRpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9uV2F0Y2hVcGRhdGVkLmNhbGwodGhpcywgd2F0Y2gsIGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeURpcnR5LmRlbGV0ZSh3YXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5RGlydHkuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGFscmVhZHlEaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uICh3YXRjaCkgeyByZXR1cm4gX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaC5kaXJ0eSh3YXRjaCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVSZXN1bHQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5wZXJmb3JtVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodXBkYXRlLCBvcHRpbWlzdGljSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2goe1xuICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBvcHRpbWlzdGljSWQgfHwgKG9wdGltaXN0aWNJZCAhPT0gbnVsbCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUudHJhbnNmb3JtRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRkVHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZS5nZXQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1dGlsaXRpZXMuYWRkVHlwZW5hbWVUb0RvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZS5zZXQoZG9jdW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlbmFtZURvY3VtZW50Q2FjaGUuc2V0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYnJvYWRjYXN0V2F0Y2hlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy50eENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaChjLCBvcHRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmJyb2FkY2FzdFdhdGNoID0gZnVuY3Rpb24gKGMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxhc3REaWZmID0gYy5sYXN0RGlmZjtcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYoYyk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoYy5vcHRpbWlzdGljICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMub3B0aW1pc3RpYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRpZmYuZnJvbU9wdGltaXN0aWNUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbldhdGNoVXBkYXRlZCAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25XYXRjaFVwZGF0ZWQuY2FsbCh0aGlzLCBjLCBkaWZmLCBsYXN0RGlmZikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdERpZmYgfHwgIWVxdWFsaXR5LmVxdWFsKGxhc3REaWZmLnJlc3VsdCwgZGlmZi5yZXN1bHQpKSB7XG4gICAgICAgICAgICBjLmNhbGxiYWNrKGMubGFzdERpZmYgPSBkaWZmLCBsYXN0RGlmZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeUNhY2hlO1xufShBcG9sbG9DYWNoZSkpO1xuXG5leHBvcnRzLmlzUmVmZXJlbmNlID0gdXRpbGl0aWVzLmlzUmVmZXJlbmNlO1xuZXhwb3J0cy5tYWtlUmVmZXJlbmNlID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2U7XG5leHBvcnRzLkFwb2xsb0NhY2hlID0gQXBvbGxvQ2FjaGU7XG5leHBvcnRzLkluTWVtb3J5Q2FjaGUgPSBJbk1lbW9yeUNhY2hlO1xuZXhwb3J0cy5NaXNzaW5nRmllbGRFcnJvciA9IE1pc3NpbmdGaWVsZEVycm9yO1xuZXhwb3J0cy5Qb2xpY2llcyA9IFBvbGljaWVzO1xuZXhwb3J0cy5jYWNoZVNsb3QgPSBjYWNoZVNsb3Q7XG5leHBvcnRzLmNhbm9uaWNhbFN0cmluZ2lmeSA9IGNhbm9uaWNhbFN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdERhdGFJZEZyb21PYmplY3QgPSBkZWZhdWx0RGF0YUlkRnJvbU9iamVjdDtcbmV4cG9ydHMuZmllbGROYW1lRnJvbVN0b3JlTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWU7XG5leHBvcnRzLm1ha2VWYXIgPSBtYWtlVmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGUuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuLi9saW5rL2NvcmUnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnLi4vbGluay9odHRwJyk7XG52YXIgZXF1YWxpdHkgPSByZXF1aXJlKCdAd3J5L2VxdWFsaXR5Jyk7XG52YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xudmFyIGdyYXBocWwgPSByZXF1aXJlKCdncmFwaHFsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9saW5rL3V0aWxzJyk7XG52YXIgdHNJbnZhcmlhbnQgPSByZXF1aXJlKCd0cy1pbnZhcmlhbnQnKTtcbnZhciBncmFwaHFsVGFnID0gcmVxdWlyZSgnZ3JhcGhxbC10YWcnKTtcblxudmFyIHZlcnNpb24gPSAnMy42LjknO1xuXG5leHBvcnRzLk5ldHdvcmtTdGF0dXMgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKE5ldHdvcmtTdGF0dXMpIHtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJsb2FkaW5nXCJdID0gMV0gPSBcImxvYWRpbmdcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJzZXRWYXJpYWJsZXNcIl0gPSAyXSA9IFwic2V0VmFyaWFibGVzXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZmV0Y2hNb3JlXCJdID0gM10gPSBcImZldGNoTW9yZVwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInJlZmV0Y2hcIl0gPSA0XSA9IFwicmVmZXRjaFwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInBvbGxcIl0gPSA2XSA9IFwicG9sbFwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInJlYWR5XCJdID0gN10gPSBcInJlYWR5XCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZXJyb3JcIl0gPSA4XSA9IFwiZXJyb3JcIjtcbn0pKGV4cG9ydHMuTmV0d29ya1N0YXR1cyB8fCAoZXhwb3J0cy5OZXR3b3JrU3RhdHVzID0ge30pKTtcbmZ1bmN0aW9uIGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChuZXR3b3JrU3RhdHVzKSB7XG4gICAgcmV0dXJuIG5ldHdvcmtTdGF0dXMgPyBuZXR3b3JrU3RhdHVzIDwgNyA6IGZhbHNlO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbnZhciBPYnNlcnZhYmxlUXVlcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhPYnNlcnZhYmxlUXVlcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVF1ZXJ5KF9hKSB7XG4gICAgICAgIHZhciBxdWVyeU1hbmFnZXIgPSBfYS5xdWVyeU1hbmFnZXIsIHF1ZXJ5SW5mbyA9IF9hLnF1ZXJ5SW5mbywgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViT2JzZXJ2ZXIgPSBvYnNlcnZlci5fc3Vic2NyaXB0aW9uLl9vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViT2JzZXJ2ZXIgJiYgIXN1Yk9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yk9ic2VydmVyLmVycm9yID0gZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gIV90aGlzLm9ic2VydmVycy5zaXplO1xuICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IF90aGlzLmxhc3Q7XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IobGFzdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0ICYmIGxhc3QucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KGxhc3QucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlb2JzZXJ2ZSgpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKSAmJiAhX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVhckRvd25RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMucXVlcnlJbmZvID0gcXVlcnlJbmZvO1xuICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIgPSBxdWVyeU1hbmFnZXI7XG4gICAgICAgIF90aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICAgICAgdmFyIF9iID0gcXVlcnlNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIF9jID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9kID0gX2MuZmV0Y2hQb2xpY3ksIGRlZmF1bHRGZXRjaFBvbGljeSA9IF9kID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfZDtcbiAgICAgICAgdmFyIF9lID0gb3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoUG9saWN5IDogX2UsIF9mID0gb3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3ksIGluaXRpYWxGZXRjaFBvbGljeSA9IF9mID09PSB2b2lkIDAgPyAoZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiID8gZGVmYXVsdEZldGNoUG9saWN5IDogZmV0Y2hQb2xpY3kpIDogX2Y7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgaW5pdGlhbEZldGNoUG9saWN5OiBpbml0aWFsRmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSB9KTtcbiAgICAgICAgX3RoaXMucXVlcnlJZCA9IHF1ZXJ5SW5mby5xdWVyeUlkIHx8IHF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgdmFyIG9wRGVmID0gdXRpbGl0aWVzLmdldE9wZXJhdGlvbkRlZmluaXRpb24oX3RoaXMucXVlcnkpO1xuICAgICAgICBfdGhpcy5xdWVyeU5hbWUgPSBvcERlZiAmJiBvcERlZi5uYW1lICYmIG9wRGVmLm5hbWUudmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUsIFwicXVlcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0odGhpcy5vcHRpb25zLnF1ZXJ5KS5kb2N1bWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLCBcInZhcmlhYmxlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5yZW1vdmVRdWVyeShfdGhpcy5xdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRDdXJyZW50UmVzdWx0ID0gZnVuY3Rpb24gKHNhdmVBc0xhc3RSZXN1bHQpIHtcbiAgICAgICAgaWYgKHNhdmVBc0xhc3RSZXN1bHQgPT09IHZvaWQgMCkgeyBzYXZlQXNMYXN0UmVzdWx0ID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IHRoaXMuZ2V0TGFzdFJlc3VsdCh0cnVlKTtcbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSB0aGlzLnF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8XG4gICAgICAgICAgICAobGFzdFJlc3VsdCAmJiBsYXN0UmVzdWx0Lm5ldHdvcmtTdGF0dXMpIHx8XG4gICAgICAgICAgICBleHBvcnRzLk5ldHdvcmtTdGF0dXMucmVhZHk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbGFzdFJlc3VsdCksIHsgbG9hZGluZzogaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpLCBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzIH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2EgPT09IHZvaWQgMCA/IFwiY2FjaGUtZmlyc3RcIiA6IF9hO1xuICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJyB8fFxuICAgICAgICAgICAgZmV0Y2hQb2xpY3kgPT09ICdzdGFuZGJ5JyB8fFxuICAgICAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIudHJhbnNmb3JtKHRoaXMub3B0aW9ucy5xdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnF1ZXJ5SW5mby5nZXREaWZmKCk7XG4gICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSB8fCB0aGlzLm9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRpZmYucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVxdWFsaXR5LmVxdWFsKHJlc3VsdC5kYXRhLCB7fSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID09PSBleHBvcnRzLk5ldHdvcmtTdGF0dXMubG9hZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1maXJzdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX0RFVl9fICYmXG4gICAgICAgICAgICAgICAgIWRpZmYuY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5vcHRpb25zLnBhcnRpYWxSZWZldGNoICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5kYXRhICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ01pc3NpbmdGaWVsZEVycm9ycyhkaWZmLm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzYXZlQXNMYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5pc0RpZmZlcmVudEZyb21MYXN0UmVzdWx0ID0gZnVuY3Rpb24gKG5ld1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubGFzdCB8fCAhZXF1YWxpdHkuZXF1YWwodGhpcy5sYXN0LnJlc3VsdCwgbmV3UmVzdWx0KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZ2V0TGFzdCA9IGZ1bmN0aW9uIChrZXksIHZhcmlhYmxlc011c3RNYXRjaCkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubGFzdDtcbiAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgIGxhc3Rba2V5XSAmJlxuICAgICAgICAgICAgKCF2YXJpYWJsZXNNdXN0TWF0Y2ggfHwgZXF1YWxpdHkuZXF1YWwobGFzdC52YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZ2V0TGFzdFJlc3VsdCA9IGZ1bmN0aW9uICh2YXJpYWJsZXNNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdChcInJlc3VsdFwiLCB2YXJpYWJsZXNNdXN0TWF0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAodmFyaWFibGVzTXVzdE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExhc3QoXCJlcnJvclwiLCB2YXJpYWJsZXNNdXN0TWF0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldExhc3RSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5sYXN0O1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzZXRRdWVyeVN0b3JlRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5yZXNldEVycm9ycyh0aGlzLnF1ZXJ5SWQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZWZldGNoID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZW9ic2VydmVPcHRpb25zID0ge1xuICAgICAgICAgICAgcG9sbEludGVydmFsOiAwLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZmV0Y2hQb2xpY3kgPSB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLWFuZC1uZXR3b3JrJykge1xuICAgICAgICAgICAgcmVvYnNlcnZlT3B0aW9ucy5mZXRjaFBvbGljeSA9IGZldGNoUG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICByZW9ic2VydmVPcHRpb25zLmZldGNoUG9saWN5ID0gJ25vLWNhY2hlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgPSAnbmV0d29yay1vbmx5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXyAmJiB2YXJpYWJsZXMgJiYgaGFzT3duUHJvcGVydHkkMS5jYWxsKHZhcmlhYmxlcywgXCJ2YXJpYWJsZXNcIikpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeURlZiA9IHV0aWxpdGllcy5nZXRRdWVyeURlZmluaXRpb24odGhpcy5xdWVyeSk7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHF1ZXJ5RGVmLnZhcmlhYmxlRGVmaW5pdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXZhcnMgfHwgIXZhcnMuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gdi52YXJpYWJsZS5uYW1lLnZhbHVlID09PSBcInZhcmlhYmxlc1wiOyB9KSkge1xuICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkNhbGxlZCByZWZldGNoKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YXJpYWJsZXMpLCBcIikgZm9yIHF1ZXJ5IFwiKS5jb25jYXQoKChfYSA9IHF1ZXJ5RGVmLm5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgfHwgSlNPTi5zdHJpbmdpZnkocXVlcnlEZWYpLCBcIiwgd2hpY2ggZG9lcyBub3QgZGVjbGFyZSBhICR2YXJpYWJsZXMgdmFyaWFibGUuXFxuRGlkIHlvdSBtZWFuIHRvIGNhbGwgcmVmZXRjaCh2YXJpYWJsZXMpIGluc3RlYWQgb2YgcmVmZXRjaCh7IHZhcmlhYmxlcyB9KT9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYWJsZXMgJiYgIWVxdWFsaXR5LmVxdWFsKHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMudmFyaWFibGVzID0gdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgdmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXJ5SW5mby5yZXNldExhc3RXcml0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUocmVvYnNlcnZlT3B0aW9ucywgZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlZmV0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5mZXRjaE1vcmUgPSBmdW5jdGlvbiAoZmV0Y2hNb3JlT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tYmluZWRPcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChmZXRjaE1vcmVPcHRpb25zLnF1ZXJ5ID8gZmV0Y2hNb3JlT3B0aW9ucyA6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IHF1ZXJ5OiB0aGlzLnF1ZXJ5IH0pLCBmZXRjaE1vcmVPcHRpb25zKSwgeyB2YXJpYWJsZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgZmV0Y2hNb3JlT3B0aW9ucy52YXJpYWJsZXMpIH0pKSksIHsgZmV0Y2hQb2xpY3k6IFwibm8tY2FjaGVcIiB9KTtcbiAgICAgICAgdmFyIHFpZCA9IHRoaXMucXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpO1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyeUluZm87XG4gICAgICAgIHZhciBvcmlnaW5hbE5ldHdvcmtTdGF0dXMgPSBxdWVyeUluZm8ubmV0d29ya1N0YXR1cztcbiAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlO1xuICAgICAgICBpZiAoY29tYmluZWRPcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRRdWVyeVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLmZldGNoUXVlcnkocWlkLCBjb21iaW5lZE9wdGlvbnMsIGV4cG9ydHMuTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpLnRoZW4oZnVuY3Rpb24gKGZldGNoTW9yZVJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMucXVlcnlNYW5hZ2VyLnJlbW92ZVF1ZXJ5KHFpZCk7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9IG9yaWdpbmFsTmV0d29ya1N0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5jYWNoZS5iYXRjaCh7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gZmV0Y2hNb3JlT3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS51cGRhdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IF90aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogX3RoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHByZXZpb3VzKSB7IHJldHVybiB1cGRhdGVRdWVyeShwcmV2aW91cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9yZVJlc3VsdDogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGNvbWJpbmVkT3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUXVlcnlTZXQuYWRkKHdhdGNoLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hNb3JlUmVzdWx0O1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZFF1ZXJ5U2V0LmhhcyhfdGhpcy5xdWVyeSkpIHtcbiAgICAgICAgICAgICAgICByZW9ic2VydmVDYWNoZUZpcnN0KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN1YnNjcmliZVRvTW9yZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnF1ZXJ5TWFuYWdlclxuICAgICAgICAgICAgLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbih7XG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5kb2N1bWVudCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gb3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUXVlcnkoZnVuY3Rpb24gKHByZXZpb3VzLCBfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVRdWVyeShwcmV2aW91cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGE6IHN1YnNjcmlwdGlvbkRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50LmVycm9yKCdVbmhhbmRsZWQgR3JhcGhRTCBzdWJzY3JpcHRpb24gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUobmV3T3B0aW9ucyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldFZhcmlhYmxlcyA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGVxdWFsaXR5LmVxdWFsKHRoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMuc2l6ZVxuICAgICAgICAgICAgICAgID8gdGhpcy5yZXN1bHQoKVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVvYnNlcnZlKHtcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiB0aGlzLm9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgIH0sIGV4cG9ydHMuTmV0d29ya1N0YXR1cy5zZXRWYXJpYWJsZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVRdWVyeSA9IGZ1bmN0aW9uIChtYXBGbikge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gdGhpcy5xdWVyeU1hbmFnZXI7XG4gICAgICAgIHZhciByZXN1bHQgPSBxdWVyeU1hbmFnZXIuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5vcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgIH0pLnJlc3VsdDtcbiAgICAgICAgdmFyIG5ld1Jlc3VsdCA9IG1hcEZuKHJlc3VsdCwge1xuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdSZXN1bHQpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci5jYWNoZS53cml0ZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBxdWVyeTogdGhpcy5vcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGRhdGE6IG5ld1Jlc3VsdCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHRoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IHBvbGxJbnRlcnZhbDtcbiAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucG9sbEludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmFwcGx5TmV4dEZldGNoUG9saWN5ID0gZnVuY3Rpb24gKHJlYXNvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2EgPT09IHZvaWQgMCA/IFwiY2FjaGUtZmlyc3RcIiA6IF9hLCBfYiA9IG9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LCBpbml0aWFsRmV0Y2hQb2xpY3kgPSBfYiA9PT0gdm9pZCAwID8gZmV0Y2hQb2xpY3kgOiBfYjtcbiAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm5leHRGZXRjaFBvbGljeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IG9wdGlvbnMubmV4dEZldGNoUG9saWN5KGZldGNoUG9saWN5LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3k6IGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlYXNvbiA9PT0gXCJ2YXJpYWJsZXMtY2hhbmdlZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IGluaXRpYWxGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPSBvcHRpb25zLm5leHRGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucywgbmV3TmV0d29ya1N0YXR1cykge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zZXRPYnNlcnZhYmxlUXVlcnkodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5T2JzZXJ2YWJsZSh0aGlzLnF1ZXJ5SWQsIG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5xdWVyeU1hbmFnZXIuc3NyTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBvbGxpbmdJbmZvID0gX2EucG9sbGluZ0luZm8sIHBvbGxJbnRlcnZhbCA9IF9hLm9wdGlvbnMucG9sbEludGVydmFsO1xuICAgICAgICBpZiAoIXBvbGxJbnRlcnZhbCkge1xuICAgICAgICAgICAgaWYgKHBvbGxpbmdJbmZvKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBvbGxpbmdJbmZvLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvbGxpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2xsaW5nSW5mbyAmJlxuICAgICAgICAgICAgcG9sbGluZ0luZm8uaW50ZXJ2YWwgPT09IHBvbGxJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChwb2xsSW50ZXJ2YWwsICdBdHRlbXB0ZWQgdG8gc3RhcnQgYSBwb2xsaW5nIHF1ZXJ5IHdpdGhvdXQgYSBwb2xsaW5nIGludGVydmFsLicpIDogZ2xvYmFscy5pbnZhcmlhbnQocG9sbEludGVydmFsLCAxMCk7XG4gICAgICAgIHZhciBpbmZvID0gcG9sbGluZ0luZm8gfHwgKHRoaXMucG9sbGluZ0luZm8gPSB7fSk7XG4gICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgIHZhciBtYXliZUZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBvbGxpbmdJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQoX3RoaXMucXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogXCJuZXR3b3JrLW9ubHlcIixcbiAgICAgICAgICAgICAgICAgICAgfSwgZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnBvbGwpLnRoZW4ocG9sbCwgcG9sbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gX3RoaXMucG9sbGluZ0luZm87XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmZvLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGluZm8udGltZW91dCA9IHNldFRpbWVvdXQobWF5YmVGZXRjaCwgaW5mby5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBvbGwoKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudXBkYXRlTGFzdFJlc3VsdCA9IGZ1bmN0aW9uIChuZXdSZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdGhpcy5sYXN0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMubGFzdCksIHsgcmVzdWx0OiB0aGlzLnF1ZXJ5TWFuYWdlci5hc3N1bWVJbW11dGFibGVSZXN1bHRzXG4gICAgICAgICAgICAgICAgPyBuZXdSZXN1bHRcbiAgICAgICAgICAgICAgICA6IHV0aWxpdGllcy5jbG9uZURlZXAobmV3UmVzdWx0KSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSk7XG4gICAgICAgIGlmICghdXRpbGl0aWVzLmlzTm9uRW1wdHlBcnJheShuZXdSZXN1bHQuZXJyb3JzKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGFzdC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZW9ic2VydmUgPSBmdW5jdGlvbiAobmV3T3B0aW9ucywgbmV3TmV0d29ya1N0YXR1cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICAgICAgdmFyIHVzZURpc3Bvc2FibGVDb25jYXN0ID0gbmV3TmV0d29ya1N0YXR1cyA9PT0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlZmV0Y2ggfHxcbiAgICAgICAgICAgIG5ld05ldHdvcmtTdGF0dXMgPT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUgfHxcbiAgICAgICAgICAgIG5ld05ldHdvcmtTdGF0dXMgPT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5wb2xsO1xuICAgICAgICB2YXIgb2xkVmFyaWFibGVzID0gdGhpcy5vcHRpb25zLnZhcmlhYmxlcztcbiAgICAgICAgdmFyIG9sZEZldGNoUG9saWN5ID0gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IHV0aWxpdGllcy5jb21wYWN0KHRoaXMub3B0aW9ucywgbmV3T3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdXNlRGlzcG9zYWJsZUNvbmNhc3RcbiAgICAgICAgICAgID8gbWVyZ2VkT3B0aW9uc1xuICAgICAgICAgICAgOiBhc3NpZ24odGhpcy5vcHRpb25zLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgaWYgKCF1c2VEaXNwb3NhYmxlQ29uY2FzdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMudmFyaWFibGVzICYmXG4gICAgICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKG5ld09wdGlvbnMudmFyaWFibGVzLCBvbGRWYXJpYWJsZXMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gXCJzdGFuZGJ5XCIgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZldGNoUG9saWN5ID09PSBvbGRGZXRjaFBvbGljeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlOZXh0RmV0Y2hQb2xpY3koXCJ2YXJpYWJsZXMtY2hhbmdlZFwiLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TmV0d29ya1N0YXR1cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuc2V0VmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFyaWFibGVzID0gb3B0aW9ucy52YXJpYWJsZXMgJiYgdHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMudmFyaWFibGVzKTtcbiAgICAgICAgdmFyIGNvbmNhc3QgPSB0aGlzLmZldGNoKG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0RXJyb3IoZXJyb3IsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXVzZURpc3Bvc2FibGVDb25jYXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25jYXN0ICYmIHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmNhc3QucmVtb3ZlT2JzZXJ2ZXIodGhpcy5vYnNlcnZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbmNhc3QgPSBjb25jYXN0O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbmNhc3QuYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gY29uY2FzdC5wcm9taXNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlcG9ydFJlc3VsdCh0aGlzLmdldEN1cnJlbnRSZXN1bHQoZmFsc2UpLCB0aGlzLnZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlcG9ydFJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgbGFzdEVycm9yID0gdGhpcy5nZXRMYXN0RXJyb3IoKTtcbiAgICAgICAgaWYgKGxhc3RFcnJvciB8fCB0aGlzLmlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGxhc3RFcnJvciB8fCAhcmVzdWx0LnBhcnRpYWwgfHwgdGhpcy5vcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxpdGllcy5pdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KHRoaXMub2JzZXJ2ZXJzLCAnbmV4dCcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5nZXRMYXN0UmVzdWx0KCkpLCB7IGVycm9yOiBlcnJvciwgZXJyb3JzOiBlcnJvci5ncmFwaFFMRXJyb3JzLCBuZXR3b3JrU3RhdHVzOiBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZXJyb3IsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQoZXJyb3JSZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgIHV0aWxpdGllcy5pdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KHRoaXMub2JzZXJ2ZXJzLCAnZXJyb3InLCB0aGlzLmxhc3QuZXJyb3IgPSBlcnJvcik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmhhc09ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNpemUgPiAwO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50ZWFyRG93blF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Rvcm5Eb3duKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jb25jYXN0ICYmIHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uY2FzdC5yZW1vdmVPYnNlcnZlcih0aGlzLm9ic2VydmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmNhc3Q7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLnN0b3BRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVRdWVyeTtcbn0odXRpbGl0aWVzLk9ic2VydmFibGUpKTtcbnV0aWxpdGllcy5maXhPYnNlcnZhYmxlU3ViY2xhc3MoT2JzZXJ2YWJsZVF1ZXJ5KTtcbmZ1bmN0aW9uIHJlb2JzZXJ2ZUNhY2hlRmlyc3Qob2JzUXVlcnkpIHtcbiAgICB2YXIgX2EgPSBvYnNRdWVyeS5vcHRpb25zLCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCBuZXh0RmV0Y2hQb2xpY3kgPSBfYS5uZXh0RmV0Y2hQb2xpY3k7XG4gICAgaWYgKGZldGNoUG9saWN5ID09PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIgfHxcbiAgICAgICAgZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIG9ic1F1ZXJ5LnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICBmZXRjaFBvbGljeTogXCJjYWNoZS1maXJzdFwiLFxuICAgICAgICAgICAgbmV4dEZldGNoUG9saWN5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RmV0Y2hQb2xpY3kgPSBuZXh0RmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEZldGNoUG9saWN5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JzUXVlcnkucmVvYnNlcnZlKCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrKGVycm9yKSB7XG4gICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5lcnJvcignVW5oYW5kbGVkIGVycm9yJywgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xufVxuZnVuY3Rpb24gbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKG1pc3NpbmcpIHtcbiAgICBpZiAoX19ERVZfXyAmJiBtaXNzaW5nKSB7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQuZGVidWcoXCJNaXNzaW5nIGNhY2hlIHJlc3VsdCBmaWVsZHM6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShtaXNzaW5nKSksIG1pc3NpbmcpO1xuICAgIH1cbn1cblxudmFyIExvY2FsU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsU3RhdGUoX2EpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gX2EuY2FjaGUsIGNsaWVudCA9IF9hLmNsaWVudCwgcmVzb2x2ZXJzID0gX2EucmVzb2x2ZXJzLCBmcmFnbWVudE1hdGNoZXIgPSBfYS5mcmFnbWVudE1hdGNoZXI7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVycykge1xuICAgICAgICAgICAgdGhpcy5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmFkZFJlc29sdmVycyA9IGZ1bmN0aW9uIChyZXNvbHZlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSB0aGlzLnJlc29sdmVycyB8fCB7fTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZXJzKSkge1xuICAgICAgICAgICAgcmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlcnMgPSB1dGlsaXRpZXMubWVyZ2VEZWVwKF90aGlzLnJlc29sdmVycywgcmVzb2x2ZXJHcm91cCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJzID0gdXRpbGl0aWVzLm1lcmdlRGVlcCh0aGlzLnJlc29sdmVycywgcmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHt9O1xuICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnMgfHwge307XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5ydW5SZXNvbHZlcnMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQsIHJlbW90ZVJlc3VsdCA9IF9hLnJlbW90ZVJlc3VsdCwgY29udGV4dCA9IF9hLmNvbnRleHQsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2IgPSBfYS5vbmx5UnVuRm9yY2VkUmVzb2x2ZXJzLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlc29sdmVEb2N1bWVudChkb2N1bWVudCwgcmVtb3RlUmVzdWx0LmRhdGEsIGNvbnRleHQsIHZhcmlhYmxlcywgdGhpcy5mcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpLnRoZW4oZnVuY3Rpb24gKGxvY2FsUmVzdWx0KSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHJlbW90ZVJlc3VsdCksIHsgZGF0YTogbG9jYWxSZXN1bHQucmVzdWx0IH0pKTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbW90ZVJlc3VsdF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXRGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRNYXRjaGVyID0gZnJhZ21lbnRNYXRjaGVyO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0RnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudE1hdGNoZXI7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5jbGllbnRRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmhhc0RpcmVjdGl2ZXMoWydjbGllbnQnXSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXJ2ZXJRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLnJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucHJlcGFyZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgZ2V0Q2FjaGVLZXk6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuaWRlbnRpZnkob2JqKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgdmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZXNvbHZlRG9jdW1lbnQoZG9jdW1lbnQsIHRoaXMuYnVpbGRSb290VmFsdWVGcm9tQ2FjaGUoZG9jdW1lbnQsIHZhcmlhYmxlcykgfHwge30sIHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCksIHZhcmlhYmxlcykudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2YXJpYWJsZXMpLCBkYXRhLmV4cG9ydGVkVmFyaWFibGVzKSk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0c2xpYi5fX2Fzc2lnbih7fSwgdmFyaWFibGVzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zaG91bGRGb3JjZVJlc29sdmVycyA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICB2YXIgZm9yY2VSZXNvbHZlcnMgPSBmYWxzZTtcbiAgICAgICAgZ3JhcGhxbC52aXNpdChkb2N1bWVudCwge1xuICAgICAgICAgICAgRGlyZWN0aXZlOiB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUudmFsdWUgPT09ICdjbGllbnQnICYmIG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlc29sdmVycyA9IG5vZGUuYXJndW1lbnRzLnNvbWUoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcubmFtZS52YWx1ZSA9PT0gJ2Fsd2F5cycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy52YWx1ZS52YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyYXBocWwuQlJFQUs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JjZVJlc29sdmVycztcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogdXRpbGl0aWVzLmJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0KGRvY3VtZW50KSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgfSkucmVzdWx0O1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50LCByb290VmFsdWUsIGNvbnRleHQsIHZhcmlhYmxlcywgZnJhZ21lbnRNYXRjaGVyLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHt9OyB9XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICBpZiAoZnJhZ21lbnRNYXRjaGVyID09PSB2b2lkIDApIHsgZnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTsgfVxuICAgICAgICBpZiAob25seVJ1bkZvcmNlZFJlc29sdmVycyA9PT0gdm9pZCAwKSB7IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFpbkRlZmluaXRpb24sIGZyYWdtZW50cywgZnJhZ21lbnRNYXAsIGRlZmluaXRpb25PcGVyYXRpb24sIGRlZmF1bHRPcGVyYXRpb25UeXBlLCBfYSwgY2FjaGUsIGNsaWVudCwgZXhlY0NvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgbWFpbkRlZmluaXRpb24gPSB1dGlsaXRpZXMuZ2V0TWFpbkRlZmluaXRpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50cyA9IHV0aWxpdGllcy5nZXRGcmFnbWVudERlZmluaXRpb25zKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IHV0aWxpdGllcy5jcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25PcGVyYXRpb24gPSBtYWluRGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAub3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcGVyYXRpb25UeXBlID0gZGVmaW5pdGlvbk9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGRlZmluaXRpb25PcGVyYXRpb24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbk9wZXJhdGlvbi5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICA6ICdRdWVyeSc7XG4gICAgICAgICAgICAgICAgX2EgPSB0aGlzLCBjYWNoZSA9IF9hLmNhY2hlLCBjbGllbnQgPSBfYS5jbGllbnQ7XG4gICAgICAgICAgICAgICAgZXhlY0NvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBmcmFnbWVudE1hcCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGU6IGRlZmF1bHRPcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChtYWluRGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJpYWJsZXM6IGV4ZWNDb250ZXh0LmV4cG9ydGVkVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVNlbGVjdGlvblNldCA9IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50TWFwLCBjb250ZXh0LCB2YXJpYWJsZXMsIHJlc3VsdHNUb01lcmdlLCBleGVjdXRlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwLCBjb250ZXh0ID0gZXhlY0NvbnRleHQuY29udGV4dCwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlID0gW3Jvb3RWYWx1ZV07XG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgcmV0dXJuIHRzbGliLl9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50LCB0eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWxpdGllcy5zaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZXNvbHZlRmllbGQoc2VsZWN0aW9uLCByb290VmFsdWUsIGV4ZWNDb250ZXh0KS50aGVuKGZ1bmN0aW9uIChmaWVsZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzVG9NZXJnZS5wdXNoKChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVt1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXSA9IGZpZWxkUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudE1hcFtzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50LCBcIk5vIGZyYWdtZW50IG5hbWVkIFwiLmNvbmNhdChzZWxlY3Rpb24ubmFtZS52YWx1ZSkpIDogZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnQsIDkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlQ29uZGl0aW9uID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbi5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIocm9vdFZhbHVlLCB0eXBlQ29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmcmFnbWVudC5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaChmcmFnbWVudFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBQcm9taXNlLmFsbChzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5tYXAoZXhlY3V0ZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxpdGllcy5tZXJnZURlZXBBcnJheShyZXN1bHRzVG9NZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnJlc29sdmVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgcm9vdFZhbHVlLCBleGVjQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFyaWFibGVzLCBmaWVsZE5hbWUsIGFsaWFzZWRGaWVsZE5hbWUsIGFsaWFzVXNlZCwgZGVmYXVsdFJlc3VsdCwgcmVzdWx0UHJvbWlzZSwgcmVzb2x2ZXJUeXBlLCByZXNvbHZlck1hcCwgcmVzb2x2ZTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZEZpZWxkTmFtZSA9IHV0aWxpdGllcy5yZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICBhbGlhc1VzZWQgPSBmaWVsZE5hbWUgIT09IGFsaWFzZWRGaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFJlc3VsdCA9IHJvb3RWYWx1ZVthbGlhc2VkRmllbGROYW1lXSB8fCByb290VmFsdWVbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGRlZmF1bHRSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICghZXhlY0NvbnRleHQub25seVJ1bkZvcmNlZFJlc29sdmVycyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEZvcmNlUmVzb2x2ZXJzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlclR5cGUgPSByb290VmFsdWUuX190eXBlbmFtZSB8fCBleGVjQ29udGV4dC5kZWZhdWx0T3BlcmF0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJNYXAgPSB0aGlzLnJlc29sdmVycyAmJiB0aGlzLnJlc29sdmVyc1tyZXNvbHZlclR5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXNvbHZlck1hcFthbGlhc1VzZWQgPyBmaWVsZE5hbWUgOiBhbGlhc2VkRmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjYWNoZS5jYWNoZVNsb3Qud2l0aFZhbHVlKHRoaXMuY2FjaGUsIHJlc29sdmUsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsaXRpZXMuYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dC5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGZpZWxkOiBmaWVsZCwgZnJhZ21lbnRNYXA6IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBkZWZhdWx0UmVzdWx0OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ2V4cG9ydCcgJiYgZGlyZWN0aXZlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLm5hbWUudmFsdWUgPT09ICdhcycgJiYgYXJnLnZhbHVlLmtpbmQgPT09ICdTdHJpbmdWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQuZXhwb3J0ZWRWYXJpYWJsZXNbYXJnLnZhbHVlLnZhbHVlXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkoZmllbGQsIHJlc3VsdCwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU2VsZWN0aW9uU2V0KGZpZWxkLnNlbGVjdGlvblNldCwgcmVzdWx0LCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnJlc29sdmVTdWJTZWxlY3RlZEFycmF5ID0gZnVuY3Rpb24gKGZpZWxkLCByZXN1bHQsIGV4ZWNDb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkoZmllbGQsIGl0ZW0sIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmaWVsZC5zZWxlY3Rpb25TZXQsIGl0ZW0sIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsU3RhdGU7XG59KCkpO1xuXG52YXIgZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMgPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrTWFwID8gV2Vha01hcCA6IE1hcCkoKTtcbmZ1bmN0aW9uIHdyYXBEZXN0cnVjdGl2ZUNhY2hlTWV0aG9kKGNhY2hlLCBtZXRob2ROYW1lKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gY2FjaGVbbWV0aG9kTmFtZV07XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhY2hlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuc2V0KGNhY2hlLCAoZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuZ2V0KGNhY2hlKSArIDEpICUgMWUxNSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5jZWxOb3RpZnlUaW1lb3V0KGluZm8pIHtcbiAgICBpZiAoaW5mb1tcIm5vdGlmeVRpbWVvdXRcIl0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluZm9bXCJub3RpZnlUaW1lb3V0XCJdKTtcbiAgICAgICAgaW5mb1tcIm5vdGlmeVRpbWVvdXRcIl0gPSB2b2lkIDA7XG4gICAgfVxufVxudmFyIFF1ZXJ5SW5mbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnlJbmZvKHF1ZXJ5TWFuYWdlciwgcXVlcnlJZCkge1xuICAgICAgICBpZiAocXVlcnlJZCA9PT0gdm9pZCAwKSB7IHF1ZXJ5SWQgPSBxdWVyeU1hbmFnZXIuZ2VuZXJhdGVRdWVyeUlkKCk7IH1cbiAgICAgICAgdGhpcy5xdWVyeUlkID0gcXVlcnlJZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0SWQgPSAxO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZVF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSA9IHF1ZXJ5TWFuYWdlci5jYWNoZTtcbiAgICAgICAgaWYgKCFkZXN0cnVjdGl2ZU1ldGhvZENvdW50cy5oYXMoY2FjaGUpKSB7XG4gICAgICAgICAgICBkZXN0cnVjdGl2ZU1ldGhvZENvdW50cy5zZXQoY2FjaGUsIDApO1xuICAgICAgICAgICAgd3JhcERlc3RydWN0aXZlQ2FjaGVNZXRob2QoY2FjaGUsIFwiZXZpY3RcIik7XG4gICAgICAgICAgICB3cmFwRGVzdHJ1Y3RpdmVDYWNoZU1ldGhvZChjYWNoZSwgXCJtb2RpZnlcIik7XG4gICAgICAgICAgICB3cmFwRGVzdHJ1Y3RpdmVDYWNoZU1ldGhvZChjYWNoZSwgXCJyZXNldFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSBxdWVyeS5uZXR3b3JrU3RhdHVzIHx8IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5sb2FkaW5nO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMgJiZcbiAgICAgICAgICAgIHRoaXMubmV0d29ya1N0YXR1cyAhPT0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmxvYWRpbmcgJiZcbiAgICAgICAgICAgICFlcXVhbGl0eS5lcXVhbCh0aGlzLnZhcmlhYmxlcywgcXVlcnkudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5zZXRWYXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcXVhbGl0eS5lcXVhbChxdWVyeS52YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RGlmZiA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeS5kb2N1bWVudCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnkudmFyaWFibGVzLFxuICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBudWxsLFxuICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogdGhpcy5ncmFwaFFMRXJyb3JzIHx8IFtdLFxuICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChxdWVyeS5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T2JzZXJ2YWJsZVF1ZXJ5KHF1ZXJ5Lm9ic2VydmFibGVRdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5Lmxhc3RSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlcXVlc3RJZCA9IHF1ZXJ5Lmxhc3RSZXF1ZXN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxOb3RpZnlUaW1lb3V0KHRoaXMpO1xuICAgICAgICB0aGlzLmxhc3REaWZmID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB0aGlzLnZhcmlhYmxlczsgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0RGlmZk9wdGlvbnModmFyaWFibGVzKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdERpZmYgJiYgZXF1YWxpdHkuZXF1YWwob3B0aW9ucywgdGhpcy5sYXN0RGlmZi5vcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdERpZmYuZGlmZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVdhdGNoKHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIG9xID0gdGhpcy5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgIGlmIChvcSAmJiBvcS5vcHRpb25zLmZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBsZXRlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWZmID0gdGhpcy5jYWNoZS5kaWZmKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhc3REaWZmKGRpZmYsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUudXBkYXRlTGFzdERpZmYgPSBmdW5jdGlvbiAoZGlmZiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxhc3REaWZmID0gZGlmZiA/IHtcbiAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHRoaXMuZ2V0RGlmZk9wdGlvbnMoKSxcbiAgICAgICAgfSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuZ2V0RGlmZk9wdGlvbnMgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhcmlhYmxlcyA9PT0gdm9pZCAwKSB7IHZhcmlhYmxlcyA9IHRoaXMudmFyaWFibGVzOyB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiB0cnVlLFxuICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiAoX2EgPSB0aGlzLm9ic2VydmFibGVRdWVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnMuY2Fub25pemVSZXN1bHRzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5zZXREaWZmID0gZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9sZERpZmYgPSB0aGlzLmxhc3REaWZmICYmIHRoaXMubGFzdERpZmYuZGlmZjtcbiAgICAgICAgdGhpcy51cGRhdGVMYXN0RGlmZihkaWZmKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5ICYmXG4gICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwob2xkRGlmZiAmJiBvbGREaWZmLnJlc3VsdCwgZGlmZiAmJiBkaWZmLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vdGlmeVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm5vdGlmeSgpOyB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5zZXRPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAob3EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9xID09PSB0aGlzLm9ic2VydmFibGVRdWVyeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMub3FMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKHRoaXMub3FMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlUXVlcnkgPSBvcTtcbiAgICAgICAgaWYgKG9xKSB7XG4gICAgICAgICAgICBvcVtcInF1ZXJ5SW5mb1wiXSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5hZGQodGhpcy5vcUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gX3RoaXMuZ2V0RGlmZigpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmZyb21PcHRpbWlzdGljVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb3FbXCJvYnNlcnZlXCJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW9ic2VydmVDYWNoZUZpcnN0KG9xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9xTGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjYW5jZWxOb3RpZnlUaW1lb3V0KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGROb3RpZnkoKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKF90aGlzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5zaG91bGROb3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSB8fCAhdGhpcy5saXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQodGhpcy5uZXR3b3JrU3RhdHVzKSAmJlxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaFBvbGljeSA9IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09IFwiY2FjaGUtb25seVwiICYmXG4gICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3kgIT09IFwiY2FjaGUtYW5kLW5ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwgPSBRdWVyeUluZm8ucHJvdG90eXBlLmNhbmNlbDtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgICAgIHZhciBvcSA9IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgaWYgKG9xKVxuICAgICAgICAgICAgICAgIG9xLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUudXBkYXRlV2F0Y2ggPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB0aGlzLnZhcmlhYmxlczsgfVxuICAgICAgICB2YXIgb3EgPSB0aGlzLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgaWYgKG9xICYmIG9xLm9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YXRjaE9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5nZXREaWZmT3B0aW9ucyh2YXJpYWJsZXMpKSwgeyB3YXRjaGVyOiB0aGlzLCBjYWxsYmFjazogZnVuY3Rpb24gKGRpZmYpIHsgcmV0dXJuIF90aGlzLnNldERpZmYoZGlmZik7IH0gfSk7XG4gICAgICAgIGlmICghdGhpcy5sYXN0V2F0Y2ggfHxcbiAgICAgICAgICAgICFlcXVhbGl0eS5lcXVhbCh3YXRjaE9wdGlvbnMsIHRoaXMubGFzdFdhdGNoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gdGhpcy5jYWNoZS53YXRjaCh0aGlzLmxhc3RXYXRjaCA9IHdhdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUucmVzZXRMYXN0V3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdFdyaXRlID0gdm9pZCAwO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5zaG91bGRXcml0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgbGFzdFdyaXRlID0gdGhpcy5sYXN0V3JpdGU7XG4gICAgICAgIHJldHVybiAhKGxhc3RXcml0ZSAmJlxuICAgICAgICAgICAgbGFzdFdyaXRlLmRtQ291bnQgPT09IGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLmdldCh0aGlzLmNhY2hlKSAmJlxuICAgICAgICAgICAgZXF1YWxpdHkuZXF1YWwodmFyaWFibGVzLCBsYXN0V3JpdGUudmFyaWFibGVzKSAmJlxuICAgICAgICAgICAgZXF1YWxpdHkuZXF1YWwocmVzdWx0LmRhdGEsIGxhc3RXcml0ZS5yZXN1bHQuZGF0YSkpO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5tYXJrUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgb3B0aW9ucywgY2FjaGVXcml0ZUJlaGF2aW9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ3JhcGhRTEVycm9ycyA9IHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkocmVzdWx0LmVycm9ycykgPyByZXN1bHQuZXJyb3JzIDogW107XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduby1jYWNoZScpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdERpZmYoeyByZXN1bHQ6IHJlc3VsdC5kYXRhLCBjb21wbGV0ZTogdHJ1ZSB9LCB0aGlzLmdldERpZmZPcHRpb25zKG9wdGlvbnMudmFyaWFibGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FjaGVXcml0ZUJlaGF2aW9yICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV3JpdGVSZXN1bHQocmVzdWx0LCBvcHRpb25zLmVycm9yUG9saWN5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUucGVyZm9ybVRyYW5zYWN0aW9uKGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2hvdWxkV3JpdGUocmVzdWx0LCBvcHRpb25zLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLndyaXRlUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBfdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZTogY2FjaGVXcml0ZUJlaGF2aW9yID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0V3JpdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbUNvdW50OiBkZXN0cnVjdGl2ZU1ldGhvZENvdW50cy5nZXQoX3RoaXMuY2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0RGlmZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3REaWZmLmRpZmYuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IF90aGlzLmxhc3REaWZmLmRpZmYucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZk9wdGlvbnMgPSBfdGhpcy5nZXREaWZmT3B0aW9ucyhvcHRpb25zLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2FjaGUuZGlmZihkaWZmT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlV2F0Y2gob3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3REaWZmKGRpZmYsIGRpZmZPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGlmZi5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFdyaXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLm1hcmtSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrRXJyb3IgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5tYXJrRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICB0aGlzLmxhc3RXcml0ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBpZiAoZXJyb3IuZ3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFFMRXJyb3JzID0gZXJyb3IuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IubmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtFcnJvciA9IGVycm9yLm5ldHdvcmtFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlJbmZvO1xufSgpKTtcbmZ1bmN0aW9uIHNob3VsZFdyaXRlUmVzdWx0KHJlc3VsdCwgZXJyb3JQb2xpY3kpIHtcbiAgICBpZiAoZXJyb3JQb2xpY3kgPT09IHZvaWQgMCkgeyBlcnJvclBvbGljeSA9IFwibm9uZVwiOyB9XG4gICAgdmFyIGlnbm9yZUVycm9ycyA9IGVycm9yUG9saWN5ID09PSBcImlnbm9yZVwiIHx8XG4gICAgICAgIGVycm9yUG9saWN5ID09PSBcImFsbFwiO1xuICAgIHZhciB3cml0ZVdpdGhFcnJvcnMgPSAhdXRpbGl0aWVzLmdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpO1xuICAgIGlmICghd3JpdGVXaXRoRXJyb3JzICYmIGlnbm9yZUVycm9ycyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICB3cml0ZVdpdGhFcnJvcnMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVXaXRoRXJyb3JzO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFF1ZXJ5TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnlNYW5hZ2VyKF9hKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IF9hLmNhY2hlLCBsaW5rID0gX2EubGluaywgZGVmYXVsdE9wdGlvbnMgPSBfYS5kZWZhdWx0T3B0aW9ucywgX2IgPSBfYS5xdWVyeURlZHVwbGljYXRpb24sIHF1ZXJ5RGVkdXBsaWNhdGlvbiA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBvbkJyb2FkY2FzdCA9IF9hLm9uQnJvYWRjYXN0LCBfYyA9IF9hLnNzck1vZGUsIHNzck1vZGUgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5jbGllbnRBd2FyZW5lc3MsIGNsaWVudEF3YXJlbmVzcyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBsb2NhbFN0YXRlID0gX2EubG9jYWxTdGF0ZSwgYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA9IF9hLmFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgICAgIHRoaXMuY2xpZW50QXdhcmVuZXNzID0ge307XG4gICAgICAgIHRoaXMucXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYWNoZSA9IG5ldyAodXRpbGl0aWVzLmNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgICAgICB0aGlzLnF1ZXJ5SWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbklkQ291bnRlciA9IDE7XG4gICAgICAgIHRoaXMuaW5GbGlnaHRMaW5rT2JzZXJ2YWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucXVlcnlEZWR1cGxpY2F0aW9uID0gcXVlcnlEZWR1cGxpY2F0aW9uO1xuICAgICAgICB0aGlzLmNsaWVudEF3YXJlbmVzcyA9IGNsaWVudEF3YXJlbmVzcztcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbG9jYWxTdGF0ZSB8fCBuZXcgTG9jYWxTdGF0ZSh7IGNhY2hlOiBjYWNoZSB9KTtcbiAgICAgICAgdGhpcy5zc3JNb2RlID0gc3NyTW9kZTtcbiAgICAgICAgdGhpcy5hc3N1bWVJbW11dGFibGVSZXN1bHRzID0gISFhc3N1bWVJbW11dGFibGVSZXN1bHRzO1xuICAgICAgICBpZiAoKHRoaXMub25Ccm9hZGNhc3QgPSBvbkJyb2FkY2FzdCkpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2luZm8sIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIF90aGlzLnN0b3BRdWVyeU5vQnJvYWRjYXN0KHF1ZXJ5SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nRmV0Y2hlcyhfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoJ1F1ZXJ5TWFuYWdlciBzdG9wcGVkIHdoaWxlIHF1ZXJ5IHdhcyBpbiBmbGlnaHQnKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDExKSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFBlbmRpbmdGZXRjaGVzID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hDYW5jZWxGbnMuZm9yRWFjaChmdW5jdGlvbiAoY2FuY2VsKSB7IHJldHVybiBjYW5jZWwoZXJyb3IpOyB9KTtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5jbGVhcigpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgdmFyIG11dGF0aW9uID0gX2EubXV0YXRpb24sIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgb3B0aW1pc3RpY1Jlc3BvbnNlID0gX2Eub3B0aW1pc3RpY1Jlc3BvbnNlLCB1cGRhdGVRdWVyaWVzID0gX2EudXBkYXRlUXVlcmllcywgX2QgPSBfYS5yZWZldGNoUXVlcmllcywgcmVmZXRjaFF1ZXJpZXMgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCwgX2UgPSBfYS5hd2FpdFJlZmV0Y2hRdWVyaWVzLCBhd2FpdFJlZmV0Y2hRdWVyaWVzID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIHVwZGF0ZVdpdGhQcm94eUZuID0gX2EudXBkYXRlLCBvblF1ZXJ5VXBkYXRlZCA9IF9hLm9uUXVlcnlVcGRhdGVkLCBfZiA9IF9hLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9mID09PSB2b2lkIDAgPyAoKF9iID0gdGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mZXRjaFBvbGljeSkgfHwgXCJuZXR3b3JrLW9ubHlcIiA6IF9mLCBfZyA9IF9hLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9nID09PSB2b2lkIDAgPyAoKF9jID0gdGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lcnJvclBvbGljeSkgfHwgXCJub25lXCIgOiBfZywga2VlcFJvb3RGaWVsZHMgPSBfYS5rZWVwUm9vdEZpZWxkcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbklkLCBtdXRhdGlvblN0b3JlVmFsdWUsIHNlbGY7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfaC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQobXV0YXRpb24sICdtdXRhdGlvbiBvcHRpb24gaXMgcmVxdWlyZWQuIFlvdSBtdXN0IHNwZWNpZnkgeW91ciBHcmFwaFFMIGRvY3VtZW50IGluIHRoZSBtdXRhdGlvbiBvcHRpb24uJykgOiBnbG9iYWxzLmludmFyaWFudChtdXRhdGlvbiwgMTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnLCBcIk11dGF0aW9ucyBzdXBwb3J0IG9ubHkgJ25ldHdvcmstb25seScgb3IgJ25vLWNhY2hlJyBmZXRjaFBvbGljeSBzdHJpbmdzLiBUaGUgZGVmYXVsdCBgbmV0d29yay1vbmx5YCBiZWhhdmlvciBhdXRvbWF0aWNhbGx5IHdyaXRlcyBtdXRhdGlvbiByZXN1bHRzIHRvIHRoZSBjYWNoZS4gUGFzc2luZyBgbm8tY2FjaGVgIHNraXBzIHRoZSBjYWNoZSB3cml0ZS5cIikgOiBnbG9iYWxzLmludmFyaWFudChmZXRjaFBvbGljeSA9PT0gJ25ldHdvcmstb25seScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJywgMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZCA9IHRoaXMuZ2VuZXJhdGVNdXRhdGlvbklkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IHRoaXMudHJhbnNmb3JtKG11dGF0aW9uKS5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybShtdXRhdGlvbikuaGFzQ2xpZW50RXhwb3J0cykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5sb2NhbFN0YXRlLmFkZEV4cG9ydGVkVmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gKF9oLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uU3RvcmVWYWx1ZSA9IHRoaXMubXV0YXRpb25TdG9yZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm11dGF0aW9uU3RvcmVbbXV0YXRpb25JZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiBtdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGltaXN0aWNSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya011dGF0aW9uT3B0aW1pc3RpYyhvcHRpbWlzdGljUmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZDogbXV0YXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IHVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlV2l0aFByb3h5Rm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBSb290RmllbGRzOiBrZWVwUm9vdEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxpdGllcy5hc3luY01hcChzZWxmLmdldE9ic2VydmFibGVGcm9tTGluayhtdXRhdGlvbiwgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IG9wdGltaXN0aWNSZXNwb25zZTogb3B0aW1pc3RpY1Jlc3BvbnNlIH0pLCB2YXJpYWJsZXMsIGZhbHNlKSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5ncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSAmJiBlcnJvclBvbGljeSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BcG9sbG9FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25TdG9yZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25TdG9yZVZhbHVlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlUmVzdWx0ID0gdHNsaWIuX19hc3NpZ24oe30sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmV0Y2hRdWVyaWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZldGNoUXVlcmllcyA9IHJlZmV0Y2hRdWVyaWVzKHN0b3JlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvclBvbGljeSA9PT0gJ2lnbm9yZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsaXRpZXMuZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHN0b3JlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVJlc3VsdC5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5tYXJrTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBzdG9yZVJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogbXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUG9saWN5OiBlcnJvclBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlV2l0aFByb3h5Rm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUXVlcmllczogdXBkYXRlUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdFJlZmV0Y2hRdWVyaWVzOiBhd2FpdFJlZmV0Y2hRdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyaWVzOiByZWZldGNoUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPcHRpbWlzdGljOiBvcHRpbWlzdGljUmVzcG9uc2UgPyBtdXRhdGlvbklkIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVlcnlVcGRhdGVkOiBvblF1ZXJ5VXBkYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwUm9vdEZpZWxkczoga2VlcFJvb3RGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChzdG9yZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uU3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpbWlzdGljUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZS5yZW1vdmVPcHRpbWlzdGljKG11dGF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyIGluc3RhbmNlb2YgZXJyb3JzLkFwb2xsb0Vycm9yID8gZXJyIDogbmV3IGVycm9ycy5BcG9sbG9FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLm1hcmtNdXRhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChtdXRhdGlvbiwgY2FjaGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNhY2hlID09PSB2b2lkIDApIHsgY2FjaGUgPSB0aGlzLmNhY2hlOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBtdXRhdGlvbi5yZXN1bHQ7XG4gICAgICAgIHZhciBjYWNoZVdyaXRlcyA9IFtdO1xuICAgICAgICB2YXIgc2tpcENhY2hlID0gbXV0YXRpb24uZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIjtcbiAgICAgICAgaWYgKCFza2lwQ2FjaGUgJiYgc2hvdWxkV3JpdGVSZXN1bHQocmVzdWx0LCBtdXRhdGlvbi5lcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgIGNhY2hlV3JpdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9NVVRBVElPTicsXG4gICAgICAgICAgICAgICAgcXVlcnk6IG11dGF0aW9uLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogbXV0YXRpb24udmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVlcmllc18xID0gbXV0YXRpb24udXBkYXRlUXVlcmllcztcbiAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyaWVzXzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGVRdWVyeSA9IF9hLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5TmFtZSA9IG9ic2VydmFibGVRdWVyeSAmJiBvYnNlcnZhYmxlUXVlcnkucXVlcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5TmFtZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVRdWVyaWVzXzEsIHF1ZXJ5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlciA9IHVwZGF0ZVF1ZXJpZXNfMVtxdWVyeU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKSwgZG9jdW1lbnQgPSBfYi5kb2N1bWVudCwgdmFyaWFibGVzID0gX2IudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBjYWNoZS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIGN1cnJlbnRRdWVyeVJlc3VsdCA9IF9jLnJlc3VsdCwgY29tcGxldGUgPSBfYy5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlICYmIGN1cnJlbnRRdWVyeVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRRdWVyeVJlc3VsdCA9IHVwZGF0ZXIoY3VycmVudFF1ZXJ5UmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25SZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWU6IGRvY3VtZW50ICYmIHV0aWxpdGllcy5nZXRPcGVyYXRpb25OYW1lKGRvY3VtZW50KSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlWYXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRRdWVyeVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlV3JpdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG5leHRRdWVyeVJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVXcml0ZXMubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgbXV0YXRpb24ucmVmZXRjaFF1ZXJpZXMgfHxcbiAgICAgICAgICAgIG11dGF0aW9uLnVwZGF0ZSB8fFxuICAgICAgICAgICAgbXV0YXRpb24ub25RdWVyeVVwZGF0ZWQgfHxcbiAgICAgICAgICAgIG11dGF0aW9uLnJlbW92ZU9wdGltaXN0aWMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzXzEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucmVmZXRjaFF1ZXJpZXMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhY2hlOiBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlV3JpdGVzLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlKSB7IHJldHVybiBjYWNoZS53cml0ZSh3cml0ZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBtdXRhdGlvbi51cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjYWNoZS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiUk9PVF9NVVRBVElPTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogX3RoaXMudHJhbnNmb3JtKG11dGF0aW9uLmRvY3VtZW50KS5hc1F1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCByZXN1bHQpLCB7IGRhdGE6IGRpZmYucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZShjYWNoZSwgcmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbXV0YXRpb24uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhY2hlICYmICFtdXRhdGlvbi5rZWVwUm9vdEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubW9kaWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ1JPT1RfTVVUQVRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gX2EuZmllbGROYW1lLCBERUxFVEUgPSBfYS5ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWUgPT09IFwiX190eXBlbmFtZVwiID8gdmFsdWUgOiBERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiBtdXRhdGlvbi5yZWZldGNoUXVlcmllcyxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW1vdmVPcHRpbWlzdGljOiBtdXRhdGlvbi5yZW1vdmVPcHRpbWlzdGljLFxuICAgICAgICAgICAgICAgIG9uUXVlcnlVcGRhdGVkOiBtdXRhdGlvbi5vblF1ZXJ5VXBkYXRlZCB8fCBudWxsLFxuICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHRzXzEucHVzaChyZXN1bHQpOyB9KTtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5hd2FpdFJlZmV0Y2hRdWVyaWVzIHx8IG11dGF0aW9uLm9uUXVlcnlVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHNfMSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUubWFya011dGF0aW9uT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChvcHRpbWlzdGljUmVzcG9uc2UsIG11dGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdHlwZW9mIG9wdGltaXN0aWNSZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IG9wdGltaXN0aWNSZXNwb25zZShtdXRhdGlvbi52YXJpYWJsZXMpXG4gICAgICAgICAgICA6IG9wdGltaXN0aWNSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVjb3JkT3B0aW1pc3RpY1RyYW5zYWN0aW9uKGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXJrTXV0YXRpb25SZXN1bHQodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG11dGF0aW9uKSwgeyByZXN1bHQ6IHsgZGF0YTogZGF0YSB9IH0pLCBjYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50LmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbXV0YXRpb24ubXV0YXRpb25JZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmZldGNoUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgbmV0d29ya1N0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFF1ZXJ5T2JzZXJ2YWJsZShxdWVyeUlkLCBvcHRpb25zLCBuZXR3b3JrU3RhdHVzKS5wcm9taXNlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRRdWVyeVN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbywgcXVlcnlJZCkge1xuICAgICAgICAgICAgc3RvcmVbcXVlcnlJZF0gPSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBpbmZvLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBpbmZvLm5ldHdvcmtTdGF0dXMsXG4gICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBpbmZvLm5ldHdvcmtFcnJvcixcbiAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBpbmZvLmdyYXBoUUxFcnJvcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEVycm9ycyA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHZhciBxdWVyeUluZm8gPSB0aGlzLnF1ZXJpZXMuZ2V0KHF1ZXJ5SWQpO1xuICAgICAgICBpZiAocXVlcnlJbmZvKSB7XG4gICAgICAgICAgICBxdWVyeUluZm8ubmV0d29ya0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcXVlcnlJbmZvLmdyYXBoUUxFcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybUNhY2hlID0gdGhpcy50cmFuc2Zvcm1DYWNoZTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1DYWNoZS5oYXMoZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0aGlzLmNhY2hlLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHZhciBmb3JMaW5rID0gdXRpbGl0aWVzLnJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQodGhpcy5jYWNoZS50cmFuc2Zvcm1Gb3JMaW5rKHRyYW5zZm9ybWVkKSk7XG4gICAgICAgICAgICB2YXIgY2xpZW50UXVlcnkgPSB0aGlzLmxvY2FsU3RhdGUuY2xpZW50UXVlcnkodHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgdmFyIHNlcnZlclF1ZXJ5ID0gZm9yTGluayAmJiB0aGlzLmxvY2FsU3RhdGUuc2VydmVyUXVlcnkoZm9yTGluayk7XG4gICAgICAgICAgICB2YXIgY2FjaGVFbnRyeV8xID0ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiB0cmFuc2Zvcm1lZCxcbiAgICAgICAgICAgICAgICBoYXNDbGllbnRFeHBvcnRzOiB1dGlsaXRpZXMuaGFzQ2xpZW50RXhwb3J0cyh0cmFuc2Zvcm1lZCksXG4gICAgICAgICAgICAgICAgaGFzRm9yY2VkUmVzb2x2ZXJzOiB0aGlzLmxvY2FsU3RhdGUuc2hvdWxkRm9yY2VSZXNvbHZlcnModHJhbnNmb3JtZWQpLFxuICAgICAgICAgICAgICAgIGNsaWVudFF1ZXJ5OiBjbGllbnRRdWVyeSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJRdWVyeTogc2VydmVyUXVlcnksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhcnM6IHV0aWxpdGllcy5nZXREZWZhdWx0VmFsdWVzKHV0aWxpdGllcy5nZXRPcGVyYXRpb25EZWZpbml0aW9uKHRyYW5zZm9ybWVkKSksXG4gICAgICAgICAgICAgICAgYXNRdWVyeTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRyYW5zZm9ybWVkKSwgeyBkZWZpbml0aW9uczogdHJhbnNmb3JtZWQuZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYub3BlcmF0aW9uICE9PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGRlZiksIHsgb3BlcmF0aW9uOiBcInF1ZXJ5XCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICAgICAgICAgICAgICB9KSB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYyAmJiAhdHJhbnNmb3JtQ2FjaGUuaGFzKGRvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KGRvYywgY2FjaGVFbnRyeV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGFkZCh0cmFuc2Zvcm1lZCk7XG4gICAgICAgICAgICBhZGQoY2xpZW50UXVlcnkpO1xuICAgICAgICAgICAgYWRkKHNlcnZlclF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KGRvY3VtZW50KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFibGVzID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnRyYW5zZm9ybShkb2N1bWVudCkuZGVmYXVsdFZhcnMpLCB2YXJpYWJsZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS53YXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyB2YXJpYWJsZXM6IHRoaXMuZ2V0VmFyaWFibGVzKG9wdGlvbnMucXVlcnksIG9wdGlvbnMudmFyaWFibGVzKSB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5SW5mbyA9IG5ldyBRdWVyeUluZm8odGhpcyk7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVRdWVyeSh7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXI6IHRoaXMsXG4gICAgICAgICAgICBxdWVyeUluZm86IHF1ZXJ5SW5mbyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuc2V0KG9ic2VydmFibGUucXVlcnlJZCwgcXVlcnlJbmZvKTtcbiAgICAgICAgcXVlcnlJbmZvLmluaXQoe1xuICAgICAgICAgICAgZG9jdW1lbnQ6IG9ic2VydmFibGUucXVlcnksXG4gICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnk6IG9ic2VydmFibGUsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9ic2VydmFibGUudmFyaWFibGVzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHF1ZXJ5SWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHF1ZXJ5SWQgPT09IHZvaWQgMCkgeyBxdWVyeUlkID0gdGhpcy5nZW5lcmF0ZVF1ZXJ5SWQoKTsgfVxuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5xdWVyeSwgJ3F1ZXJ5IG9wdGlvbiBpcyByZXF1aXJlZC4gWW91IG11c3Qgc3BlY2lmeSB5b3VyIEdyYXBoUUwgZG9jdW1lbnQgJyArXG4gICAgICAgICAgICAnaW4gdGhlIHF1ZXJ5IG9wdGlvbi4nKSA6IGdsb2JhbHMuaW52YXJpYW50KG9wdGlvbnMucXVlcnksIDE0KTtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KG9wdGlvbnMucXVlcnkua2luZCA9PT0gJ0RvY3VtZW50JywgJ1lvdSBtdXN0IHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFwiZ3FsXCIgdGFnLicpIDogZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5xdWVyeS5raW5kID09PSAnRG9jdW1lbnQnLCAxNSk7XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghb3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSwgJ3JldHVyblBhcnRpYWxEYXRhIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpIDogZ2xvYmFscy5pbnZhcmlhbnQoIW9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIDE2KTtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KCFvcHRpb25zLnBvbGxJbnRlcnZhbCwgJ3BvbGxJbnRlcnZhbCBvcHRpb24gb25seSBzdXBwb3J0ZWQgb24gd2F0Y2hRdWVyeS4nKSA6IGdsb2JhbHMuaW52YXJpYW50KCFvcHRpb25zLnBvbGxJbnRlcnZhbCwgMTcpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFF1ZXJ5KHF1ZXJ5SWQsIG9wdGlvbnMpLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RvcFF1ZXJ5KHF1ZXJ5SWQpOyB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMucXVlcnlJZENvdW50ZXIrKyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlUmVxdWVzdElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SWRDb3VudGVyKys7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlTXV0YXRpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLm11dGF0aW9uSWRDb3VudGVyKyspO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbylcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5zdG9wKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmNsZWFyU3RvcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkaXNjYXJkV2F0Y2hlczogdHJ1ZSxcbiAgICAgICAgfTsgfVxuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdGZXRjaGVzKF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcignU3RvcmUgcmVzZXQgd2hpbGUgcXVlcnkgd2FzIGluIGZsaWdodCAobm90IGNvbXBsZXRlZCBpbiBsaW5rIGNoYWluKScpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoMTgpKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SW5mbykge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5SW5mby5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5sb2FkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uU3RvcmUpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVzZXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldE9ic2VydmFibGVRdWVyaWVzID0gZnVuY3Rpb24gKGluY2x1ZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluY2x1ZGUgPT09IHZvaWQgMCkgeyBpbmNsdWRlID0gXCJhY3RpdmVcIjsgfVxuICAgICAgICB2YXIgcXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHF1ZXJ5TmFtZXNBbmREb2NzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbGVnYWN5UXVlcnlPcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNsdWRlKSkge1xuICAgICAgICAgICAgaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5TmFtZXNBbmREb2NzLnNldChkZXNjLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxpdGllcy5pc0RvY3VtZW50Tm9kZShkZXNjKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5zZXQoX3RoaXMudHJhbnNmb3JtKGRlc2MpLmRvY3VtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QoZGVzYykgJiYgZGVzYy5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICBsZWdhY3lRdWVyeU9wdGlvbnMuYWRkKGRlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgcXVlcnlJZCkge1xuICAgICAgICAgICAgdmFyIG9xID0gX2Eub2JzZXJ2YWJsZVF1ZXJ5LCBkb2N1bWVudCA9IF9hLmRvY3VtZW50O1xuICAgICAgICAgICAgaWYgKG9xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcy5zZXQocXVlcnlJZCwgb3EpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBxdWVyeU5hbWUgPSBvcS5xdWVyeU5hbWUsIGZldGNoUG9saWN5ID0gb3Eub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChpbmNsdWRlID09PSBcImFjdGl2ZVwiICYmICFvcS5oYXNPYnNlcnZlcnMoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZSA9PT0gXCJhY3RpdmVcIiB8fFxuICAgICAgICAgICAgICAgICAgICAocXVlcnlOYW1lICYmIHF1ZXJ5TmFtZXNBbmREb2NzLmhhcyhxdWVyeU5hbWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQgJiYgcXVlcnlOYW1lc0FuZERvY3MuaGFzKGRvY3VtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcy5zZXQocXVlcnlJZCwgb3EpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lc0FuZERvY3Muc2V0KHF1ZXJ5TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TmFtZXNBbmREb2NzLnNldChkb2N1bWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxlZ2FjeVF1ZXJ5T3B0aW9ucy5zaXplKSB7XG4gICAgICAgICAgICBsZWdhY3lRdWVyeU9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeUlkID0gdXRpbGl0aWVzLm1ha2VVbmlxdWVJZChcImxlZ2FjeU9uZVRpbWVRdWVyeVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlJbmZvID0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkuaW5pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBvcSA9IG5ldyBPYnNlcnZhYmxlUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeU1hbmFnZXI6IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeUluZm86IHF1ZXJ5SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiBcIm5ldHdvcmstb25seVwiIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdsb2JhbHMuaW52YXJpYW50KG9xLnF1ZXJ5SWQgPT09IHF1ZXJ5SWQpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5zZXRPYnNlcnZhYmxlUXVlcnkob3EpO1xuICAgICAgICAgICAgICAgIHF1ZXJpZXMuc2V0KHF1ZXJ5SWQsIG9xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fICYmIHF1ZXJ5TmFtZXNBbmREb2NzLnNpemUpIHtcbiAgICAgICAgICAgIHF1ZXJ5TmFtZXNBbmREb2NzLmZvckVhY2goZnVuY3Rpb24gKGluY2x1ZGVkLCBuYW1lT3JEb2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIlVua25vd24gcXVlcnkgXCIuY29uY2F0KHR5cGVvZiBuYW1lT3JEb2MgPT09IFwic3RyaW5nXCIgPyBcIm5hbWVkIFwiIDogXCJcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG5hbWVPckRvYywgbnVsbCwgMiksIFwiIHJlcXVlc3RlZCBpbiByZWZldGNoUXVlcmllcyBvcHRpb25zLmluY2x1ZGUgYXJyYXlcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyaWVzO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVN0YW5kYnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluY2x1ZGVTdGFuZGJ5ID09PSB2b2lkIDApIHsgaW5jbHVkZVN0YW5kYnkgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlU3RhbmRieSA/IFwiYWxsXCIgOiBcImFjdGl2ZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnksIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9ic2VydmFibGVRdWVyeS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5LnJlc2V0TGFzdFJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlU3RhbmRieSB8fFxuICAgICAgICAgICAgICAgIChmZXRjaFBvbGljeSAhPT0gXCJzdGFuZGJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3kgIT09IFwiY2FjaGUtb25seVwiKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeVByb21pc2VzLnB1c2gob2JzZXJ2YWJsZVF1ZXJ5LnJlZmV0Y2goKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zZXREaWZmKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvYnNlcnZhYmxlUXVlcnlQcm9taXNlcyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnNldE9ic2VydmFibGVRdWVyeSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgdGhpcy5nZXRRdWVyeShvYnNlcnZhYmxlUXVlcnkucXVlcnlJZCkuc2V0T2JzZXJ2YWJsZVF1ZXJ5KG9ic2VydmFibGVRdWVyeSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgZXJyb3JQb2xpY3kgPSBfYS5lcnJvclBvbGljeSwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBfYiA9IF9hLmNvbnRleHQsIGNvbnRleHQgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgICAgICAgcXVlcnkgPSB0aGlzLnRyYW5zZm9ybShxdWVyeSkuZG9jdW1lbnQ7XG4gICAgICAgIHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKHF1ZXJ5LCB2YXJpYWJsZXMpO1xuICAgICAgICB2YXIgbWFrZU9ic2VydmFibGUgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0T2JzZXJ2YWJsZUZyb21MaW5rKHF1ZXJ5LCBjb250ZXh0LCB2YXJpYWJsZXMpLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ICE9PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRXcml0ZVJlc3VsdChyZXN1bHQsIGVycm9yUG9saWN5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGUud3JpdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJZDogJ1JPT1RfU1VCU0NSSVBUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5ncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybShxdWVyeSkuaGFzQ2xpZW50RXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGVQcm9taXNlXzEgPSB0aGlzLmxvY2FsU3RhdGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMocXVlcnksIHZhcmlhYmxlcywgY29udGV4dCkudGhlbihtYWtlT2JzZXJ2YWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHV0aWxpdGllcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGVQcm9taXNlXzEudGhlbihmdW5jdGlvbiAob2JzZXJ2YWJsZSkgeyByZXR1cm4gc3ViID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpOyB9LCBvYnNlcnZlci5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YiAmJiBzdWIudW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlT2JzZXJ2YWJsZSh2YXJpYWJsZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLnN0b3BRdWVyeU5vQnJvYWRjYXN0KHF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLnN0b3BRdWVyeUluU3RvcmVOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVRdWVyeShxdWVyeUlkKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLmZldGNoQ2FuY2VsRm5zLmRlbGV0ZShxdWVyeUlkKTtcbiAgICAgICAgaWYgKHRoaXMucXVlcmllcy5oYXMocXVlcnlJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UXVlcnkocXVlcnlJZCkuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5xdWVyaWVzLmRlbGV0ZShxdWVyeUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5icm9hZGNhc3RRdWVyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vbkJyb2FkY2FzdClcbiAgICAgICAgICAgIHRoaXMub25Ccm9hZGNhc3QoKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8ubm90aWZ5KCk7IH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRMb2NhbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRPYnNlcnZhYmxlRnJvbUxpbmsgPSBmdW5jdGlvbiAocXVlcnksIGNvbnRleHQsIHZhcmlhYmxlcywgZGVkdXBsaWNhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkZWR1cGxpY2F0aW9uID09PSB2b2lkIDApIHsgZGVkdXBsaWNhdGlvbiA9IChfYSA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5xdWVyeURlZHVwbGljYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucXVlcnlEZWR1cGxpY2F0aW9uOyB9XG4gICAgICAgIHZhciBvYnNlcnZhYmxlO1xuICAgICAgICB2YXIgc2VydmVyUXVlcnkgPSB0aGlzLnRyYW5zZm9ybShxdWVyeSkuc2VydmVyUXVlcnk7XG4gICAgICAgIGlmIChzZXJ2ZXJRdWVyeSkge1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcywgaW5GbGlnaHRMaW5rT2JzZXJ2YWJsZXNfMSA9IF9iLmluRmxpZ2h0TGlua09ic2VydmFibGVzLCBsaW5rID0gX2IubGluaztcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHNlcnZlclF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IHV0aWxpdGllcy5nZXRPcGVyYXRpb25OYW1lKHNlcnZlclF1ZXJ5KSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5wcmVwYXJlQ29udGV4dCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29udGV4dCksIHsgZm9yY2VGZXRjaDogIWRlZHVwbGljYXRpb24gfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBvcGVyYXRpb24uY29udGV4dDtcbiAgICAgICAgICAgIGlmIChkZWR1cGxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5VmFyaWFibGVzXzEgPSBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xLmdldChzZXJ2ZXJRdWVyeSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEuc2V0KHNlcnZlclF1ZXJ5LCBieVZhcmlhYmxlc18xKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFySnNvbl8xID0gY2FjaGUuY2Fub25pY2FsU3RyaW5naWZ5KHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IGJ5VmFyaWFibGVzXzEuZ2V0KHZhckpzb25fMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25jYXN0ID0gbmV3IHV0aWxpdGllcy5Db25jYXN0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZXhlY3V0ZShsaW5rLCBvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBieVZhcmlhYmxlc18xLnNldCh2YXJKc29uXzEsIG9ic2VydmFibGUgPSBjb25jYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uY2FzdC5jbGVhbnVwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieVZhcmlhYmxlc18xLmRlbGV0ZSh2YXJKc29uXzEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnlWYXJpYWJsZXNfMS5zaXplIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEuZGVsZXRlKHNlcnZlclF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IG5ldyB1dGlsaXRpZXMuQ29uY2FzdChbXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZXhlY3V0ZShsaW5rLCBvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gbmV3IHV0aWxpdGllcy5Db25jYXN0KFtcbiAgICAgICAgICAgICAgICB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZih7IGRhdGE6IHt9IH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLnByZXBhcmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGllbnRRdWVyeSA9IHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5jbGllbnRRdWVyeTtcbiAgICAgICAgaWYgKGNsaWVudFF1ZXJ5KSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gdXRpbGl0aWVzLmFzeW5jTWFwKG9ic2VydmFibGUsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubG9jYWxTdGF0ZS5ydW5SZXNvbHZlcnMoe1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogY2xpZW50UXVlcnksXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZXN1bHRzRnJvbUxpbmsgPSBmdW5jdGlvbiAocXVlcnlJbmZvLCBjYWNoZVdyaXRlQmVoYXZpb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9IHF1ZXJ5SW5mby5sYXN0UmVxdWVzdElkID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RJZCgpO1xuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLmFzeW5jTWFwKHRoaXMuZ2V0T2JzZXJ2YWJsZUZyb21MaW5rKHF1ZXJ5SW5mby5kb2N1bWVudCwgb3B0aW9ucy5jb250ZXh0LCBvcHRpb25zLnZhcmlhYmxlcyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBoYXNFcnJvcnMgPSB1dGlsaXRpZXMuaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCA+PSBxdWVyeUluZm8ubGFzdFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgJiYgb3B0aW9ucy5lcnJvclBvbGljeSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcXVlcnlJbmZvLm1hcmtFcnJvcihuZXcgZXJyb3JzLkFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLm1hcmtSZXN1bHQocmVzdWx0LCBvcHRpb25zLCBjYWNoZVdyaXRlQmVoYXZpb3IpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcXIgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlYWR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgJiYgb3B0aW9ucy5lcnJvclBvbGljeSAhPT0gXCJpZ25vcmVcIikge1xuICAgICAgICAgICAgICAgIGFxci5lcnJvcnMgPSByZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgIGFxci5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFxcjtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzLmlzQXBvbGxvRXJyb3IobmV0d29ya0Vycm9yKVxuICAgICAgICAgICAgICAgID8gbmV0d29ya0Vycm9yXG4gICAgICAgICAgICAgICAgOiBuZXcgZXJyb3JzLkFwb2xsb0Vycm9yKHsgbmV0d29ya0Vycm9yOiBuZXR3b3JrRXJyb3IgfSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdElkID49IHF1ZXJ5SW5mby5sYXN0UmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLm1hcmtFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmZldGNoUXVlcnlPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIG9wdGlvbnMsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5ldHdvcmtTdGF0dXMgPT09IHZvaWQgMCkgeyBuZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmxvYWRpbmc7IH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ob3B0aW9ucy5xdWVyeSkuZG9jdW1lbnQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5O1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9hID09PSB2b2lkIDAgPyBkZWZhdWx0cyAmJiBkZWZhdWx0cy5mZXRjaFBvbGljeSB8fCBcImNhY2hlLWZpcnN0XCIgOiBfYSwgX2IgPSBvcHRpb25zLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyAmJiBkZWZhdWx0cy5lcnJvclBvbGljeSB8fCBcIm5vbmVcIiA6IF9iLCBfYyA9IG9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIHJldHVyblBhcnRpYWxEYXRhID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gb3B0aW9ucy5ub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UsIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IG9wdGlvbnMuY29udGV4dCwgY29udGV4dCA9IF9lID09PSB2b2lkIDAgPyB7fSA6IF9lO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5LFxuICAgICAgICAgICAgZXJyb3JQb2xpY3k6IGVycm9yUG9saWN5LFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHJldHVyblBhcnRpYWxEYXRhLFxuICAgICAgICAgICAgbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlOiBub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZyb21WYXJpYWJsZXMgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICAgIHZhciBjb25jYXN0U291cmNlcyA9IF90aGlzLmZldGNoUXVlcnlCeVBvbGljeShxdWVyeUluZm8sIG5vcm1hbGl6ZWQsIG5ldHdvcmtTdGF0dXMpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQuZmV0Y2hQb2xpY3kgIT09IFwic3RhbmRieVwiICYmXG4gICAgICAgICAgICAgICAgY29uY2FzdFNvdXJjZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ub2JzZXJ2YWJsZVF1ZXJ5W1wiYXBwbHlOZXh0RmV0Y2hQb2xpY3lcIl0oXCJhZnRlci1mZXRjaFwiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25jYXN0U291cmNlcztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsZWFudXBDYW5jZWxGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZldGNoQ2FuY2VsRm5zLmRlbGV0ZShxdWVyeUlkKTsgfTtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5zZXQocXVlcnlJZCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY2xlYW51cENhbmNlbEZuKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhc3QuY2FuY2VsKHJlYXNvbik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbmNhc3QgPSBuZXcgdXRpbGl0aWVzLkNvbmNhc3QodGhpcy50cmFuc2Zvcm0obm9ybWFsaXplZC5xdWVyeSkuaGFzQ2xpZW50RXhwb3J0c1xuICAgICAgICAgICAgPyB0aGlzLmxvY2FsU3RhdGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMobm9ybWFsaXplZC5xdWVyeSwgbm9ybWFsaXplZC52YXJpYWJsZXMsIG5vcm1hbGl6ZWQuY29udGV4dCkudGhlbihmcm9tVmFyaWFibGVzKVxuICAgICAgICAgICAgOiBmcm9tVmFyaWFibGVzKG5vcm1hbGl6ZWQudmFyaWFibGVzKSk7XG4gICAgICAgIGNvbmNhc3QucHJvbWlzZS50aGVuKGNsZWFudXBDYW5jZWxGbiwgY2xlYW51cENhbmNlbEZuKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhc3Q7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hRdWVyaWVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVDYWNoZSA9IF9hLnVwZGF0ZUNhY2hlLCBpbmNsdWRlID0gX2EuaW5jbHVkZSwgX2IgPSBfYS5vcHRpbWlzdGljLCBvcHRpbWlzdGljID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gX2EucmVtb3ZlT3B0aW1pc3RpYywgcmVtb3ZlT3B0aW1pc3RpYyA9IF9jID09PSB2b2lkIDAgPyBvcHRpbWlzdGljID8gdXRpbGl0aWVzLm1ha2VVbmlxdWVJZChcInJlZmV0Y2hRdWVyaWVzXCIpIDogdm9pZCAwIDogX2MsIG9uUXVlcnlVcGRhdGVkID0gX2Eub25RdWVyeVVwZGF0ZWQ7XG4gICAgICAgIHZhciBpbmNsdWRlZFF1ZXJpZXNCeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlKS5mb3JFYWNoKGZ1bmN0aW9uIChvcSwgcXVlcnlJZCkge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkUXVlcmllc0J5SWQuc2V0KHF1ZXJ5SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgb3E6IG9xLFxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlmZjogX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkuZ2V0RGlmZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgTWFwO1xuICAgICAgICBpZiAodXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuYmF0Y2goe1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlQ2FjaGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyAmJiByZW1vdmVPcHRpbWlzdGljIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbW92ZU9wdGltaXN0aWM6IHJlbW92ZU9wdGltaXN0aWMsXG4gICAgICAgICAgICAgICAgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCwgZGlmZiwgbGFzdERpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9xID0gd2F0Y2gud2F0Y2hlciBpbnN0YW5jZW9mIFF1ZXJ5SW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2gud2F0Y2hlci5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5kZWxldGUob3EucXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9uUXVlcnlVcGRhdGVkKG9xLCBkaWZmLCBsYXN0RGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcS5yZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KG9xLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5zZXQob3EucXVlcnlJZCwgeyBvcTogb3EsIGxhc3REaWZmOiBsYXN0RGlmZiwgZGlmZjogZGlmZiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZWRRdWVyaWVzQnlJZC5zaXplKSB7XG4gICAgICAgICAgICBpbmNsdWRlZFF1ZXJpZXNCeUlkLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9xID0gX2Eub3EsIGxhc3REaWZmID0gX2EubGFzdERpZmYsIGRpZmYgPSBfYS5kaWZmO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBvcVtcInF1ZXJ5SW5mb1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBpbmZvLmdldERpZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvblF1ZXJ5VXBkYXRlZChvcSwgZGlmZiwgbGFzdERpZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9uUXVlcnlVcGRhdGVkIHx8IHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcS5yZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KG9xLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlJZC5pbmRleE9mKFwibGVnYWN5T25lVGltZVF1ZXJ5XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZU9wdGltaXN0aWMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmVtb3ZlT3B0aW1pc3RpYyhyZW1vdmVPcHRpbWlzdGljKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hRdWVyeUJ5UG9saWN5ID0gZnVuY3Rpb24gKHF1ZXJ5SW5mbywgX2EsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgcmVmZXRjaFdyaXRlUG9saWN5ID0gX2EucmVmZXRjaFdyaXRlUG9saWN5LCBlcnJvclBvbGljeSA9IF9hLmVycm9yUG9saWN5LCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9hLnJldHVyblBhcnRpYWxEYXRhLCBjb250ZXh0ID0gX2EuY29udGV4dCwgbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gX2Eubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlO1xuICAgICAgICB2YXIgb2xkTmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzO1xuICAgICAgICBxdWVyeUluZm8uaW5pdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYWRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5SW5mby5nZXREaWZmKHZhcmlhYmxlcyk7IH07XG4gICAgICAgIHZhciByZXN1bHRzRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRpZmYsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrU3RhdHVzID09PSB2b2lkIDApIHsgbmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5sb2FkaW5nOyB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRpZmYucmVzdWx0O1xuICAgICAgICAgICAgaWYgKF9fREVWX18gJiZcbiAgICAgICAgICAgICAgICAhcmV0dXJuUGFydGlhbERhdGEgJiZcbiAgICAgICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwoZGF0YSwge30pKSB7XG4gICAgICAgICAgICAgICAgbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKGRpZmYubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gdXRpbGl0aWVzLk9ic2VydmFibGUub2YodHNsaWIuX19hc3NpZ24oeyBkYXRhOiBkYXRhLCBsb2FkaW5nOiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyksIG5ldHdvcmtTdGF0dXM6IG5ldHdvcmtTdGF0dXMgfSwgKGRpZmYuY29tcGxldGUgPyBudWxsIDogeyBwYXJ0aWFsOiB0cnVlIH0pKSk7IH07XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBfdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmhhc0ZvcmNlZFJlc29sdmVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sb2NhbFN0YXRlLnJ1blJlc29sdmVycyh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUmVzdWx0OiB7IGRhdGE6IGRhdGEgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHsgcmV0dXJuIGZyb21EYXRhKHJlc29sdmVkLmRhdGEgfHwgdm9pZCAwKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbURhdGEoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYWNoZVdyaXRlQmVoYXZpb3IgPSBmZXRjaFBvbGljeSA9PT0gXCJuby1jYWNoZVwiID8gMCA6XG4gICAgICAgICAgICAobmV0d29ya1N0YXR1cyA9PT0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlZmV0Y2ggJiZcbiAgICAgICAgICAgICAgICByZWZldGNoV3JpdGVQb2xpY3kgIT09IFwibWVyZ2VcIikgPyAxXG4gICAgICAgICAgICAgICAgOiAyO1xuICAgICAgICB2YXIgcmVzdWx0c0Zyb21MaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0UmVzdWx0c0Zyb21MaW5rKHF1ZXJ5SW5mbywgY2FjaGVXcml0ZUJlaGF2aW9yLCB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBmZXRjaFBvbGljeTogZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICB2YXIgc2hvdWxkTm90aWZ5ID0gbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2xkTmV0d29ya1N0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgb2xkTmV0d29ya1N0YXR1cyAhPT0gbmV0d29ya1N0YXR1cyAmJlxuICAgICAgICAgICAgaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpO1xuICAgICAgICBzd2l0Y2ggKGZldGNoUG9saWN5KSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FzZSBcImNhY2hlLWZpcnN0XCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHJlYWRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUNhY2hlKGRpZmYsIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5QYXJ0aWFsRGF0YSB8fCBzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUoZGlmZiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUxpbmsoKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjYWNoZS1hbmQtbmV0d29ya1wiOiB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSByZWFkQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSB8fCByZXR1cm5QYXJ0aWFsRGF0YSB8fCBzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUoZGlmZiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUxpbmsoKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjYWNoZS1vbmx5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21DYWNoZShyZWFkQ2FjaGUoKSwgcXVlcnlJbmZvLm1hcmtSZWFkeSgpKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmstb25seVwiOlxuICAgICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUocmVhZENhY2hlKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcmVzdWx0c0Zyb21MaW5rKCldO1xuICAgICAgICAgICAgY2FzZSBcIm5vLWNhY2hlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21DYWNoZShxdWVyeUluZm8uZ2V0RGlmZigpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tTGluaygpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3Jlc3VsdHNGcm9tTGluaygpXTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGFuZGJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgJiYgIXRoaXMucXVlcmllcy5oYXMocXVlcnlJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5zZXQocXVlcnlJZCwgbmV3IFF1ZXJ5SW5mbyh0aGlzLCBxdWVyeUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5nZXQocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmxvY2FsU3RhdGUucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbmV3Q29udGV4dCksIHsgY2xpZW50QXdhcmVuZXNzOiB0aGlzLmNsaWVudEF3YXJlbmVzcyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBRdWVyeU1hbmFnZXI7XG59KCkpO1xuXG52YXIgaGFzU3VnZ2VzdGVkRGV2dG9vbHMgPSBmYWxzZTtcbnZhciBBcG9sbG9DbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwb2xsb0NsaWVudChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIHVyaSA9IG9wdGlvbnMudXJpLCBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMsIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMsIGNhY2hlID0gb3B0aW9ucy5jYWNoZSwgX2EgPSBvcHRpb25zLnNzck1vZGUsIHNzck1vZGUgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnNzckZvcmNlRmV0Y2hEZWxheSwgc3NyRm9yY2VGZXRjaERlbGF5ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBvcHRpb25zLmNvbm5lY3RUb0RldlRvb2xzLCBjb25uZWN0VG9EZXZUb29scyA9IF9jID09PSB2b2lkIDAgPyB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgIXdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyAmJlxuICAgICAgICAgICAgX19ERVZfXyA6IF9jLCBfZCA9IG9wdGlvbnMucXVlcnlEZWR1cGxpY2F0aW9uLCBxdWVyeURlZHVwbGljYXRpb24gPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsIF9lID0gb3B0aW9ucy5hc3N1bWVJbW11dGFibGVSZXN1bHRzLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIHJlc29sdmVycyA9IG9wdGlvbnMucmVzb2x2ZXJzLCB0eXBlRGVmcyA9IG9wdGlvbnMudHlwZURlZnMsIGZyYWdtZW50TWF0Y2hlciA9IG9wdGlvbnMuZnJhZ21lbnRNYXRjaGVyLCBjbGllbnRBd2FyZW5lc3NOYW1lID0gb3B0aW9ucy5uYW1lLCBjbGllbnRBd2FyZW5lc3NWZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgICB2YXIgbGluayA9IG9wdGlvbnMubGluaztcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICBsaW5rID0gdXJpXG4gICAgICAgICAgICAgICAgPyBuZXcgaHR0cC5IdHRwTGluayh7IHVyaTogdXJpLCBjcmVkZW50aWFsczogY3JlZGVudGlhbHMsIGhlYWRlcnM6IGhlYWRlcnMgfSlcbiAgICAgICAgICAgICAgICA6IGNvcmUuQXBvbGxvTGluay5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIlRvIGluaXRpYWxpemUgQXBvbGxvIENsaWVudCwgeW91IG11c3Qgc3BlY2lmeSBhICdjYWNoZScgcHJvcGVydHkgXCIgK1xuICAgICAgICAgICAgICAgIFwiaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpc2l0OiBodHRwczovL2dvLmFwb2xsby5kZXYvYy9kb2NzXCIpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoNyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IHNzck1vZGUgfHwgc3NyRm9yY2VGZXRjaERlbGF5ID4gMDtcbiAgICAgICAgdGhpcy5xdWVyeURlZHVwbGljYXRpb24gPSBxdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnR5cGVEZWZzID0gdHlwZURlZnM7XG4gICAgICAgIGlmIChzc3JGb3JjZUZldGNoRGVsYXkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IGZhbHNlKTsgfSwgc3NyRm9yY2VGZXRjaERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoUXVlcnkgPSB0aGlzLndhdGNoUXVlcnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tdXRhdGUgPSB0aGlzLm11dGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmUgPSB0aGlzLnJlc2V0U3RvcmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSB0aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcy5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoY29ubmVjdFRvRGV2VG9vbHMgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNTdWdnZXN0ZWREZXZ0b29scyAmJiBfX0RFVl9fKSB7XG4gICAgICAgICAgICBoYXNTdWdnZXN0ZWREZXZ0b29scyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZiAmJlxuICAgICAgICAgICAgICAgICF3aW5kb3cuX19BUE9MTE9fREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgICAgICAgICAgICAgIHZhciBuYXYgPSB3aW5kb3cubmF2aWdhdG9yO1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdiAmJiBuYXYudXNlckFnZW50O1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodWEuaW5kZXhPZihcIkNocm9tZS9cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhcG9sbG8tY2xpZW50LWRldmVsb3Blci10L2pka2tua2tiZWJiYXBpbGdvZWNjY2lnbGtmYm1ibmZtXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodWEuaW5kZXhPZihcIkZpcmVmb3gvXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9hZGRvbnMubW96aWxsYS5vcmcvZW4tVVMvZmlyZWZveC9hZGRvbi9hcG9sbG8tZGV2ZWxvcGVyLXRvb2xzL1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5sb2coXCJEb3dubG9hZCB0aGUgQXBvbGxvIERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVyaWVuY2U6IFwiICsgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsU3RhdGUoe1xuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICAgICAgcmVzb2x2ZXJzOiByZXNvbHZlcnMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih7XG4gICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgICAgICAgIGxpbms6IHRoaXMubGluayxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB0aGlzLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgcXVlcnlEZWR1cGxpY2F0aW9uOiBxdWVyeURlZHVwbGljYXRpb24sXG4gICAgICAgICAgICBzc3JNb2RlOiBzc3JNb2RlLFxuICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogY2xpZW50QXdhcmVuZXNzTmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjbGllbnRBd2FyZW5lc3NWZXJzaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsU3RhdGU6IHRoaXMubG9jYWxTdGF0ZSxcbiAgICAgICAgICAgIGFzc3VtZUltbXV0YWJsZVJlc3VsdHM6IGFzc3VtZUltbXV0YWJsZVJlc3VsdHMsXG4gICAgICAgICAgICBvbkJyb2FkY2FzdDogY29ubmVjdFRvRGV2VG9vbHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRldlRvb2xzSG9va0NiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRldlRvb2xzSG9va0NiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IF90aGlzLnF1ZXJ5TWFuYWdlci5nZXRRdWVyeVN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25zOiBfdGhpcy5xdWVyeU1hbmFnZXIubXV0YXRpb25TdG9yZSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhV2l0aE9wdGltaXN0aWNSZXN1bHRzOiBfdGhpcy5jYWNoZS5leHRyYWN0KHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zdG9wKCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndhdGNoUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXRpbGl0aWVzLm1lcmdlT3B0aW9ucyh0aGlzLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyAmJlxuICAgICAgICAgICAgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ2NhY2hlLWFuZC1uZXR3b3JrJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6ICdjYWNoZS1maXJzdCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLndhdGNoUXVlcnkob3B0aW9ucyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1dGlsaXRpZXMubWVyZ2VPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChvcHRpb25zLmZldGNoUG9saWN5ICE9PSAnY2FjaGUtYW5kLW5ldHdvcmsnLCAnVGhlIGNhY2hlLWFuZC1uZXR3b3JrIGZldGNoUG9saWN5IGRvZXMgbm90IHdvcmsgd2l0aCBjbGllbnQucXVlcnksIGJlY2F1c2UgJyArXG4gICAgICAgICAgICAnY2xpZW50LnF1ZXJ5IGNhbiBvbmx5IHJldHVybiBhIHNpbmdsZSByZXN1bHQuIFBsZWFzZSB1c2UgY2xpZW50LndhdGNoUXVlcnkgJyArXG4gICAgICAgICAgICAndG8gcmVjZWl2ZSBtdWx0aXBsZSByZXN1bHRzIGZyb20gdGhlIGNhY2hlIGFuZCB0aGUgbmV0d29yaywgb3IgY29uc2lkZXIgJyArXG4gICAgICAgICAgICAndXNpbmcgYSBkaWZmZXJlbnQgZmV0Y2hQb2xpY3ksIHN1Y2ggYXMgY2FjaGUtZmlyc3Qgb3IgbmV0d29yay1vbmx5LicpIDogZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgOCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyAmJiBvcHRpb25zLmZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmZXRjaFBvbGljeTogJ2NhY2hlLWZpcnN0JyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIucXVlcnkob3B0aW9ucyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHV0aWxpdGllcy5tZXJnZU9wdGlvbnModGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5tdXRhdGUob3B0aW9ucyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5zdGFydEdyYXBoUUxTdWJzY3JpcHRpb24ob3B0aW9ucyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlYWRRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnJlYWRRdWVyeShvcHRpb25zLCBvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVhZEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVhZEZyYWdtZW50KG9wdGlvbnMsIG9wdGltaXN0aWMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS53cml0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWNoZS53cml0ZVF1ZXJ5KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhY2hlLndyaXRlRnJhZ21lbnQob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuX19hY3Rpb25Ib29rRm9yRGV2VG9vbHMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5kZXZUb29sc0hvb2tDYiA9IGNiO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5fX3JlcXVlc3RSYXcgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gY29yZS5leGVjdXRlKHRoaXMubGluaywgcGF5bG9hZCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucXVlcnlNYW5hZ2VyLmNsZWFyU3RvcmUoe1xuICAgICAgICAgICAgZGlzY2FyZFdhdGNoZXM6IGZhbHNlLFxuICAgICAgICB9KTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UuYWxsKF90aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSkpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzKCk7IH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5jbGVhclN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnF1ZXJ5TWFuYWdlci5jbGVhclN0b3JlKHtcbiAgICAgICAgICAgIGRpc2NhcmRXYXRjaGVzOiB0cnVlLFxuICAgICAgICB9KTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UuYWxsKF90aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSkpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUub25SZXNldFN0b3JlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZUNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MgPSBfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gY2I7IH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5vbkNsZWFyU3RvcmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcyA9IF90aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSBjYjsgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlU3RhbmRieSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzKGluY2x1ZGVTdGFuZGJ5KTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVmZXRjaFF1ZXJpZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5xdWVyeU1hbmFnZXIucmVmZXRjaFF1ZXJpZXMob3B0aW9ucyk7XG4gICAgICAgIHZhciBxdWVyaWVzID0gW107XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIG9ic1F1ZXJ5KSB7XG4gICAgICAgICAgICBxdWVyaWVzLnB1c2gob2JzUXVlcnkpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gUHJvbWlzZS5hbGwocmVzdWx0cyk7XG4gICAgICAgIHJlc3VsdC5xdWVyaWVzID0gcXVlcmllcztcbiAgICAgICAgcmVzdWx0LnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50LmRlYnVnKFwiSW4gY2xpZW50LnJlZmV0Y2hRdWVyaWVzLCBQcm9taXNlLmFsbCBwcm9taXNlIHJlamVjdGVkIHdpdGggZXJyb3IgXCIuY29uY2F0KGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5nZXRPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlID09PSB2b2lkIDApIHsgaW5jbHVkZSA9IFwiYWN0aXZlXCI7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLmdldE9ic2VydmFibGVRdWVyaWVzKGluY2x1ZGUpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZXh0cmFjdChvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVzdG9yZShzZXJpYWxpemVkU3RhdGUpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5hZGRSZXNvbHZlcnMgPSBmdW5jdGlvbiAocmVzb2x2ZXJzKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuc2V0UmVzb2x2ZXJzKHJlc29sdmVycyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLmdldFJlc29sdmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5nZXRSZXNvbHZlcnMoKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0TG9jYWxTdGF0ZUZyYWdtZW50TWF0Y2hlciA9IGZ1bmN0aW9uIChmcmFnbWVudE1hdGNoZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zZXRMaW5rID0gZnVuY3Rpb24gKG5ld0xpbmspIHtcbiAgICAgICAgdGhpcy5saW5rID0gdGhpcy5xdWVyeU1hbmFnZXIubGluayA9IG5ld0xpbms7XG4gICAgfTtcbiAgICByZXR1cm4gQXBvbGxvQ2xpZW50O1xufSgpKTtcblxudHNJbnZhcmlhbnQuc2V0VmVyYm9zaXR5KGdsb2JhbHMuREVWID8gXCJsb2dcIiA6IFwic2lsZW50XCIpO1xuXG5leHBvcnRzLkFwb2xsb0NhY2hlID0gY2FjaGUuQXBvbGxvQ2FjaGU7XG5leHBvcnRzLkNhY2hlID0gY2FjaGUuQ2FjaGU7XG5leHBvcnRzLkluTWVtb3J5Q2FjaGUgPSBjYWNoZS5Jbk1lbW9yeUNhY2hlO1xuZXhwb3J0cy5NaXNzaW5nRmllbGRFcnJvciA9IGNhY2hlLk1pc3NpbmdGaWVsZEVycm9yO1xuZXhwb3J0cy5kZWZhdWx0RGF0YUlkRnJvbU9iamVjdCA9IGNhY2hlLmRlZmF1bHREYXRhSWRGcm9tT2JqZWN0O1xuZXhwb3J0cy5tYWtlVmFyID0gY2FjaGUubWFrZVZhcjtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IHV0aWxpdGllcy5PYnNlcnZhYmxlO1xuZXhwb3J0cy5pc1JlZmVyZW5jZSA9IHV0aWxpdGllcy5pc1JlZmVyZW5jZTtcbmV4cG9ydHMubWFrZVJlZmVyZW5jZSA9IHV0aWxpdGllcy5tYWtlUmVmZXJlbmNlO1xuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSB1dGlsaXRpZXMubWVyZ2VPcHRpb25zO1xuZXhwb3J0cy5BcG9sbG9FcnJvciA9IGVycm9ycy5BcG9sbG9FcnJvcjtcbmV4cG9ydHMuaXNBcG9sbG9FcnJvciA9IGVycm9ycy5pc0Fwb2xsb0Vycm9yO1xuZXhwb3J0cy5mcm9tRXJyb3IgPSB1dGlscy5mcm9tRXJyb3I7XG5leHBvcnRzLmZyb21Qcm9taXNlID0gdXRpbHMuZnJvbVByb21pc2U7XG5leHBvcnRzLnRocm93U2VydmVyRXJyb3IgPSB1dGlscy50aHJvd1NlcnZlckVycm9yO1xuZXhwb3J0cy50b1Byb21pc2UgPSB1dGlscy50b1Byb21pc2U7XG5leHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IHRzSW52YXJpYW50LnNldFZlcmJvc2l0eTtcbmV4cG9ydHMuZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gZ3JhcGhxbFRhZy5kaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM7XG5leHBvcnRzLmRpc2FibGVGcmFnbWVudFdhcm5pbmdzID0gZ3JhcGhxbFRhZy5kaXNhYmxlRnJhZ21lbnRXYXJuaW5ncztcbmV4cG9ydHMuZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMgPSBncmFwaHFsVGFnLmVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzO1xuZXhwb3J0cy5ncWwgPSBncmFwaHFsVGFnLmdxbDtcbmV4cG9ydHMucmVzZXRDYWNoZXMgPSBncmFwaHFsVGFnLnJlc2V0Q2FjaGVzO1xuZXhwb3J0cy5BcG9sbG9DbGllbnQgPSBBcG9sbG9DbGllbnQ7XG5leHBvcnRzLk9ic2VydmFibGVRdWVyeSA9IE9ic2VydmFibGVRdWVyeTtcbmZvciAodmFyIGsgaW4gY29yZSkge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIGV4cG9ydHNba10gPSBjb3JlW2tdO1xufVxuZm9yICh2YXIgayBpbiBodHRwKSB7XG4gICAgaWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgZXhwb3J0c1trXSA9IGh0dHBba107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmNqcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnJlcXVpcmUoJy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzJyk7XG5cbmZ1bmN0aW9uIGlzQXBvbGxvRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyci5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGhRTEVycm9ycycpO1xufVxudmFyIGdlbmVyYXRlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZXJyLmdyYXBoUUxFcnJvcnMpIHx8IHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZXJyLmNsaWVudEVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IChlcnIuZ3JhcGhRTEVycm9ycyB8fCBbXSlcbiAgICAgICAgICAgIC5jb25jYXQoZXJyLmNsaWVudEVycm9ycyB8fCBbXSk7XG4gICAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGVycm9yXG4gICAgICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiAnRXJyb3IgbWVzc2FnZSBub3QgZm91bmQuJztcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJcIi5jb25jYXQoZXJyb3JNZXNzYWdlLCBcIlxcblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnIubmV0d29ya0Vycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCJcIi5jb25jYXQoZXJyLm5ldHdvcmtFcnJvci5tZXNzYWdlLCBcIlxcblwiKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG52YXIgQXBvbGxvRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhBcG9sbG9FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcG9sbG9FcnJvcihfYSkge1xuICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IF9hLmdyYXBoUUxFcnJvcnMsIGNsaWVudEVycm9ycyA9IF9hLmNsaWVudEVycm9ycywgbmV0d29ya0Vycm9yID0gX2EubmV0d29ya0Vycm9yLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIGV4dHJhSW5mbyA9IF9hLmV4dHJhSW5mbztcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3JNZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ncmFwaFFMRXJyb3JzID0gZ3JhcGhRTEVycm9ycyB8fCBbXTtcbiAgICAgICAgX3RoaXMuY2xpZW50RXJyb3JzID0gY2xpZW50RXJyb3JzIHx8IFtdO1xuICAgICAgICBfdGhpcy5uZXR3b3JrRXJyb3IgPSBuZXR3b3JrRXJyb3IgfHwgbnVsbDtcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCBnZW5lcmF0ZUVycm9yTWVzc2FnZShfdGhpcyk7XG4gICAgICAgIF90aGlzLmV4dHJhSW5mbyA9IGV4dHJhSW5mbztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gQXBvbGxvRXJyb3IucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBcG9sbG9FcnJvcjtcbn0oRXJyb3IpKTtcblxuZXhwb3J0cy5BcG9sbG9FcnJvciA9IEFwb2xsb0Vycm9yO1xuZXhwb3J0cy5pc0Fwb2xsb0Vycm9yID0gaXNBcG9sbG9FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBwYXNzdGhyb3VnaChvcCwgZm9yd2FyZCkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IGZvcndhcmQob3ApIDogdXRpbGl0aWVzLk9ic2VydmFibGUub2YoKSk7XG59XG5mdW5jdGlvbiB0b0xpbmsoaGFuZGxlcikge1xuICAgIHJldHVybiB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBBcG9sbG9MaW5rKGhhbmRsZXIpIDogaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIGlzVGVybWluYXRpbmcobGluaykge1xuICAgIHJldHVybiBsaW5rLnJlcXVlc3QubGVuZ3RoIDw9IDE7XG59XG52YXIgTGlua0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTGlua0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtFcnJvcihtZXNzYWdlLCBsaW5rKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaW5rRXJyb3I7XG59KEVycm9yKSk7XG52YXIgQXBvbGxvTGluayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBvbGxvTGluayhyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9XG4gICAgQXBvbGxvTGluay5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7IH0pO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5mcm9tID0gZnVuY3Rpb24gKGxpbmtzKSB7XG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gQXBvbGxvTGluay5lbXB0eSgpO1xuICAgICAgICByZXR1cm4gbGlua3MubWFwKHRvTGluaykucmVkdWNlKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LmNvbmNhdCh5KTsgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnNwbGl0ID0gZnVuY3Rpb24gKHRlc3QsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0TGluayA9IHRvTGluayhsZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0TGluayA9IHRvTGluayhyaWdodCB8fCBuZXcgQXBvbGxvTGluayhwYXNzdGhyb3VnaCkpO1xuICAgICAgICBpZiAoaXNUZXJtaW5hdGluZyhsZWZ0TGluaykgJiYgaXNUZXJtaW5hdGluZyhyaWdodExpbmspKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFwb2xsb0xpbmsoZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0KG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBsZWZ0TGluay5yZXF1ZXN0KG9wZXJhdGlvbikgfHwgdXRpbGl0aWVzLk9ic2VydmFibGUub2YoKVxuICAgICAgICAgICAgICAgICAgICA6IHJpZ2h0TGluay5yZXF1ZXN0KG9wZXJhdGlvbikgfHwgdXRpbGl0aWVzLk9ic2VydmFibGUub2YoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdChvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gbGVmdExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKClcbiAgICAgICAgICAgICAgICAgICAgOiByaWdodExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBvbGxvTGluay5leGVjdXRlID0gZnVuY3Rpb24gKGxpbmssIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gKGxpbmsucmVxdWVzdCh1dGlscy5jcmVhdGVPcGVyYXRpb24ob3BlcmF0aW9uLmNvbnRleHQsIHV0aWxzLnRyYW5zZm9ybU9wZXJhdGlvbih1dGlscy52YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24pKSkpIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCkpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5jb25jYXQgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgZmlyc3RMaW5rID0gdG9MaW5rKGZpcnN0KTtcbiAgICAgICAgaWYgKGlzVGVybWluYXRpbmcoZmlyc3RMaW5rKSkge1xuICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKG5ldyBMaW5rRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgY29uY2F0IG9uIGEgdGVybWluYXRpbmcgbGluaywgd2hpY2ggd2lsbCBoYXZlIG5vIGVmZmVjdFwiLCBmaXJzdExpbmspKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdExpbms7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRMaW5rID0gdG9MaW5rKHNlY29uZCk7XG4gICAgICAgIGlmIChpc1Rlcm1pbmF0aW5nKG5leHRMaW5rKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG5leHRMaW5rLnJlcXVlc3Qob3ApIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7IH0pIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaXJzdExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCwgZm9yd2FyZCkgfHwgdXRpbGl0aWVzLk9ic2VydmFibGUub2YoKTtcbiAgICAgICAgICAgICAgICB9KSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0ZXN0LCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoQXBvbGxvTGluay5zcGxpdCh0ZXN0LCBsZWZ0LCByaWdodCB8fCBuZXcgQXBvbGxvTGluayhwYXNzdGhyb3VnaCkpKTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBBcG9sbG9MaW5rLmNvbmNhdCh0aGlzLCBuZXh0KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcigncmVxdWVzdCBpcyBub3QgaW1wbGVtZW50ZWQnKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDE5KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIG9ic2VydmVyKSB7XG4gICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUuc2V0T25FcnJvciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQXBvbGxvTGluaztcbn0oKSk7XG5cbnZhciBlbXB0eSA9IEFwb2xsb0xpbmsuZW1wdHk7XG5cbnZhciBmcm9tID0gQXBvbGxvTGluay5mcm9tO1xuXG52YXIgc3BsaXQgPSBBcG9sbG9MaW5rLnNwbGl0O1xuXG52YXIgY29uY2F0ID0gQXBvbGxvTGluay5jb25jYXQ7XG5cbnZhciBleGVjdXRlID0gQXBvbGxvTGluay5leGVjdXRlO1xuXG5leHBvcnRzLkFwb2xsb0xpbmsgPSBBcG9sbG9MaW5rO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5leHBvcnRzLmVtcHR5ID0gZW1wdHk7XG5leHBvcnRzLmV4ZWN1dGUgPSBleGVjdXRlO1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBncmFwaHFsID0gcmVxdWlyZSgnZ3JhcGhxbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlKG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZVxuICAgICAgICAudGV4dCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5VGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgcGFyc2VFcnJvci5uYW1lID0gJ1NlcnZlclBhcnNlRXJyb3InO1xuICAgICAgICAgICAgcGFyc2VFcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgcGFyc2VFcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgcGFyc2VFcnJvci5ib2R5VGV4dCA9IGJvZHlUZXh0O1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIHV0aWxzLnRocm93U2VydmVyRXJyb3IocmVzcG9uc2UsIHJlc3VsdCwgXCJSZXNwb25zZSBub3Qgc3VjY2Vzc2Z1bDogUmVjZWl2ZWQgc3RhdHVzIGNvZGUgXCIuY29uY2F0KHJlc3BvbnNlLnN0YXR1cykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpICYmXG4gICAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsICdkYXRhJykgJiZcbiAgICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgJ2Vycm9ycycpKSB7XG4gICAgICAgICAgICB1dGlscy50aHJvd1NlcnZlckVycm9yKHJlc3BvbnNlLCByZXN1bHQsIFwiU2VydmVyIHJlc3BvbnNlIHdhcyBtaXNzaW5nIGZvciBxdWVyeSAnXCIuY29uY2F0KEFycmF5LmlzQXJyYXkob3BlcmF0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9wZXJhdGlvbnMubWFwKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3Aub3BlcmF0aW9uTmFtZTsgfSlcbiAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbnMub3BlcmF0aW9uTmFtZSwgXCInLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTsgfTtcbn1cblxudmFyIHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyID0gZnVuY3Rpb24gKHAsIGxhYmVsKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHApO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgcGFyc2VFcnJvciA9IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQuIFwiLmNvbmNhdChsYWJlbCwgXCIgaXMgbm90IHNlcmlhbGl6YWJsZTogXCIpLmNvbmNhdChlLm1lc3NhZ2UpKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDIxKTtcbiAgICAgICAgcGFyc2VFcnJvci5wYXJzZUVycm9yID0gZTtcbiAgICAgICAgdGhyb3cgcGFyc2VFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgZGVmYXVsdEh0dHBPcHRpb25zID0ge1xuICAgIGluY2x1ZGVRdWVyeTogdHJ1ZSxcbiAgICBpbmNsdWRlRXh0ZW5zaW9uczogZmFsc2UsXG59O1xudmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIGFjY2VwdDogJyovKicsXG4gICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG59O1xudmFyIGZhbGxiYWNrSHR0cENvbmZpZyA9IHtcbiAgICBodHRwOiBkZWZhdWx0SHR0cE9wdGlvbnMsXG4gICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMsXG4gICAgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG59O1xudmFyIGRlZmF1bHRQcmludGVyID0gZnVuY3Rpb24gKGFzdCwgcHJpbnRlcikgeyByZXR1cm4gcHJpbnRlcihhc3QpOyB9O1xuZnVuY3Rpb24gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5KG9wZXJhdGlvbiwgZmFsbGJhY2tDb25maWcpIHtcbiAgICB2YXIgY29uZmlncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNvbmZpZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGNvbmZpZ3MudW5zaGlmdChmYWxsYmFja0NvbmZpZyk7XG4gICAgcmV0dXJuIHNlbGVjdEh0dHBPcHRpb25zQW5kQm9keUludGVybmFsLmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbb3BlcmF0aW9uLFxuICAgICAgICBkZWZhdWx0UHJpbnRlcl0sIGNvbmZpZ3MsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbChvcGVyYXRpb24sIHByaW50ZXIpIHtcbiAgICB2YXIgY29uZmlncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNvbmZpZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIGh0dHAgPSB7fTtcbiAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBvcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCBjb25maWcub3B0aW9ucyksIHsgaGVhZGVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycyksIGhlYWRlcnNUb0xvd2VyQ2FzZShjb25maWcuaGVhZGVycykpIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gY29uZmlnLmNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIGh0dHAgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaHR0cCksIGNvbmZpZy5odHRwKTtcbiAgICB9KTtcbiAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbi5vcGVyYXRpb25OYW1lLCBleHRlbnNpb25zID0gb3BlcmF0aW9uLmV4dGVuc2lvbnMsIHZhcmlhYmxlcyA9IG9wZXJhdGlvbi52YXJpYWJsZXMsIHF1ZXJ5ID0gb3BlcmF0aW9uLnF1ZXJ5O1xuICAgIHZhciBib2R5ID0geyBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb25OYW1lLCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9O1xuICAgIGlmIChodHRwLmluY2x1ZGVFeHRlbnNpb25zKVxuICAgICAgICBib2R5LmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIGlmIChodHRwLmluY2x1ZGVRdWVyeSlcbiAgICAgICAgYm9keS5xdWVyeSA9IHByaW50ZXIocXVlcnksIGdyYXBocWwucHJpbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhlYWRlcnNUb0xvd2VyQ2FzZShoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRfMSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIE9iamVjdC5rZXlzKE9iamVjdChoZWFkZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZF8xW25hbWUudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRfMTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbnZhciBjaGVja0ZldGNoZXIgPSBmdW5jdGlvbiAoZmV0Y2hlcikge1xuICAgIGlmICghZmV0Y2hlciAmJiB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIlxcblxcXCJmZXRjaFxcXCIgaGFzIG5vdCBiZWVuIGZvdW5kIGdsb2JhbGx5IGFuZCBubyBmZXRjaGVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQuIFRvIGZpeCB0aGlzLCBpbnN0YWxsIGEgZmV0Y2ggcGFja2FnZSAobGlrZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9jcm9zcy1mZXRjaCksIGluc3RhbnRpYXRlIHRoZSBmZXRjaGVyLCBhbmQgcGFzcyBpdCBpbnRvIHlvdXIgSHR0cExpbmsgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxcblxcbmltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCc7XFxuaW1wb3J0IHsgQXBvbGxvQ2xpZW50LCBIdHRwTGluayB9IGZyb20gJ0BhcG9sbG8vY2xpZW50JztcXG5jb25zdCBjbGllbnQgPSBuZXcgQXBvbGxvQ2xpZW50KHtcXG4gIGxpbms6IG5ldyBIdHRwTGluayh7IHVyaTogJy9ncmFwaHFsJywgZmV0Y2ggfSlcXG59KTtcXG4gICAgXCIpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoMjApO1xuICAgIH1cbn07XG5cbnZhciBjcmVhdGVTaWduYWxJZlN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7IGNvbnRyb2xsZXI6IGZhbHNlLCBzaWduYWw6IGZhbHNlIH07XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdmFyIHNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHJldHVybiB7IGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIsIHNpZ25hbDogc2lnbmFsIH07XG59O1xuXG52YXIgc2VsZWN0VVJJID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgZmFsbGJhY2tVUkkpIHtcbiAgICB2YXIgY29udGV4dCA9IG9wZXJhdGlvbi5nZXRDb250ZXh0KCk7XG4gICAgdmFyIGNvbnRleHRVUkkgPSBjb250ZXh0LnVyaTtcbiAgICBpZiAoY29udGV4dFVSSSkge1xuICAgICAgICByZXR1cm4gY29udGV4dFVSSTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrVVJJID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1VSSShvcGVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVVJJIHx8ICcvZ3JhcGhxbCc7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmV3cml0ZVVSSUZvckdFVChjaG9zZW5VUkksIGJvZHkpIHtcbiAgICB2YXIgcXVlcnlQYXJhbXMgPSBbXTtcbiAgICB2YXIgYWRkUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goXCJcIi5jb25jYXQoa2V5LCBcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpKTtcbiAgICB9O1xuICAgIGlmICgncXVlcnknIGluIGJvZHkpIHtcbiAgICAgICAgYWRkUXVlcnlQYXJhbSgncXVlcnknLCBib2R5LnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGJvZHkub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBhZGRRdWVyeVBhcmFtKCdvcGVyYXRpb25OYW1lJywgYm9keS5vcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgaWYgKGJvZHkudmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkVmFyaWFibGVzID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZFZhcmlhYmxlcyA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHkudmFyaWFibGVzLCAnVmFyaWFibGVzIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgndmFyaWFibGVzJywgc2VyaWFsaXplZFZhcmlhYmxlcyk7XG4gICAgfVxuICAgIGlmIChib2R5LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRFeHRlbnNpb25zID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZEV4dGVuc2lvbnMgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LmV4dGVuc2lvbnMsICdFeHRlbnNpb25zIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgnZXh0ZW5zaW9ucycsIHNlcmlhbGl6ZWRFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gJycsIHByZUZyYWdtZW50ID0gY2hvc2VuVVJJO1xuICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gY2hvc2VuVVJJLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoZnJhZ21lbnRTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgZnJhZ21lbnQgPSBjaG9zZW5VUkkuc3Vic3RyKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICBwcmVGcmFnbWVudCA9IGNob3NlblVSSS5zdWJzdHIoMCwgZnJhZ21lbnRTdGFydCk7XG4gICAgfVxuICAgIHZhciBxdWVyeVBhcmFtc1ByZWZpeCA9IHByZUZyYWdtZW50LmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG4gICAgdmFyIG5ld1VSSSA9IHByZUZyYWdtZW50ICsgcXVlcnlQYXJhbXNQcmVmaXggKyBxdWVyeVBhcmFtcy5qb2luKCcmJykgKyBmcmFnbWVudDtcbiAgICByZXR1cm4geyBuZXdVUkk6IG5ld1VSSSB9O1xufVxuXG52YXIgYmFja3VwRmV0Y2ggPSB1dGlsaXRpZXMubWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2g7IH0pO1xudmFyIGNyZWF0ZUh0dHBMaW5rID0gZnVuY3Rpb24gKGxpbmtPcHRpb25zKSB7XG4gICAgaWYgKGxpbmtPcHRpb25zID09PSB2b2lkIDApIHsgbGlua09wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IGxpbmtPcHRpb25zLnVyaSwgdXJpID0gX2EgPT09IHZvaWQgMCA/ICcvZ3JhcGhxbCcgOiBfYSwgcHJlZmVycmVkRmV0Y2ggPSBsaW5rT3B0aW9ucy5mZXRjaCwgX2IgPSBsaW5rT3B0aW9ucy5wcmludCwgcHJpbnQgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdFByaW50ZXIgOiBfYiwgaW5jbHVkZUV4dGVuc2lvbnMgPSBsaW5rT3B0aW9ucy5pbmNsdWRlRXh0ZW5zaW9ucywgdXNlR0VURm9yUXVlcmllcyA9IGxpbmtPcHRpb25zLnVzZUdFVEZvclF1ZXJpZXMsIF9jID0gbGlua09wdGlvbnMuaW5jbHVkZVVudXNlZFZhcmlhYmxlcywgaW5jbHVkZVVudXNlZFZhcmlhYmxlcyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByZXF1ZXN0T3B0aW9ucyA9IHRzbGliLl9fcmVzdChsaW5rT3B0aW9ucywgW1widXJpXCIsIFwiZmV0Y2hcIiwgXCJwcmludFwiLCBcImluY2x1ZGVFeHRlbnNpb25zXCIsIFwidXNlR0VURm9yUXVlcmllc1wiLCBcImluY2x1ZGVVbnVzZWRWYXJpYWJsZXNcIl0pO1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNoZWNrRmV0Y2hlcihwcmVmZXJyZWRGZXRjaCB8fCBiYWNrdXBGZXRjaCk7XG4gICAgfVxuICAgIHZhciBsaW5rQ29uZmlnID0ge1xuICAgICAgICBodHRwOiB7IGluY2x1ZGVFeHRlbnNpb25zOiBpbmNsdWRlRXh0ZW5zaW9ucyB9LFxuICAgICAgICBvcHRpb25zOiByZXF1ZXN0T3B0aW9ucy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiByZXF1ZXN0T3B0aW9ucy5jcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgY29yZS5BcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGNob3NlblVSSSA9IHNlbGVjdFVSSShvcGVyYXRpb24sIHVyaSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gb3BlcmF0aW9uLmdldENvbnRleHQoKTtcbiAgICAgICAgdmFyIGNsaWVudEF3YXJlbmVzc0hlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbnRleHQuY2xpZW50QXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb250ZXh0LmNsaWVudEF3YXJlbmVzcywgbmFtZV8xID0gX2EubmFtZSwgdmVyc2lvbiA9IF9hLnZlcnNpb247XG4gICAgICAgICAgICBpZiAobmFtZV8xKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzSGVhZGVyc1snYXBvbGxvZ3JhcGhxbC1jbGllbnQtbmFtZSddID0gbmFtZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBd2FyZW5lc3NIZWFkZXJzWydhcG9sbG9ncmFwaHFsLWNsaWVudC12ZXJzaW9uJ10gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0SGVhZGVycyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjbGllbnRBd2FyZW5lc3NIZWFkZXJzKSwgY29udGV4dC5oZWFkZXJzKTtcbiAgICAgICAgdmFyIGNvbnRleHRDb25maWcgPSB7XG4gICAgICAgICAgICBodHRwOiBjb250ZXh0Lmh0dHAsXG4gICAgICAgICAgICBvcHRpb25zOiBjb250ZXh0LmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBjb250ZXh0LmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgaGVhZGVyczogY29udGV4dEhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYiA9IHNlbGVjdEh0dHBPcHRpb25zQW5kQm9keUludGVybmFsKG9wZXJhdGlvbiwgcHJpbnQsIGZhbGxiYWNrSHR0cENvbmZpZywgbGlua0NvbmZpZywgY29udGV4dENvbmZpZyksIG9wdGlvbnMgPSBfYi5vcHRpb25zLCBib2R5ID0gX2IuYm9keTtcbiAgICAgICAgaWYgKGJvZHkudmFyaWFibGVzICYmICFpbmNsdWRlVW51c2VkVmFyaWFibGVzKSB7XG4gICAgICAgICAgICB2YXIgdW51c2VkTmFtZXNfMSA9IG5ldyBTZXQoT2JqZWN0LmtleXMoYm9keS52YXJpYWJsZXMpKTtcbiAgICAgICAgICAgIGdyYXBocWwudmlzaXQob3BlcmF0aW9uLnF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgVmFyaWFibGU6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQua2luZCAhPT0gJ1ZhcmlhYmxlRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVudXNlZE5hbWVzXzEuZGVsZXRlKG5vZGUubmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodW51c2VkTmFtZXNfMS5zaXplKSB7XG4gICAgICAgICAgICAgICAgYm9keS52YXJpYWJsZXMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgYm9keS52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIHVudXNlZE5hbWVzXzEuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYm9keS52YXJpYWJsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRyb2xsZXI7XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHZhciBfYyA9IGNyZWF0ZVNpZ25hbElmU3VwcG9ydGVkKCksIF9jb250cm9sbGVyID0gX2MuY29udHJvbGxlciwgc2lnbmFsID0gX2Muc2lnbmFsO1xuICAgICAgICAgICAgY29udHJvbGxlciA9IF9jb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmluaXRpb25Jc011dGF0aW9uID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJyAmJiBkLm9wZXJhdGlvbiA9PT0gJ211dGF0aW9uJztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVzZUdFVEZvclF1ZXJpZXMgJiZcbiAgICAgICAgICAgICFvcGVyYXRpb24ucXVlcnkuZGVmaW5pdGlvbnMuc29tZShkZWZpbml0aW9uSXNNdXRhdGlvbikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdmFyIF9kID0gcmV3cml0ZVVSSUZvckdFVChjaG9zZW5VUkksIGJvZHkpLCBuZXdVUkkgPSBfZC5uZXdVUkksIHBhcnNlRXJyb3IgPSBfZC5wYXJzZUVycm9yO1xuICAgICAgICAgICAgaWYgKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZnJvbUVycm9yKHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hvc2VuVVJJID0gbmV3VVJJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LCAnUGF5bG9hZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZnJvbUVycm9yKHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEZldGNoID0gcHJlZmVycmVkRmV0Y2ggfHwgdXRpbGl0aWVzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoOyB9KSB8fCBiYWNrdXBGZXRjaDtcbiAgICAgICAgICAgIGN1cnJlbnRGZXRjaChjaG9zZW5VUkksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNldENvbnRleHQoeyByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlKG9wZXJhdGlvbikpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3VsdCAmJiBlcnIucmVzdWx0LmVycm9ycyAmJiBlcnIucmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChlcnIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgSHR0cExpbmsgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhIdHRwTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdHRwTGluayhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNyZWF0ZUh0dHBMaW5rKG9wdGlvbnMpLnJlcXVlc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIdHRwTGluaztcbn0oY29yZS5BcG9sbG9MaW5rKSk7XG5cbmV4cG9ydHMuSHR0cExpbmsgPSBIdHRwTGluaztcbmV4cG9ydHMuY2hlY2tGZXRjaGVyID0gY2hlY2tGZXRjaGVyO1xuZXhwb3J0cy5jcmVhdGVIdHRwTGluayA9IGNyZWF0ZUh0dHBMaW5rO1xuZXhwb3J0cy5jcmVhdGVTaWduYWxJZlN1cHBvcnRlZCA9IGNyZWF0ZVNpZ25hbElmU3VwcG9ydGVkO1xuZXhwb3J0cy5kZWZhdWx0UHJpbnRlciA9IGRlZmF1bHRQcmludGVyO1xuZXhwb3J0cy5mYWxsYmFja0h0dHBDb25maWcgPSBmYWxsYmFja0h0dHBDb25maWc7XG5leHBvcnRzLnBhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2UgPSBwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlO1xuZXhwb3J0cy5yZXdyaXRlVVJJRm9yR0VUID0gcmV3cml0ZVVSSUZvckdFVDtcbmV4cG9ydHMuc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5ID0gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5O1xuZXhwb3J0cy5zZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbCA9IHNlbGVjdEh0dHBPcHRpb25zQW5kQm9keUludGVybmFsO1xuZXhwb3J0cy5zZWxlY3RVUkkgPSBzZWxlY3RVUkk7XG5leHBvcnRzLnNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyID0gc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwLmNqcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcycpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcblxuZnVuY3Rpb24gZnJvbUVycm9yKGVycm9yVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWxpdGllcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvclZhbHVlKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdG9Qcm9taXNlKG9ic2VydmFibGUpIHtcbiAgICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIlByb21pc2UgV3JhcHBlciBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlIHJlc3VsdHMgZnJvbSBPYnNlcnZhYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UpIHtcbiAgICByZXR1cm4gbmV3IHV0aWxpdGllcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XG4gICAgfSk7XG59XG5cbnZhciB0aHJvd1NlcnZlckVycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXN1bHQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdTZXJ2ZXJFcnJvcic7XG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGVycm9yLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aHJvdyBlcnJvcjtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciBPUEVSQVRJT05fRklFTERTID0gW1xuICAgICAgICAncXVlcnknLFxuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgICAgICd2YXJpYWJsZXMnLFxuICAgICAgICAnZXh0ZW5zaW9ucycsXG4gICAgICAgICdjb250ZXh0JyxcbiAgICBdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24pOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICBpZiAoT1BFUkFUSU9OX0ZJRUxEUy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJpbGxlZ2FsIGFyZ3VtZW50OiBcIi5jb25jYXQoa2V5KSkgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcigyNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uKHN0YXJ0aW5nLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgY29udGV4dCA9IHRzbGliLl9fYXNzaWduKHt9LCBzdGFydGluZyk7XG4gICAgdmFyIHNldENvbnRleHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIG5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29udGV4dCksIG5leHQoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wZXJhdGlvbiwgJ3NldENvbnRleHQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2V0Q29udGV4dCxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3BlcmF0aW9uLCAnZ2V0Q29udGV4dCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBnZXRDb250ZXh0LFxuICAgIH0pO1xuICAgIHJldHVybiBvcGVyYXRpb247XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICB2YXIgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgICAgIHZhcmlhYmxlczogb3BlcmF0aW9uLnZhcmlhYmxlcyB8fCB7fSxcbiAgICAgICAgZXh0ZW5zaW9uczogb3BlcmF0aW9uLmV4dGVuc2lvbnMgfHwge30sXG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5vcGVyYXRpb25OYW1lLFxuICAgICAgICBxdWVyeTogb3BlcmF0aW9uLnF1ZXJ5LFxuICAgIH07XG4gICAgaWYgKCF0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUgPVxuICAgICAgICAgICAgdHlwZW9mIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnF1ZXJ5ICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gdXRpbGl0aWVzLmdldE9wZXJhdGlvbk5hbWUodHJhbnNmb3JtZWRPcGVyYXRpb24ucXVlcnkpIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cblxuZXhwb3J0cy5jcmVhdGVPcGVyYXRpb24gPSBjcmVhdGVPcGVyYXRpb247XG5leHBvcnRzLmZyb21FcnJvciA9IGZyb21FcnJvcjtcbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmcm9tUHJvbWlzZTtcbmV4cG9ydHMudGhyb3dTZXJ2ZXJFcnJvciA9IHRocm93U2VydmVyRXJyb3I7XG5leHBvcnRzLnRvUHJvbWlzZSA9IHRvUHJvbWlzZTtcbmV4cG9ydHMudHJhbnNmb3JtT3BlcmF0aW9uID0gdHJhbnNmb3JtT3BlcmF0aW9uO1xuZXhwb3J0cy52YWxpZGF0ZU9wZXJhdGlvbiA9IHZhbGlkYXRlT3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgnLi9yZWFjdCcpO1xuXG5cblxuZm9yICh2YXIgayBpbiBjb3JlKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIGV4cG9ydHNba10gPSBjb3JlW2tdO1xufVxuZm9yICh2YXIgayBpbiByZWFjdCkge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBleHBvcnRzW2tdID0gcmVhY3Rba107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmNqcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZSkge1xuICAgICAgICAgICAgbltrXSA9IGVba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbnZhciBjb250ZXh0S2V5ID0gdXRpbGl0aWVzLmNhblVzZVN5bWJvbFxuICAgID8gU3ltYm9sLmZvcignX19BUE9MTE9fQ09OVEVYVF9fJylcbiAgICA6ICdfX0FQT0xMT19DT05URVhUX18nO1xuZnVuY3Rpb24gZ2V0QXBvbGxvQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dFtjb250ZXh0S2V5XTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCwgY29udGV4dEtleSwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoe30pLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmRpc3BsYXlOYW1lID0gJ0Fwb2xsb0NvbnRleHQnO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIEFwb2xsb0NvbnN1bWVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGNvbnRleHQgJiYgY29udGV4dC5jbGllbnQsICdDb3VsZCBub3QgZmluZCBcImNsaWVudFwiIGluIHRoZSBjb250ZXh0IG9mIEFwb2xsb0NvbnN1bWVyLiAnICtcbiAgICAgICAgICAgICdXcmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhbiA8QXBvbGxvUHJvdmlkZXI+LicpIDogZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dCAmJiBjb250ZXh0LmNsaWVudCwgMjUpO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dC5jbGllbnQpO1xuICAgIH0pKTtcbn07XG5cbnZhciBBcG9sbG9Qcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgaWYgKGNsaWVudCAmJiBjb250ZXh0LmNsaWVudCAhPT0gY2xpZW50KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCwgeyBjbGllbnQ6IGNsaWVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dC5jbGllbnQsICdBcG9sbG9Qcm92aWRlciB3YXMgbm90IHBhc3NlZCBhIGNsaWVudCBpbnN0YW5jZS4gTWFrZSAnICtcbiAgICAgICAgICAgICdzdXJlIHlvdSBwYXNzIGluIHlvdXIgY2xpZW50IHZpYSB0aGUgXCJjbGllbnRcIiBwcm9wLicpIDogZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dC5jbGllbnQsIDI2KTtcbiAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbikpO1xuICAgIH0pKTtcbn07XG5cbmV4cG9ydHMuQXBvbGxvQ29uc3VtZXIgPSBBcG9sbG9Db25zdW1lcjtcbmV4cG9ydHMuQXBvbGxvUHJvdmlkZXIgPSBBcG9sbG9Qcm92aWRlcjtcbmV4cG9ydHMuZ2V0QXBvbGxvQ29udGV4dCA9IGdldEFwb2xsb0NvbnRleHQ7XG5leHBvcnRzLnJlc2V0QXBvbGxvQ29udGV4dCA9IGdldEFwb2xsb0NvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmNqcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi4vY29udGV4dCcpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMnKTtcbnZhciBlcXVhbGl0eSA9IHJlcXVpcmUoJ0B3cnkvZXF1YWxpdHknKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICAgICAgICBuW2tdID0gZVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcblxuZnVuY3Rpb24gdXNlQXBvbGxvQ2xpZW50KG92ZXJyaWRlKSB7XG4gICAgdmFyIGNvbnRleHQkMSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dC5nZXRBcG9sbG9Db250ZXh0KCkpO1xuICAgIHZhciBjbGllbnQgPSBvdmVycmlkZSB8fCBjb250ZXh0JDEuY2xpZW50O1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghIWNsaWVudCwgJ0NvdWxkIG5vdCBmaW5kIFwiY2xpZW50XCIgaW4gdGhlIGNvbnRleHQgb3IgcGFzc2VkIGluIGFzIGFuIG9wdGlvbi4gJyArXG4gICAgICAgICdXcmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhbiA8QXBvbGxvUHJvdmlkZXI+LCBvciBwYXNzIGFuIEFwb2xsb0NsaWVudCAnICtcbiAgICAgICAgJ2luc3RhbmNlIGluIHZpYSBvcHRpb25zLicpIDogZ2xvYmFscy5pbnZhcmlhbnQoISFjbGllbnQsIDI5KTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuXG52YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTtcbnZhciB1U0VTS2V5ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xudmFyIHJlYWxIb29rID0gUmVhY3RfX25hbWVzcGFjZVt1U0VTS2V5XTtcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHJlYWxIb29rIHx8IChmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgIGlmIChfX0RFVl9fICYmXG4gICAgICAgICFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gZ2V0U25hcHNob3QoKSkge1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQuZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG4gICAgfVxuICAgIHZhciBfYSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoeyBpbnN0OiB7IHZhbHVlOiB2YWx1ZSwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH0gfSksIGluc3QgPSBfYVswXS5pbnN0LCBmb3JjZVVwZGF0ZSA9IF9hWzFdO1xuICAgIGlmICh1dGlsaXRpZXMuY2FuVXNlTGF5b3V0RWZmZWN0KSB7XG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdCwgeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9KTtcbiAgICAgICAgICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdCwgeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9KTtcbiAgICB9XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gaGFuZGxlU3RvcmVDaGFuZ2UoKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW3N1YnNjcmliZV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn0pO1xuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChfYSkge1xuICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBnZXRTbmFwc2hvdCA9IF9hLmdldFNuYXBzaG90O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZ2V0U25hcHNob3QoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHVzZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiB1c2VJbnRlcm5hbFN0YXRlKHVzZUFwb2xsb0NsaWVudChvcHRpb25zLmNsaWVudCksIHF1ZXJ5KS51c2VRdWVyeShvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZUludGVybmFsU3RhdGUoY2xpZW50LCBxdWVyeSkge1xuICAgIHZhciBzdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGlmICghc3RhdGVSZWYuY3VycmVudCB8fFxuICAgICAgICBjbGllbnQgIT09IHN0YXRlUmVmLmN1cnJlbnQuY2xpZW50IHx8XG4gICAgICAgIHF1ZXJ5ICE9PSBzdGF0ZVJlZi5jdXJyZW50LnF1ZXJ5KSB7XG4gICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBuZXcgSW50ZXJuYWxTdGF0ZShjbGllbnQsIHF1ZXJ5LCBzdGF0ZVJlZi5jdXJyZW50KTtcbiAgICB9XG4gICAgdmFyIHN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSgwKTsgX2FbMF07IHZhciBzZXRUaWNrID0gX2FbMV07XG4gICAgc3RhdGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpY2soZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuIHRpY2sgKyAxOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbnZhciBJbnRlcm5hbFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcm5hbFN0YXRlKGNsaWVudCwgcXVlcnksIHByZXZpb3VzKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuYXN5bmNSZXNvbHZlRm5zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnNUb0lnbm9yZU9uY2UgPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrU2V0ID8gV2Vha1NldCA6IFNldCkoKTtcbiAgICAgICAgdGhpcy5zc3JEaXNhYmxlZFJlc3VsdCA9IHV0aWxpdGllcy5tYXliZURlZXBGcmVlemUoe1xuICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBjb3JlLk5ldHdvcmtTdGF0dXMubG9hZGluZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2tpcFN0YW5kYnlSZXN1bHQgPSB1dGlsaXRpZXMubWF5YmVEZWVwRnJlZXplKHtcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IGNvcmUuTmV0d29ya1N0YXR1cy5yZWFkeSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9RdWVyeVJlc3VsdENhY2hlID0gbmV3ICh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG4gICAgICAgIHBhcnNlci52ZXJpZnlEb2N1bWVudFR5cGUocXVlcnksIHBhcnNlci5Eb2N1bWVudFR5cGUuUXVlcnkpO1xuICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSBwcmV2aW91cyAmJiBwcmV2aW91cy5yZXN1bHQ7XG4gICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSBwcmV2aW91c1Jlc3VsdCAmJiBwcmV2aW91c1Jlc3VsdC5kYXRhO1xuICAgICAgICBpZiAocHJldmlvdXNEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRGF0YSA9IHByZXZpb3VzRGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKFwiQ2FsbGluZyBkZWZhdWx0IG5vLW9wIGltcGxlbWVudGF0aW9uIG9mIEludGVybmFsU3RhdGUjZm9yY2VVcGRhdGVcIik7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5hc3luY1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpcy5hc3luY1Jlc29sdmVGbnMuYWRkKHJlc29sdmUpO1xuICAgICAgICAgICAgX3RoaXMub3B0aW9uc1RvSWdub3JlT25jZS5hZGQoX3RoaXMud2F0Y2hRdWVyeU9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS51c2VRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVuZGVyUHJvbWlzZXMgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQuZ2V0QXBvbGxvQ29udGV4dCgpKS5yZW5kZXJQcm9taXNlcztcbiAgICAgICAgdGhpcy51c2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgb2JzUXVlcnkgPSB0aGlzLnVzZU9ic2VydmFibGVRdWVyeSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmUoUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJlbmRlclByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbk5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gX3RoaXMucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYnNRdWVyeS5nZXRDdXJyZW50UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0LmxvYWRpbmcgPT09IHJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0Lm5ldHdvcmtTdGF0dXMgPT09IHJlc3VsdC5uZXR3b3JrU3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5LmVxdWFsKHByZXZpb3VzUmVzdWx0LmRhdGEsIHJlc3VsdC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBvYnNRdWVyeVtcImxhc3RcIl07XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JzUXVlcnkucmVzZXRMYXN0UmVzdWx0cygpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBvYnNRdWVyeS5zdWJzY3JpYmUob25OZXh0LCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic1F1ZXJ5W1wibGFzdFwiXSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChlcnJvciwgJ2dyYXBoUUxFcnJvcnMnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gX3RoaXMucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNSZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByZXZpb3VzUmVzdWx0ICYmIHByZXZpb3VzUmVzdWx0LmxvYWRpbmcpIHx8XG4gICAgICAgICAgICAgICAgICAgICFlcXVhbGl0eS5lcXVhbChlcnJvciwgcHJldmlvdXNSZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAocHJldmlvdXNSZXN1bHQgJiYgcHJldmlvdXNSZXN1bHQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IGNvcmUuTmV0d29ya1N0YXR1cy5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBvYnNRdWVyeS5zdWJzY3JpYmUob25OZXh0LCBvbkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgb2JzUXVlcnksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclByb21pc2VzLFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzYWJsZU5ldHdvcmtGZXRjaGVzLFxuICAgICAgICBdKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0Q3VycmVudFJlc3VsdCgpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nZXRDdXJyZW50UmVzdWx0KCk7IH0pO1xuICAgICAgICB0aGlzLnVuc2FmZUhhbmRsZVBhcnRpYWxSZWZldGNoKHJlc3VsdCk7XG4gICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHRoaXMudG9RdWVyeVJlc3VsdChyZXN1bHQpO1xuICAgICAgICBpZiAoIXF1ZXJ5UmVzdWx0LmxvYWRpbmcgJiYgdGhpcy5hc3luY1Jlc29sdmVGbnMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3luY1Jlc29sdmVGbnMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZShxdWVyeVJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5hc3luY1Jlc29sdmVGbnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHQ7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS51c2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgd2F0Y2hRdWVyeU9wdGlvbnMgPSB0aGlzLmNyZWF0ZVdhdGNoUXVlcnlPcHRpb25zKHRoaXMucXVlcnlIb29rT3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VycmVudFdhdGNoUXVlcnlPcHRpb25zID0gdGhpcy53YXRjaFF1ZXJ5T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1RvSWdub3JlT25jZS5oYXMoY3VycmVudFdhdGNoUXVlcnlPcHRpb25zKSB8fFxuICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKHdhdGNoUXVlcnlPcHRpb25zLCBjdXJyZW50V2F0Y2hRdWVyeU9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoUXVlcnlPcHRpb25zID0gd2F0Y2hRdWVyeU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY3VycmVudFdhdGNoUXVlcnlPcHRpb25zICYmIHRoaXMub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1RvSWdub3JlT25jZS5kZWxldGUoY3VycmVudFdhdGNoUXVlcnlPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmFibGUucmVvYnNlcnZlKHRoaXMuZ2V0T2JzUXVlcnlPcHRpb25zKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNEYXRhID0gKChfYSA9IHRoaXMucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgfHwgdGhpcy5wcmV2aW91c0RhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlZCA9IG9wdGlvbnMub25Db21wbGV0ZWQgfHwgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUub25Db21wbGV0ZWQ7XG4gICAgICAgIHRoaXMub25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5vbkVycm9yO1xuICAgICAgICBpZiAoKHRoaXMucmVuZGVyUHJvbWlzZXMgfHwgdGhpcy5jbGllbnQuZGlzYWJsZU5ldHdvcmtGZXRjaGVzKSAmJlxuICAgICAgICAgICAgdGhpcy5xdWVyeUhvb2tPcHRpb25zLnNzciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICF0aGlzLnF1ZXJ5SG9va09wdGlvbnMuc2tpcCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLnNzckRpc2FibGVkUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucXVlcnlIb29rT3B0aW9ucy5za2lwIHx8XG4gICAgICAgICAgICB0aGlzLndhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5ID09PSAnc3RhbmRieScpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5za2lwU3RhbmRieVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlc3VsdCA9PT0gdGhpcy5zc3JEaXNhYmxlZFJlc3VsdCB8fFxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPT09IHRoaXMuc2tpcFN0YW5kYnlSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5nZXRPYnNRdWVyeU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b01lcmdlID0gW107XG4gICAgICAgIHZhciBnbG9iYWxEZWZhdWx0cyA9IHRoaXMuY2xpZW50LmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnk7XG4gICAgICAgIGlmIChnbG9iYWxEZWZhdWx0cylcbiAgICAgICAgICAgIHRvTWVyZ2UucHVzaChnbG9iYWxEZWZhdWx0cyk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5SG9va09wdGlvbnMuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRvTWVyZ2UucHVzaCh0aGlzLnF1ZXJ5SG9va09wdGlvbnMuZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRvTWVyZ2UucHVzaCh1dGlsaXRpZXMuY29tcGFjdCh0aGlzLm9ic2VydmFibGUgJiYgdGhpcy5vYnNlcnZhYmxlLm9wdGlvbnMsIHRoaXMud2F0Y2hRdWVyeU9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHRvTWVyZ2UucmVkdWNlKGNvcmUubWVyZ2VPcHRpb25zKTtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLmNyZWF0ZVdhdGNoUXVlcnlPcHRpb25zID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgaWYgKF9hID09PSB2b2lkIDApIHsgX2EgPSB7fTsgfVxuICAgICAgICB2YXIgc2tpcCA9IF9hLnNraXA7IF9hLnNzcjsgX2Eub25Db21wbGV0ZWQ7IF9hLm9uRXJyb3I7IF9hLmRpc3BsYXlOYW1lOyBfYS5kZWZhdWx0T3B0aW9uczsgdmFyIG90aGVyT3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wic2tpcFwiLCBcInNzclwiLCBcIm9uQ29tcGxldGVkXCIsIFwib25FcnJvclwiLCBcImRpc3BsYXlOYW1lXCIsIFwiZGVmYXVsdE9wdGlvbnNcIl0pO1xuICAgICAgICB2YXIgd2F0Y2hRdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG90aGVyT3B0aW9ucywgeyBxdWVyeTogdGhpcy5xdWVyeSB9KTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyUHJvbWlzZXMgJiZcbiAgICAgICAgICAgICh3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ25ldHdvcmstb25seScgfHxcbiAgICAgICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ2NhY2hlLWFuZC1uZXR3b3JrJykpIHtcbiAgICAgICAgICAgIHdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5ID0gJ2NhY2hlLWZpcnN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdhdGNoUXVlcnlPcHRpb25zLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgd2F0Y2hRdWVyeU9wdGlvbnMudmFyaWFibGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIHZhciBfYyA9IHdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9jID09PSB2b2lkIDAgPyB0aGlzLmdldERlZmF1bHRGZXRjaFBvbGljeSgpIDogX2MsIF9kID0gd2F0Y2hRdWVyeU9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LCBpbml0aWFsRmV0Y2hQb2xpY3kgPSBfZCA9PT0gdm9pZCAwID8gZmV0Y2hQb2xpY3kgOiBfZDtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24od2F0Y2hRdWVyeU9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3k6IGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogJ3N0YW5kYnknLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5KSB7XG4gICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9XG4gICAgICAgICAgICAgICAgKChfYiA9IHRoaXMub2JzZXJ2YWJsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5KSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldERlZmF1bHRGZXRjaFBvbGljeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaFF1ZXJ5T3B0aW9ucztcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLmdldERlZmF1bHRGZXRjaFBvbGljeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICgoKF9hID0gdGhpcy5xdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmV0Y2hQb2xpY3kpIHx8XG4gICAgICAgICAgICAoKF9iID0gdGhpcy5jbGllbnQuZGVmYXVsdE9wdGlvbnMud2F0Y2hRdWVyeSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZldGNoUG9saWN5KSB8fFxuICAgICAgICAgICAgXCJjYWNoZS1maXJzdFwiKTtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKGRhdGEpIHsgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUudXNlT2JzZXJ2YWJsZVF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzUXVlcnkgPSB0aGlzLm9ic2VydmFibGUgPVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9taXNlc1xuICAgICAgICAgICAgICAgICYmIHRoaXMucmVuZGVyUHJvbWlzZXMuZ2V0U1NST2JzZXJ2YWJsZSh0aGlzLndhdGNoUXVlcnlPcHRpb25zKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMub2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY2xpZW50LndhdGNoUXVlcnkodGhpcy5nZXRPYnNRdWVyeU9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMub2JzUXVlcnlGaWVsZHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICByZWZldGNoOiBvYnNRdWVyeS5yZWZldGNoLmJpbmQob2JzUXVlcnkpLFxuICAgICAgICAgICAgcmVvYnNlcnZlOiBvYnNRdWVyeS5yZW9ic2VydmUuYmluZChvYnNRdWVyeSksXG4gICAgICAgICAgICBmZXRjaE1vcmU6IG9ic1F1ZXJ5LmZldGNoTW9yZS5iaW5kKG9ic1F1ZXJ5KSxcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXJ5OiBvYnNRdWVyeS51cGRhdGVRdWVyeS5iaW5kKG9ic1F1ZXJ5KSxcbiAgICAgICAgICAgIHN0YXJ0UG9sbGluZzogb2JzUXVlcnkuc3RhcnRQb2xsaW5nLmJpbmQob2JzUXVlcnkpLFxuICAgICAgICAgICAgc3RvcFBvbGxpbmc6IG9ic1F1ZXJ5LnN0b3BQb2xsaW5nLmJpbmQob2JzUXVlcnkpLFxuICAgICAgICAgICAgc3Vic2NyaWJlVG9Nb3JlOiBvYnNRdWVyeS5zdWJzY3JpYmVUb01vcmUuYmluZChvYnNRdWVyeSksXG4gICAgICAgIH0pOyB9LCBbb2JzUXVlcnldKTtcbiAgICAgICAgdmFyIHNzckFsbG93ZWQgPSAhKHRoaXMucXVlcnlIb29rT3B0aW9ucy5zc3IgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5SG9va09wdGlvbnMuc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclByb21pc2VzICYmIHNzckFsbG93ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvbWlzZXMucmVnaXN0ZXJTU1JPYnNlcnZhYmxlKG9ic1F1ZXJ5KTtcbiAgICAgICAgICAgIGlmIChvYnNRdWVyeS5nZXRDdXJyZW50UmVzdWx0KCkubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvbWlzZXMuYWRkT2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZShvYnNRdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ic1F1ZXJ5O1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24gKG5leHRSZXN1bHQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIGlmIChwcmV2aW91c1Jlc3VsdCAmJiBwcmV2aW91c1Jlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRGF0YSA9IHByZXZpb3VzUmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3JPckNvbXBsZXRlZChuZXh0UmVzdWx0KTtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLmhhbmRsZUVycm9yT3JDb21wbGV0ZWQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0LmxvYWRpbmcpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlZChyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLmdldEN1cnJlbnRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3JPckNvbXBsZXRlZCh0aGlzLnJlc3VsdCA9IHRoaXMub2JzZXJ2YWJsZS5nZXRDdXJyZW50UmVzdWx0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLnRvUXVlcnlSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHRoaXMudG9RdWVyeVJlc3VsdENhY2hlLmdldChyZXN1bHQpO1xuICAgICAgICBpZiAocXVlcnlSZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHQ7XG4gICAgICAgIHZhciBkYXRhID0gcmVzdWx0LmRhdGE7IHJlc3VsdC5wYXJ0aWFsOyB2YXIgcmVzdWx0V2l0aG91dFBhcnRpYWwgPSB0c2xpYi5fX3Jlc3QocmVzdWx0LCBbXCJkYXRhXCIsIFwicGFydGlhbFwiXSk7XG4gICAgICAgIHRoaXMudG9RdWVyeVJlc3VsdENhY2hlLnNldChyZXN1bHQsIHF1ZXJ5UmVzdWx0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyBkYXRhOiBkYXRhIH0sIHJlc3VsdFdpdGhvdXRQYXJ0aWFsKSwgdGhpcy5vYnNRdWVyeUZpZWxkcyksIHsgY2xpZW50OiB0aGlzLmNsaWVudCwgb2JzZXJ2YWJsZTogdGhpcy5vYnNlcnZhYmxlLCB2YXJpYWJsZXM6IHRoaXMub2JzZXJ2YWJsZS52YXJpYWJsZXMsIGNhbGxlZDogIXRoaXMucXVlcnlIb29rT3B0aW9ucy5za2lwLCBwcmV2aW91c0RhdGE6IHRoaXMucHJldmlvdXNEYXRhIH0pKTtcbiAgICAgICAgaWYgKCFxdWVyeVJlc3VsdC5lcnJvciAmJiB1dGlsaXRpZXMuaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpKSB7XG4gICAgICAgICAgICBxdWVyeVJlc3VsdC5lcnJvciA9IG5ldyBlcnJvcnMuQXBvbGxvRXJyb3IoeyBncmFwaFFMRXJyb3JzOiByZXN1bHQuZXJyb3JzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeVJlc3VsdDtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLnVuc2FmZUhhbmRsZVBhcnRpYWxSZWZldGNoID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnBhcnRpYWwgJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnlIb29rT3B0aW9ucy5wYXJ0aWFsUmVmZXRjaCAmJlxuICAgICAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAoIXJlc3VsdC5kYXRhIHx8IE9iamVjdC5rZXlzKHJlc3VsdC5kYXRhKS5sZW5ndGggPT09IDApICYmXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUub3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLW9ubHknKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwge1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogY29yZS5OZXR3b3JrU3RhdHVzLnJlZmV0Y2gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZS5yZWZldGNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbnRlcm5hbFN0YXRlO1xufSgpKTtcblxudmFyIEVBR0VSX01FVEhPRFMgPSBbXG4gICAgJ3JlZmV0Y2gnLFxuICAgICdyZW9ic2VydmUnLFxuICAgICdmZXRjaE1vcmUnLFxuICAgICd1cGRhdGVRdWVyeScsXG4gICAgJ3N0YXJ0UG9sbGluZycsXG4gICAgJ3N1YnNjcmliZVRvTW9yZScsXG5dO1xuZnVuY3Rpb24gdXNlTGF6eVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIGludGVybmFsU3RhdGUgPSB1c2VJbnRlcm5hbFN0YXRlKHVzZUFwb2xsb0NsaWVudChvcHRpb25zICYmIG9wdGlvbnMuY2xpZW50KSwgcXVlcnkpO1xuICAgIHZhciBleGVjT3B0aW9uc1JlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHZhciBtZXJnZWQgPSBleGVjT3B0aW9uc1JlZi5jdXJyZW50XG4gICAgICAgID8gdXRpbGl0aWVzLm1lcmdlT3B0aW9ucyhvcHRpb25zLCBleGVjT3B0aW9uc1JlZi5jdXJyZW50KVxuICAgICAgICA6IG9wdGlvbnM7XG4gICAgdmFyIHVzZVF1ZXJ5UmVzdWx0ID0gaW50ZXJuYWxTdGF0ZS51c2VRdWVyeSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbWVyZ2VkKSwgeyBza2lwOiAhZXhlY09wdGlvbnNSZWYuY3VycmVudCB9KSk7XG4gICAgdmFyIGluaXRpYWxGZXRjaFBvbGljeSA9IHVzZVF1ZXJ5UmVzdWx0Lm9ic2VydmFibGUub3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgfHxcbiAgICAgICAgaW50ZXJuYWxTdGF0ZS5nZXREZWZhdWx0RmV0Y2hQb2xpY3koKTtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih1c2VRdWVyeVJlc3VsdCwge1xuICAgICAgICBjYWxsZWQ6ICEhZXhlY09wdGlvbnNSZWYuY3VycmVudCxcbiAgICB9KTtcbiAgICB2YXIgZWFnZXJNZXRob2RzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlYWdlck1ldGhvZHMgPSB7fTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBlYWdlck1ldGhvZHNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNPcHRpb25zUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY09wdGlvbnNSZWYuY3VycmVudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsU3RhdGUuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBFQUdFUl9NRVRIT0RTXzEgPSBFQUdFUl9NRVRIT0RTOyBfaSA8IEVBR0VSX01FVEhPRFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBFQUdFUl9NRVRIT0RTXzFbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlYWdlck1ldGhvZHM7XG4gICAgfSwgW10pO1xuICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBlYWdlck1ldGhvZHMpO1xuICAgIHZhciBleGVjdXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV4ZWN1dGVPcHRpb25zKSB7XG4gICAgICAgIGV4ZWNPcHRpb25zUmVmLmN1cnJlbnQgPSBleGVjdXRlT3B0aW9ucyA/IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBleGVjdXRlT3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6IGV4ZWN1dGVPcHRpb25zLmZldGNoUG9saWN5IHx8IGluaXRpYWxGZXRjaFBvbGljeSB9KSA6IHtcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiBpbml0aWFsRmV0Y2hQb2xpY3ksXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcm9taXNlID0gaW50ZXJuYWxTdGF0ZVxuICAgICAgICAgICAgLmFzeW5jVXBkYXRlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChxdWVyeVJlc3VsdCkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbihxdWVyeVJlc3VsdCwgZWFnZXJNZXRob2RzKTsgfSk7XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbZXhlY3V0ZSwgcmVzdWx0XTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb24obXV0YXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xpZW50ID0gdXNlQXBvbGxvQ2xpZW50KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpO1xuICAgIHBhcnNlci52ZXJpZnlEb2N1bWVudFR5cGUobXV0YXRpb24sIHBhcnNlci5Eb2N1bWVudFR5cGUuTXV0YXRpb24pO1xuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgY2FsbGVkOiBmYWxzZSxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgIH0pLCByZXN1bHQgPSBfYVswXSwgc2V0UmVzdWx0ID0gX2FbMV07XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICBtdXRhdGlvbklkOiAwLFxuICAgICAgICBpc01vdW50ZWQ6IHRydWUsXG4gICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICBtdXRhdGlvbjogbXV0YXRpb24sXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgfSk7XG4gICAge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlZi5jdXJyZW50LCB7IGNsaWVudDogY2xpZW50LCBvcHRpb25zOiBvcHRpb25zLCBtdXRhdGlvbjogbXV0YXRpb24gfSk7XG4gICAgfVxuICAgIHZhciBleGVjdXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV4ZWN1dGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChleGVjdXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4ZWN1dGVPcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF9hID0gcmVmLmN1cnJlbnQsIGNsaWVudCA9IF9hLmNsaWVudCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIG11dGF0aW9uID0gX2EubXV0YXRpb247XG4gICAgICAgIHZhciBiYXNlT3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtdXRhdGlvbjogbXV0YXRpb24gfSk7XG4gICAgICAgIGlmICghcmVmLmN1cnJlbnQucmVzdWx0LmxvYWRpbmcgJiYgIWJhc2VPcHRpb25zLmlnbm9yZVJlc3VsdHMpIHtcbiAgICAgICAgICAgIHNldFJlc3VsdChyZWYuY3VycmVudC5yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBjYWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXV0YXRpb25JZCA9ICsrcmVmLmN1cnJlbnQubXV0YXRpb25JZDtcbiAgICAgICAgdmFyIGNsaWVudE9wdGlvbnMgPSBjb3JlLm1lcmdlT3B0aW9ucyhiYXNlT3B0aW9ucywgZXhlY3V0ZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50Lm11dGF0ZShjbGllbnRPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGEsIGVycm9ycyQxID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzJDEgJiYgZXJyb3JzJDEubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gbmV3IGVycm9ycy5BcG9sbG9FcnJvcih7IGdyYXBoUUxFcnJvcnM6IGVycm9ycyQxIH0pXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25JZCA9PT0gcmVmLmN1cnJlbnQubXV0YXRpb25JZCAmJlxuICAgICAgICAgICAgICAgICFjbGllbnRPcHRpb25zLmlnbm9yZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVmLmN1cnJlbnQuaXNNb3VudGVkICYmICFlcXVhbGl0eS5lcXVhbChyZWYuY3VycmVudC5yZXN1bHQsIHJlc3VsdF8xKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQocmVmLmN1cnJlbnQucmVzdWx0ID0gcmVzdWx0XzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkNvbXBsZXRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgKF9jID0gZXhlY3V0ZU9wdGlvbnMub25Db21wbGV0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGV4ZWN1dGVPcHRpb25zLCByZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25JZCA9PT0gcmVmLmN1cnJlbnQubXV0YXRpb25JZCAmJlxuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eS5lcXVhbChyZWYuY3VycmVudC5yZXN1bHQsIHJlc3VsdF8yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQocmVmLmN1cnJlbnQucmVzdWx0ID0gcmVzdWx0XzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoKF9hID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uRXJyb3IpIHx8IGNsaWVudE9wdGlvbnMub25FcnJvcikge1xuICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIChfZCA9IGV4ZWN1dGVPcHRpb25zLm9uRXJyb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKGV4ZWN1dGVPcHRpb25zLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdm9pZCAwLCBlcnJvcnM6IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciByZXNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0UmVzdWx0KHsgY2FsbGVkOiBmYWxzZSwgbG9hZGluZzogZmFsc2UsIGNsaWVudDogY2xpZW50IH0pO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYuY3VycmVudC5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbZXhlY3V0ZSwgdHNsaWIuX19hc3NpZ24oeyByZXNldDogcmVzZXQgfSwgcmVzdWx0KV07XG59XG5cbmZ1bmN0aW9uIHVzZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xpZW50ID0gdXNlQXBvbGxvQ2xpZW50KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpO1xuICAgIHBhcnNlci52ZXJpZnlEb2N1bWVudFR5cGUoc3Vic2NyaXB0aW9uLCBwYXJzZXIuRG9jdW1lbnRUeXBlLlN1YnNjcmlwdGlvbik7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBsb2FkaW5nOiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwKSxcbiAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgfSksIHJlc3VsdCA9IF9hWzBdLCBzZXRSZXN1bHQgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgcXVlcnk6IHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgfSksIG9ic2VydmFibGUgPSBfYlswXSwgc2V0T2JzZXJ2YWJsZSA9IF9iWzFdO1xuICAgIHZhciBjYW5SZXNldE9ic2VydmFibGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoeyBjbGllbnQ6IGNsaWVudCwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB2YXIgc2hvdWxkUmVzdWJzY3JpYmUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkUmVzdWJzY3JpYmU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvdWxkUmVzdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc3Vic2NyaWJlID0gISFzaG91bGRSZXN1YnNjcmliZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXApIHtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwKSAhPT0gISgoX2EgPSByZWYuY3VycmVudC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcCkgfHwgY2FuUmVzZXRPYnNlcnZhYmxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0T2JzZXJ2YWJsZShudWxsKTtcbiAgICAgICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzaG91bGRSZXN1YnNjcmliZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIChjbGllbnQgIT09IHJlZi5jdXJyZW50LmNsaWVudCB8fFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiAhPT0gcmVmLmN1cnJlbnQuc3Vic2NyaXB0aW9uIHx8XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZXRjaFBvbGljeSkgIT09ICgoX2IgPSByZWYuY3VycmVudC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmV0Y2hQb2xpY3kpIHx8XG4gICAgICAgICAgICAgICAgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcCkgIT09ICEoKF9jID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNraXApIHx8XG4gICAgICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YXJpYWJsZXMsIChfZCA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52YXJpYWJsZXMpKSkgfHxcbiAgICAgICAgICAgIGNhblJlc2V0T2JzZXJ2YWJsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRPYnNlcnZhYmxlKGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICAgICAgY29udGV4dDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVmLmN1cnJlbnQsIHsgY2xpZW50OiBjbGllbnQsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuICAgIH0sIFtjbGllbnQsIHN1YnNjcmlwdGlvbiwgb3B0aW9ucywgY2FuUmVzZXRPYnNlcnZhYmxlUmVmLmN1cnJlbnRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGZldGNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2V0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uU3Vic2NyaXB0aW9uRGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uU3Vic2NyaXB0aW9uQ29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW29ic2VydmFibGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2VSZWFjdGl2ZVZhcihydikge1xuICAgIHZhciB2YWx1ZSA9IHJ2KCk7XG4gICAgdmFyIHNldFZhbHVlID0gUmVhY3QudXNlU3RhdGUodmFsdWUpWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9iYWJseVNhbWVWYWx1ZSA9IHJ2KCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gcHJvYmFibHlTYW1lVmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHByb2JhYmx5U2FtZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBydi5vbk5leHRDaGFuZ2Uoc2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZUFwb2xsb0NsaWVudCA9IHVzZUFwb2xsb0NsaWVudDtcbmV4cG9ydHMudXNlTGF6eVF1ZXJ5ID0gdXNlTGF6eVF1ZXJ5O1xuZXhwb3J0cy51c2VNdXRhdGlvbiA9IHVzZU11dGF0aW9uO1xuZXhwb3J0cy51c2VRdWVyeSA9IHVzZVF1ZXJ5O1xuZXhwb3J0cy51c2VSZWFjdGl2ZVZhciA9IHVzZVJlYWN0aXZlVmFyO1xuZXhwb3J0cy51c2VTdWJzY3JpcHRpb24gPSB1c2VTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMnKTtcblxuZXhwb3J0cy5Eb2N1bWVudFR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKERvY3VtZW50VHlwZSkge1xuICAgIERvY3VtZW50VHlwZVtEb2N1bWVudFR5cGVbXCJRdWVyeVwiXSA9IDBdID0gXCJRdWVyeVwiO1xuICAgIERvY3VtZW50VHlwZVtEb2N1bWVudFR5cGVbXCJNdXRhdGlvblwiXSA9IDFdID0gXCJNdXRhdGlvblwiO1xuICAgIERvY3VtZW50VHlwZVtEb2N1bWVudFR5cGVbXCJTdWJzY3JpcHRpb25cIl0gPSAyXSA9IFwiU3Vic2NyaXB0aW9uXCI7XG59KShleHBvcnRzLkRvY3VtZW50VHlwZSB8fCAoZXhwb3J0cy5Eb2N1bWVudFR5cGUgPSB7fSkpO1xudmFyIGNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gb3BlcmF0aW9uTmFtZSh0eXBlKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Eb2N1bWVudFR5cGUuUXVlcnk6XG4gICAgICAgICAgICBuYW1lID0gJ1F1ZXJ5JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuRG9jdW1lbnRUeXBlLk11dGF0aW9uOlxuICAgICAgICAgICAgbmFtZSA9ICdNdXRhdGlvbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLkRvY3VtZW50VHlwZS5TdWJzY3JpcHRpb246XG4gICAgICAgICAgICBuYW1lID0gJ1N1YnNjcmlwdGlvbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBwYXJzZXIoZG9jdW1lbnQpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KGRvY3VtZW50KTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIHZhciB2YXJpYWJsZXMsIHR5cGUsIG5hbWU7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KCEhZG9jdW1lbnQgJiYgISFkb2N1bWVudC5raW5kLCBcIkFyZ3VtZW50IG9mIFwiLmNvbmNhdChkb2N1bWVudCwgXCIgcGFzc2VkIHRvIHBhcnNlciB3YXMgbm90IGEgdmFsaWQgR3JhcGhRTCBcIikgK1xuICAgICAgICBcIkRvY3VtZW50Tm9kZS4gWW91IG1heSBuZWVkIHRvIHVzZSAnZ3JhcGhxbC10YWcnIG9yIGFub3RoZXIgbWV0aG9kIFwiICtcbiAgICAgICAgXCJ0byBjb252ZXJ0IHlvdXIgb3BlcmF0aW9uIGludG8gYSBkb2N1bWVudFwiKSA6IGdsb2JhbHMuaW52YXJpYW50KCEhZG9jdW1lbnQgJiYgISFkb2N1bWVudC5raW5kLCAzMCk7XG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuICAgIHZhciBxdWVyaWVzID0gW107XG4gICAgdmFyIG11dGF0aW9ucyA9IFtdO1xuICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRvY3VtZW50LmRlZmluaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgeCA9IF9hW19pXTtcbiAgICAgICAgaWYgKHgua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHgub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25zLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KCFmcmFnbWVudHMubGVuZ3RoIHx8XG4gICAgICAgIChxdWVyaWVzLmxlbmd0aCB8fCBtdXRhdGlvbnMubGVuZ3RoIHx8IHN1YnNjcmlwdGlvbnMubGVuZ3RoKSwgXCJQYXNzaW5nIG9ubHkgYSBmcmFnbWVudCB0byAnZ3JhcGhxbCcgaXMgbm90IHlldCBzdXBwb3J0ZWQuIFwiICtcbiAgICAgICAgXCJZb3UgbXVzdCBpbmNsdWRlIGEgcXVlcnksIHN1YnNjcmlwdGlvbiBvciBtdXRhdGlvbiBhcyB3ZWxsXCIpIDogZ2xvYmFscy5pbnZhcmlhbnQoIWZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAgICAgKHF1ZXJpZXMubGVuZ3RoIHx8IG11dGF0aW9ucy5sZW5ndGggfHwgc3Vic2NyaXB0aW9ucy5sZW5ndGgpLCAzMSk7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KHF1ZXJpZXMubGVuZ3RoICsgbXV0YXRpb25zLmxlbmd0aCArIHN1YnNjcmlwdGlvbnMubGVuZ3RoIDw9IDEsIFwicmVhY3QtYXBvbGxvIG9ubHkgc3VwcG9ydHMgYSBxdWVyeSwgc3Vic2NyaXB0aW9uLCBvciBhIG11dGF0aW9uIHBlciBIT0MuIFwiICtcbiAgICAgICAgXCJcIi5jb25jYXQoZG9jdW1lbnQsIFwiIGhhZCBcIikuY29uY2F0KHF1ZXJpZXMubGVuZ3RoLCBcIiBxdWVyaWVzLCBcIikuY29uY2F0KHN1YnNjcmlwdGlvbnMubGVuZ3RoLCBcIiBcIikgK1xuICAgICAgICBcInN1YnNjcmlwdGlvbnMgYW5kIFwiLmNvbmNhdChtdXRhdGlvbnMubGVuZ3RoLCBcIiBtdXRhdGlvbnMuIFwiKSArXG4gICAgICAgIFwiWW91IGNhbiB1c2UgJ2NvbXBvc2UnIHRvIGpvaW4gbXVsdGlwbGUgb3BlcmF0aW9uIHR5cGVzIHRvIGEgY29tcG9uZW50XCIpIDogZ2xvYmFscy5pbnZhcmlhbnQocXVlcmllcy5sZW5ndGggKyBtdXRhdGlvbnMubGVuZ3RoICsgc3Vic2NyaXB0aW9ucy5sZW5ndGggPD0gMSwgMzIpO1xuICAgIHR5cGUgPSBxdWVyaWVzLmxlbmd0aCA/IGV4cG9ydHMuRG9jdW1lbnRUeXBlLlF1ZXJ5IDogZXhwb3J0cy5Eb2N1bWVudFR5cGUuTXV0YXRpb247XG4gICAgaWYgKCFxdWVyaWVzLmxlbmd0aCAmJiAhbXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuRG9jdW1lbnRUeXBlLlN1YnNjcmlwdGlvbjtcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBxdWVyaWVzLmxlbmd0aFxuICAgICAgICA/IHF1ZXJpZXNcbiAgICAgICAgOiBtdXRhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA/IG11dGF0aW9uc1xuICAgICAgICAgICAgOiBzdWJzY3JpcHRpb25zO1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChkZWZpbml0aW9ucy5sZW5ndGggPT09IDEsIFwicmVhY3QtYXBvbGxvIG9ubHkgc3VwcG9ydHMgb25lIGRlZmluaXRpb24gcGVyIEhPQy4gXCIuY29uY2F0KGRvY3VtZW50LCBcIiBoYWQgXCIpICtcbiAgICAgICAgXCJcIi5jb25jYXQoZGVmaW5pdGlvbnMubGVuZ3RoLCBcIiBkZWZpbml0aW9ucy4gXCIpICtcbiAgICAgICAgXCJZb3UgY2FuIHVzZSAnY29tcG9zZScgdG8gam9pbiBtdWx0aXBsZSBvcGVyYXRpb24gdHlwZXMgdG8gYSBjb21wb25lbnRcIikgOiBnbG9iYWxzLmludmFyaWFudChkZWZpbml0aW9ucy5sZW5ndGggPT09IDEsIDMzKTtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zWzBdO1xuICAgIHZhcmlhYmxlcyA9IGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9ucyB8fCBbXTtcbiAgICBpZiAoZGVmaW5pdGlvbi5uYW1lICYmIGRlZmluaXRpb24ubmFtZS5raW5kID09PSAnTmFtZScpIHtcbiAgICAgICAgbmFtZSA9IGRlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hbWUgPSAnZGF0YSc7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkID0geyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlLCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9O1xuICAgIGNhY2hlLnNldChkb2N1bWVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5mdW5jdGlvbiB2ZXJpZnlEb2N1bWVudFR5cGUoZG9jdW1lbnQsIHR5cGUpIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gcGFyc2VyKGRvY3VtZW50KTtcbiAgICB2YXIgcmVxdWlyZWRPcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZSh0eXBlKTtcbiAgICB2YXIgdXNlZE9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lKG9wZXJhdGlvbi50eXBlKTtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQob3BlcmF0aW9uLnR5cGUgPT09IHR5cGUsIFwiUnVubmluZyBhIFwiLmNvbmNhdChyZXF1aXJlZE9wZXJhdGlvbk5hbWUsIFwiIHJlcXVpcmVzIGEgZ3JhcGhxbCBcIikgK1xuICAgICAgICBcIlwiLmNvbmNhdChyZXF1aXJlZE9wZXJhdGlvbk5hbWUsIFwiLCBidXQgYSBcIikuY29uY2F0KHVzZWRPcGVyYXRpb25OYW1lLCBcIiB3YXMgdXNlZCBpbnN0ZWFkLlwiKSkgOiBnbG9iYWxzLmludmFyaWFudChvcGVyYXRpb24udHlwZSA9PT0gdHlwZSwgMzQpO1xufVxuXG5leHBvcnRzLm9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLnZlcmlmeURvY3VtZW50VHlwZSA9IHZlcmlmeURvY3VtZW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xudmFyIGhvb2tzID0gcmVxdWlyZSgnLi9ob29rcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cblxuXG5leHBvcnRzLkFwb2xsb0NvbnN1bWVyID0gY29udGV4dC5BcG9sbG9Db25zdW1lcjtcbmV4cG9ydHMuQXBvbGxvUHJvdmlkZXIgPSBjb250ZXh0LkFwb2xsb1Byb3ZpZGVyO1xuZXhwb3J0cy5nZXRBcG9sbG9Db250ZXh0ID0gY29udGV4dC5nZXRBcG9sbG9Db250ZXh0O1xuZXhwb3J0cy5yZXNldEFwb2xsb0NvbnRleHQgPSBjb250ZXh0LnJlc2V0QXBvbGxvQ29udGV4dDtcbmV4cG9ydHMuRG9jdW1lbnRUeXBlID0gcGFyc2VyLkRvY3VtZW50VHlwZTtcbmV4cG9ydHMub3BlcmF0aW9uTmFtZSA9IHBhcnNlci5vcGVyYXRpb25OYW1lO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXIucGFyc2VyO1xuZm9yICh2YXIgayBpbiBob29rcykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBleHBvcnRzW2tdID0gaG9va3Nba107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c0ludmFyaWFudCA9IHJlcXVpcmUoJ3RzLWludmFyaWFudCcpO1xudmFyIHByb2Nlc3MkMSA9IHJlcXVpcmUoJ3RzLWludmFyaWFudC9wcm9jZXNzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcblxuZnVuY3Rpb24gbWF5YmUodGh1bmspIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGh1bmsoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbn1cblxudmFyIGdsb2JhbCQxID0gKG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbFRoaXM7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93OyB9KSB8fFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGY7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFsOyB9KSB8fFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heWJlLmNvbnN0cnVjdG9yKFwicmV0dXJuIHRoaXNcIikoKTsgfSkpO1xuXG52YXIgX18gPSBcIl9fXCI7XG52YXIgR0xPQkFMX0tFWSA9IFtfXywgX19dLmpvaW4oXCJERVZcIik7XG5mdW5jdGlvbiBnZXRERVYoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oX19ERVZfXyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsJDEsIEdMT0JBTF9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOVjsgfSkgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWwkMVtHTE9CQUxfS0VZXTtcbiAgICB9XG59XG52YXIgREVWID0gZ2V0REVWKCk7XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBvcmFyeUdsb2JhbHMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBncmFwaHFsLlNvdXJjZSA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2VzcyQxLnJlbW92ZSgpIDogcHJvY2VzcyQxLnJlbW92ZSgpO1xufVxuXG5mdW5jdGlvbiBjaGVja0RFVigpIHtcbiAgICBfX0RFVl9fID8gdHNJbnZhcmlhbnQuaW52YXJpYW50KFwiYm9vbGVhblwiID09PSB0eXBlb2YgREVWLCBERVYpIDogdHNJbnZhcmlhbnQuaW52YXJpYW50KFwiYm9vbGVhblwiID09PSB0eXBlb2YgREVWLCAzNik7XG59XG5yZW1vdmVUZW1wb3JhcnlHbG9iYWxzKCk7XG5jaGVja0RFVigpO1xuXG5leHBvcnRzLkludmFyaWFudEVycm9yID0gdHNJbnZhcmlhbnQuSW52YXJpYW50RXJyb3I7XG5leHBvcnRzLmludmFyaWFudCA9IHRzSW52YXJpYW50LmludmFyaWFudDtcbmV4cG9ydHMuREVWID0gREVWO1xuZXhwb3J0cy5jaGVja0RFViA9IGNoZWNrREVWO1xuZXhwb3J0cy5nbG9iYWwgPSBnbG9iYWwkMTtcbmV4cG9ydHMubWF5YmUgPSBtYXliZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpO1xudmFyIGdyYXBocWwgPSByZXF1aXJlKCdncmFwaHFsJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIHplbk9ic2VydmFibGVUcyA9IHJlcXVpcmUoJ3plbi1vYnNlcnZhYmxlLXRzJyk7XG5yZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG5mdW5jdGlvbiBzaG91bGRJbmNsdWRlKF9hLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IF9hLmRpcmVjdGl2ZXM7XG4gICAgaWYgKCFkaXJlY3RpdmVzIHx8ICFkaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEluY2x1c2lvbkRpcmVjdGl2ZXMoZGlyZWN0aXZlcykuZXZlcnkoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkaXJlY3RpdmUgPSBfYS5kaXJlY3RpdmUsIGlmQXJndW1lbnQgPSBfYS5pZkFyZ3VtZW50O1xuICAgICAgICB2YXIgZXZhbGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlmQXJndW1lbnQudmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJykge1xuICAgICAgICAgICAgZXZhbGVkVmFsdWUgPSB2YXJpYWJsZXMgJiYgdmFyaWFibGVzW2lmQXJndW1lbnQudmFsdWUubmFtZS52YWx1ZV07XG4gICAgICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZXZhbGVkVmFsdWUgIT09IHZvaWQgMCwgXCJJbnZhbGlkIHZhcmlhYmxlIHJlZmVyZW5jZWQgaW4gQFwiLmNvbmNhdChkaXJlY3RpdmUubmFtZS52YWx1ZSwgXCIgZGlyZWN0aXZlLlwiKSkgOiBnbG9iYWxzLmludmFyaWFudChldmFsZWRWYWx1ZSAhPT0gdm9pZCAwLCAzNyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmFsZWRWYWx1ZSA9IGlmQXJndW1lbnQudmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnc2tpcCcgPyAhZXZhbGVkVmFsdWUgOiBldmFsZWRWYWx1ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZU5hbWVzKHJvb3QpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBncmFwaHFsLnZpc2l0KHJvb3QsIHtcbiAgICAgICAgRGlyZWN0aXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbmFtZXMucHVzaChub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QpIHtcbiAgICByZXR1cm4gZ2V0RGlyZWN0aXZlTmFtZXMocm9vdCkuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xOyB9KTtcbn1cbmZ1bmN0aW9uIGhhc0NsaWVudEV4cG9ydHMoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gKGRvY3VtZW50ICYmXG4gICAgICAgIGhhc0RpcmVjdGl2ZXMoWydjbGllbnQnXSwgZG9jdW1lbnQpICYmXG4gICAgICAgIGhhc0RpcmVjdGl2ZXMoWydleHBvcnQnXSwgZG9jdW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzSW5jbHVzaW9uRGlyZWN0aXZlKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EubmFtZS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPT09ICdza2lwJyB8fCB2YWx1ZSA9PT0gJ2luY2x1ZGUnO1xufVxuZnVuY3Rpb24gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhkaXJlY3RpdmVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzSW5jbHVzaW9uRGlyZWN0aXZlKGRpcmVjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUFyZ3VtZW50cyA9IGRpcmVjdGl2ZS5hcmd1bWVudHM7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGRpcmVjdGl2ZUFyZ3VtZW50cyAmJiBkaXJlY3RpdmVBcmd1bWVudHMubGVuZ3RoID09PSAxLCBcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciB0aGUgQFwiLmNvbmNhdChkaXJlY3RpdmVOYW1lLCBcIiBkaXJlY3RpdmUuXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KGRpcmVjdGl2ZUFyZ3VtZW50cyAmJiBkaXJlY3RpdmVBcmd1bWVudHMubGVuZ3RoID09PSAxLCAzOCk7XG4gICAgICAgICAgICB2YXIgaWZBcmd1bWVudCA9IGRpcmVjdGl2ZUFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChpZkFyZ3VtZW50Lm5hbWUgJiYgaWZBcmd1bWVudC5uYW1lLnZhbHVlID09PSAnaWYnLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIHRoZSBAXCIuY29uY2F0KGRpcmVjdGl2ZU5hbWUsIFwiIGRpcmVjdGl2ZS5cIikpIDogZ2xvYmFscy5pbnZhcmlhbnQoaWZBcmd1bWVudC5uYW1lICYmIGlmQXJndW1lbnQubmFtZS52YWx1ZSA9PT0gJ2lmJywgMzkpO1xuICAgICAgICAgICAgdmFyIGlmVmFsdWUgPSBpZkFyZ3VtZW50LnZhbHVlO1xuICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGlmVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoaWZWYWx1ZS5raW5kID09PSAnVmFyaWFibGUnIHx8IGlmVmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZScpLCBcIkFyZ3VtZW50IGZvciB0aGUgQFwiLmNvbmNhdChkaXJlY3RpdmVOYW1lLCBcIiBkaXJlY3RpdmUgbXVzdCBiZSBhIHZhcmlhYmxlIG9yIGEgYm9vbGVhbiB2YWx1ZS5cIikpIDogZ2xvYmFscy5pbnZhcmlhbnQoaWZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpZlZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScgfHwgaWZWYWx1ZS5raW5kID09PSAnQm9vbGVhblZhbHVlJyksIDQwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZGlyZWN0aXZlOiBkaXJlY3RpdmUsIGlmQXJndW1lbnQ6IGlmQXJndW1lbnQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQoZG9jdW1lbnQsIGZyYWdtZW50TmFtZSkge1xuICAgIHZhciBhY3R1YWxGcmFnbWVudE5hbWUgPSBmcmFnbWVudE5hbWU7XG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuICAgIGRvY3VtZW50LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJGb3VuZCBhIFwiLmNvbmNhdChkZWZpbml0aW9uLm9wZXJhdGlvbiwgXCIgb3BlcmF0aW9uXCIpLmNvbmNhdChkZWZpbml0aW9uLm5hbWUgPyBcIiBuYW1lZCAnXCIuY29uY2F0KGRlZmluaXRpb24ubmFtZS52YWx1ZSwgXCInXCIpIDogJycsIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgICdObyBvcGVyYXRpb25zIGFyZSBhbGxvd2VkIHdoZW4gdXNpbmcgYSBmcmFnbWVudCBhcyBhIHF1ZXJ5LiBPbmx5IGZyYWdtZW50cyBhcmUgYWxsb3dlZC4nKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDQxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJykge1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGFjdHVhbEZyYWdtZW50TmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50cy5sZW5ndGggPT09IDEsIFwiRm91bmQgXCIuY29uY2F0KGZyYWdtZW50cy5sZW5ndGgsIFwiIGZyYWdtZW50cy4gYGZyYWdtZW50TmFtZWAgbXVzdCBiZSBwcm92aWRlZCB3aGVuIHRoZXJlIGlzIG5vdCBleGFjdGx5IDEgZnJhZ21lbnQuXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50cy5sZW5ndGggPT09IDEsIDQyKTtcbiAgICAgICAgYWN0dWFsRnJhZ21lbnROYW1lID0gZnJhZ21lbnRzWzBdLm5hbWUudmFsdWU7XG4gICAgfVxuICAgIHZhciBxdWVyeSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkb2N1bWVudCksIHsgZGVmaW5pdGlvbnM6IHRzbGliLl9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdPcGVyYXRpb25EZWZpbml0aW9uJyxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdTZWxlY3Rpb25TZXQnLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogJ0ZyYWdtZW50U3ByZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFjdHVhbEZyYWdtZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICBdLCBkb2N1bWVudC5kZWZpbml0aW9ucywgdHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRNYXAoZnJhZ21lbnRzKSB7XG4gICAgaWYgKGZyYWdtZW50cyA9PT0gdm9pZCAwKSB7IGZyYWdtZW50cyA9IFtdOyB9XG4gICAgdmFyIHN5bVRhYmxlID0ge307XG4gICAgZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHN5bVRhYmxlW2ZyYWdtZW50Lm5hbWUudmFsdWVdID0gZnJhZ21lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bVRhYmxlO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbiwgZnJhZ21lbnRNYXApIHtcbiAgICBzd2l0Y2ggKHNlbGVjdGlvbi5raW5kKSB7XG4gICAgICAgIGNhc2UgJ0lubGluZUZyYWdtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgICAgIGNhc2UgJ0ZyYWdtZW50U3ByZWFkJzoge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZnJhZ21lbnRNYXAgJiYgZnJhZ21lbnRNYXBbc2VsZWN0aW9uLm5hbWUudmFsdWVdO1xuICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50LCBcIk5vIGZyYWdtZW50IG5hbWVkIFwiLmNvbmNhdChzZWxlY3Rpb24ubmFtZS52YWx1ZSwgXCIuXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50LCA0Myk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWZlcmVuY2UoaWQpIHtcbiAgICByZXR1cm4geyBfX3JlZjogU3RyaW5nKGlkKSB9O1xufVxuZnVuY3Rpb24gaXNSZWZlcmVuY2Uob2JqKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmouX19yZWYgPT09ICdzdHJpbmcnKTtcbn1cbmZ1bmN0aW9uIGlzRG9jdW1lbnROb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc05vbk51bGxPYmplY3QodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLmtpbmQgPT09IFwiRG9jdW1lbnRcIiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlLmRlZmluaXRpb25zKSk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdTdHJpbmdWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnQm9vbGVhblZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0ludFZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzRmxvYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnRmxvYXRWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZSc7XG59XG5mdW5jdGlvbiBpc09iamVjdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdPYmplY3RWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0xpc3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnTGlzdFZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzRW51bVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdFbnVtVmFsdWUnO1xufVxuZnVuY3Rpb24gaXNOdWxsVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ051bGxWYWx1ZSc7XG59XG5mdW5jdGlvbiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGlzSW50VmFsdWUodmFsdWUpIHx8IGlzRmxvYXRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gTnVtYmVyKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCb29sZWFuVmFsdWUodmFsdWUpIHx8IGlzU3RyaW5nVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdFZhbHVlKHZhbHVlKSkge1xuICAgICAgICB2YXIgbmVzdGVkQXJnT2JqXzEgPSB7fTtcbiAgICAgICAgdmFsdWUuZmllbGRzLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKG5lc3RlZEFyZ09ial8xLCBvYmoubmFtZSwgb2JqLnZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gbmVzdGVkQXJnT2JqXzE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmFyaWFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZVZhbHVlID0gKHZhcmlhYmxlcyB8fCB7fSlbdmFsdWUubmFtZS52YWx1ZV07XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhcmlhYmxlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTGlzdFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZXMubWFwKGZ1bmN0aW9uIChsaXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRBcmdBcnJheU9iaiA9IHt9O1xuICAgICAgICAgICAgdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKG5lc3RlZEFyZ0FycmF5T2JqLCBuYW1lLCBsaXN0VmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmVzdGVkQXJnQXJyYXlPYmpbbmFtZS52YWx1ZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0VudW1WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgX19ERVZfXyA/IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKFwiVGhlIGlubGluZSBhcmd1bWVudCBcXFwiXCIuY29uY2F0KG5hbWUudmFsdWUsIFwiXFxcIiBvZiBraW5kIFxcXCJcIikuY29uY2F0KHZhbHVlLmtpbmQsIFwiXFxcIlwiKSArXG4gICAgICAgICAgICAnaXMgbm90IHN1cHBvcnRlZC4gVXNlIHZhcmlhYmxlcyBpbnN0ZWFkIG9mIGlubGluZSBhcmd1bWVudHMgdG8gJyArXG4gICAgICAgICAgICAnb3ZlcmNvbWUgdGhpcyBsaW1pdGF0aW9uLicpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoNTIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlS2V5TmFtZUZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSB7XG4gICAgdmFyIGRpcmVjdGl2ZXNPYmogPSBudWxsO1xuICAgIGlmIChmaWVsZC5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGRpcmVjdGl2ZXNPYmogPSB7fTtcbiAgICAgICAgZmllbGQuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNPYmpbZGlyZWN0aXZlLm5hbWUudmFsdWVdID0ge307XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGRpcmVjdGl2ZXNPYmpbZGlyZWN0aXZlLm5hbWUudmFsdWVdLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBhcmdPYmogPSBudWxsO1xuICAgIGlmIChmaWVsZC5hcmd1bWVudHMgJiYgZmllbGQuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBhcmdPYmogPSB7fTtcbiAgICAgICAgZmllbGQuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09iaiwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U3RvcmVLZXlOYW1lKGZpZWxkLm5hbWUudmFsdWUsIGFyZ09iaiwgZGlyZWN0aXZlc09iaik7XG59XG52YXIgS05PV05fRElSRUNUSVZFUyA9IFtcbiAgICAnY29ubmVjdGlvbicsXG4gICAgJ2luY2x1ZGUnLFxuICAgICdza2lwJyxcbiAgICAnY2xpZW50JyxcbiAgICAncmVzdCcsXG4gICAgJ2V4cG9ydCcsXG5dO1xudmFyIGdldFN0b3JlS2V5TmFtZSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGZpZWxkTmFtZSwgYXJncywgZGlyZWN0aXZlcykge1xuICAgIGlmIChhcmdzICYmXG4gICAgICAgIGRpcmVjdGl2ZXMgJiZcbiAgICAgICAgZGlyZWN0aXZlc1snY29ubmVjdGlvbiddICYmXG4gICAgICAgIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsna2V5J10pIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ10gJiZcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ10ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcktleXMgPSBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddXG4gICAgICAgICAgICAgICAgPyBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIGZpbHRlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkQXJnc18xID0ge307XG4gICAgICAgICAgICBmaWx0ZXJLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQXJnc18xW2tleV0gPSBhcmdzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2tleSddLCBcIihcIikuY29uY2F0KHN0cmluZ2lmeShmaWx0ZXJlZEFyZ3NfMSksIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2tleSddO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb21wbGV0ZUZpZWxkTmFtZSA9IGZpZWxkTmFtZTtcbiAgICBpZiAoYXJncykge1xuICAgICAgICB2YXIgc3RyaW5naWZpZWRBcmdzID0gc3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICBjb21wbGV0ZUZpZWxkTmFtZSArPSBcIihcIi5jb25jYXQoc3RyaW5naWZpZWRBcmdzLCBcIilcIik7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKEtOT1dOX0RJUkVDVElWRVMuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlc1trZXldICYmIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXNba2V5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIuY29uY2F0KGtleSwgXCIoXCIpLmNvbmNhdChzdHJpbmdpZnkoZGlyZWN0aXZlc1trZXldKSwgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIuY29uY2F0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGVGaWVsZE5hbWU7XG59LCB7XG4gICAgc2V0U3RyaW5naWZ5OiBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBzdHJpbmdpZnk7XG4gICAgICAgIHN0cmluZ2lmeSA9IHM7XG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9LFxufSk7XG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgc3RyaW5naWZ5UmVwbGFjZXIpO1xufTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF9rZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKGNvcHksIGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGZpZWxkLmFyZ3VtZW50cyAmJiBmaWVsZC5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcmdPYmpfMSA9IHt9O1xuICAgICAgICBmaWVsZC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqXzEsIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFyZ09ial8xO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3VsdEtleU5hbWVGcm9tRmllbGQoZmllbGQpIHtcbiAgICByZXR1cm4gZmllbGQuYWxpYXMgPyBmaWVsZC5hbGlhcy52YWx1ZSA6IGZpZWxkLm5hbWUudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRUeXBlbmFtZUZyb21SZXN1bHQocmVzdWx0LCBzZWxlY3Rpb25TZXQsIGZyYWdtZW50TWFwKSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuX190eXBlbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5fX3R5cGVuYW1lO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYVtfaV07XG4gICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubmFtZS52YWx1ZSA9PT0gJ19fdHlwZW5hbWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtyZXN1bHRLZXlOYW1lRnJvbUZpZWxkKHNlbGVjdGlvbildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lID0gZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbiwgZnJhZ21lbnRNYXApLnNlbGVjdGlvblNldCwgZnJhZ21lbnRNYXApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0ZpZWxkKHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gJ0ZpZWxkJztcbn1cbmZ1bmN0aW9uIGlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSAnSW5saW5lRnJhZ21lbnQnO1xufVxuXG5mdW5jdGlvbiBjaGVja0RvY3VtZW50KGRvYykge1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChkb2MgJiYgZG9jLmtpbmQgPT09ICdEb2N1bWVudCcsIFwiRXhwZWN0aW5nIGEgcGFyc2VkIEdyYXBoUUwgZG9jdW1lbnQuIFBlcmhhcHMgeW91IG5lZWQgdG8gd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGEgXFxcImdxbFxcXCIgdGFnPyBodHRwOi8vZG9jcy5hcG9sbG9zdGFjay5jb20vYXBvbGxvLWNsaWVudC9jb3JlLmh0bWwjZ3FsXCIpIDogZ2xvYmFscy5pbnZhcmlhbnQoZG9jICYmIGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCA0NCk7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBkb2MuZGVmaW5pdGlvbnNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5raW5kICE9PSAnRnJhZ21lbnREZWZpbml0aW9uJzsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kICE9PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIlNjaGVtYSB0eXBlIGRlZmluaXRpb25zIG5vdCBhbGxvd2VkIGluIHF1ZXJpZXMuIEZvdW5kOiBcXFwiXCIuY29uY2F0KGRlZmluaXRpb24ua2luZCwgXCJcXFwiXCIpKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDQ1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9KTtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQob3BlcmF0aW9ucy5sZW5ndGggPD0gMSwgXCJBbWJpZ3VvdXMgR3JhcGhRTCBkb2N1bWVudDogY29udGFpbnMgXCIuY29uY2F0KG9wZXJhdGlvbnMubGVuZ3RoLCBcIiBvcGVyYXRpb25zXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIDQ2KTtcbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpIHtcbiAgICBjaGVja0RvY3VtZW50KGRvYyk7XG4gICAgcmV0dXJuIGRvYy5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHsgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nOyB9KVswXTtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvbk5hbWUoZG9jKSB7XG4gICAgcmV0dXJuIChkb2MuZGVmaW5pdGlvbnNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicgJiYgZGVmaW5pdGlvbi5uYW1lO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZS52YWx1ZTsgfSlbMF0gfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykge1xuICAgIHJldHVybiBkb2MuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7IHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nOyB9KTtcbn1cbmZ1bmN0aW9uIGdldFF1ZXJ5RGVmaW5pdGlvbihkb2MpIHtcbiAgICB2YXIgcXVlcnlEZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvYyk7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KHF1ZXJ5RGVmICYmIHF1ZXJ5RGVmLm9wZXJhdGlvbiA9PT0gJ3F1ZXJ5JywgJ011c3QgY29udGFpbiBhIHF1ZXJ5IGRlZmluaXRpb24uJykgOiBnbG9iYWxzLmludmFyaWFudChxdWVyeURlZiAmJiBxdWVyeURlZi5vcGVyYXRpb24gPT09ICdxdWVyeScsIDQ3KTtcbiAgICByZXR1cm4gcXVlcnlEZWY7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudERlZmluaXRpb24oZG9jKSB7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCBcIkV4cGVjdGluZyBhIHBhcnNlZCBHcmFwaFFMIGRvY3VtZW50LiBQZXJoYXBzIHlvdSBuZWVkIHRvIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFxcXCJncWxcXFwiIHRhZz8gaHR0cDovL2RvY3MuYXBvbGxvc3RhY2suY29tL2Fwb2xsby1jbGllbnQvY29yZS5odG1sI2dxbFwiKSA6IGdsb2JhbHMuaW52YXJpYW50KGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCA0OCk7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGRvYy5kZWZpbml0aW9ucy5sZW5ndGggPD0gMSwgJ0ZyYWdtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBkZWZpbml0aW9uLicpIDogZ2xvYmFscy5pbnZhcmlhbnQoZG9jLmRlZmluaXRpb25zLmxlbmd0aCA8PSAxLCA0OSk7XG4gICAgdmFyIGZyYWdtZW50RGVmID0gZG9jLmRlZmluaXRpb25zWzBdO1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChmcmFnbWVudERlZi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJywgJ011c3QgYmUgYSBmcmFnbWVudCBkZWZpbml0aW9uLicpIDogZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnREZWYua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicsIDUwKTtcbiAgICByZXR1cm4gZnJhZ21lbnREZWY7XG59XG5mdW5jdGlvbiBnZXRNYWluRGVmaW5pdGlvbihxdWVyeURvYykge1xuICAgIGNoZWNrRG9jdW1lbnQocXVlcnlEb2MpO1xuICAgIHZhciBmcmFnbWVudERlZmluaXRpb247XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHF1ZXJ5RG9jLmRlZmluaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IF9hW19pXTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gZGVmaW5pdGlvbi5vcGVyYXRpb247XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSAncXVlcnknIHx8XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID09PSAnbXV0YXRpb24nIHx8XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID09PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nICYmICFmcmFnbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIGZyYWdtZW50RGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWdtZW50RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZnJhZ21lbnREZWZpbml0aW9uO1xuICAgIH1cbiAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIGEgcGFyc2VkIEdyYXBoUUwgcXVlcnkgd2l0aCBhIHF1ZXJ5LCBtdXRhdGlvbiwgc3Vic2NyaXB0aW9uLCBvciBhIGZyYWdtZW50LicpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoNTEpO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlcyhkZWZpbml0aW9uKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBkZWZzID0gZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnM7XG4gICAgaWYgKGRlZnMgJiYgZGVmcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGRlZmF1bHRWYWx1ZXMsIGRlZi52YXJpYWJsZS5uYW1lLCBkZWYuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGFycmF5LCB0ZXN0LCBjb250ZXh0KSB7XG4gICAgdmFyIHRhcmdldCA9IDA7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICBpZiAodGVzdC5jYWxsKHRoaXMsIGVsZW0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgYXJyYXlbdGFyZ2V0KytdID0gZWxlbTtcbiAgICAgICAgfVxuICAgIH0sIGNvbnRleHQpO1xuICAgIGFycmF5Lmxlbmd0aCA9IHRhcmdldDtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBUWVBFTkFNRV9GSUVMRCA9IHtcbiAgICBraW5kOiAnRmllbGQnLFxuICAgIG5hbWU6IHtcbiAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICB2YWx1ZTogJ19fdHlwZW5hbWUnLFxuICAgIH0sXG59O1xuZnVuY3Rpb24gaXNFbXB0eShvcCwgZnJhZ21lbnRzKSB7XG4gICAgcmV0dXJuIG9wLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSAnRnJhZ21lbnRTcHJlYWQnICYmXG4gICAgICAgICAgICBpc0VtcHR5KGZyYWdtZW50c1tzZWxlY3Rpb24ubmFtZS52YWx1ZV0sIGZyYWdtZW50cyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBudWxsSWZEb2NJc0VtcHR5KGRvYykge1xuICAgIHJldHVybiBpc0VtcHR5KGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKSB8fCBnZXRGcmFnbWVudERlZmluaXRpb24oZG9jKSwgY3JlYXRlRnJhZ21lbnRNYXAoZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2MpKSlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogZG9jO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRpcmVjdGl2ZU1hdGNoZXIoZGlyZWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIChkaXIubmFtZSAmJiBkaXIubmFtZSA9PT0gZGlyZWN0aXZlLm5hbWUudmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKGRpci50ZXN0ICYmIGRpci50ZXN0KGRpcmVjdGl2ZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChkaXJlY3RpdmVzLCBkb2MpIHtcbiAgICB2YXIgdmFyaWFibGVzSW5Vc2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciB2YXJpYWJsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHZhciBmcmFnbWVudFNwcmVhZHNJblVzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIG1vZGlmaWVkRG9jID0gbnVsbElmRG9jSXNFbXB0eShncmFwaHFsLnZpc2l0KGRvYywge1xuICAgICAgICBWYXJpYWJsZToge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmtpbmQgIT09ICdWYXJpYWJsZURlZmluaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc0luVXNlW25vZGUubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEZpZWxkOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBub2RlLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlbW92ZUZpZWxkID0gZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5yZW1vdmU7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlRmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlyZWN0aXZlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXJlY3RpdmVzLnNvbWUoZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFyZy52YWx1ZS5uYW1lLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbEZyYWdtZW50U3ByZWFkc0Zyb21TZWxlY3Rpb25TZXQobm9kZS5zZWxlY3Rpb25TZXQpLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmcmFnLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGcmFnbWVudFNwcmVhZDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzSW5Vc2Vbbm9kZS5uYW1lLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBEaXJlY3RpdmU6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSkpO1xuICAgIGlmIChtb2RpZmllZERvYyAmJlxuICAgICAgICBmaWx0ZXJJblBsYWNlKHZhcmlhYmxlc1RvUmVtb3ZlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gISF2Lm5hbWUgJiYgIXZhcmlhYmxlc0luVXNlW3YubmFtZV07IH0pLmxlbmd0aCkge1xuICAgICAgICBtb2RpZmllZERvYyA9IHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudCh2YXJpYWJsZXNUb1JlbW92ZSwgbW9kaWZpZWREb2MpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWREb2MgJiZcbiAgICAgICAgZmlsdGVySW5QbGFjZShmcmFnbWVudFNwcmVhZHNUb1JlbW92ZSwgZnVuY3Rpb24gKGZzKSB7IHJldHVybiAhIWZzLm5hbWUgJiYgIWZyYWdtZW50U3ByZWFkc0luVXNlW2ZzLm5hbWVdOyB9KVxuICAgICAgICAgICAgLmxlbmd0aCkge1xuICAgICAgICBtb2RpZmllZERvYyA9IHJlbW92ZUZyYWdtZW50U3ByZWFkRnJvbURvY3VtZW50KGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlLCBtb2RpZmllZERvYyk7XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cbnZhciBhZGRUeXBlbmFtZVRvRG9jdW1lbnQgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChkb2MpIHtcbiAgICByZXR1cm4gZ3JhcGhxbC52aXNpdChkb2MsIHtcbiAgICAgICAgU2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gbm9kZS5zZWxlY3Rpb25zO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBza2lwID0gc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc0ZpZWxkKHNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24ubmFtZS52YWx1ZSA9PT0gJ19fdHlwZW5hbWUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLm5hbWUudmFsdWUubGFzdEluZGV4T2YoJ19fJywgMCkgPT09IDApKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZChmaWVsZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZGlyZWN0aXZlcyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZS52YWx1ZSA9PT0gJ2V4cG9ydCc7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBub2RlKSwgeyBzZWxlY3Rpb25zOiB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHNlbGVjdGlvbnMsIHRydWUpLCBbVFlQRU5BTUVfRklFTERdLCBmYWxzZSkgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufSwge1xuICAgIGFkZGVkOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkID09PSBUWVBFTkFNRV9GSUVMRDtcbiAgICB9LFxufSk7XG52YXIgY29ubmVjdGlvblJlbW92ZUNvbmZpZyA9IHtcbiAgICB0ZXN0OiBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciB3aWxsUmVtb3ZlID0gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdjb25uZWN0aW9uJztcbiAgICAgICAgaWYgKHdpbGxSZW1vdmUpIHtcbiAgICAgICAgICAgIGlmICghZGlyZWN0aXZlLmFyZ3VtZW50cyB8fFxuICAgICAgICAgICAgICAgICFkaXJlY3RpdmUuYXJndW1lbnRzLnNvbWUoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLm5hbWUudmFsdWUgPT09ICdrZXknOyB9KSkge1xuICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybignUmVtb3ZpbmcgYW4gQGNvbm5lY3Rpb24gZGlyZWN0aXZlIGV2ZW4gdGhvdWdoIGl0IGRvZXMgbm90IGhhdmUgYSBrZXkuICcgK1xuICAgICAgICAgICAgICAgICAgICAnWW91IG1heSB3YW50IHRvIHVzZSB0aGUga2V5IHBhcmFtZXRlciB0byBzcGVjaWZ5IGEgc3RvcmUga2V5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWxsUmVtb3ZlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudChkb2MpIHtcbiAgICByZXR1cm4gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChbY29ubmVjdGlvblJlbW92ZUNvbmZpZ10sIGNoZWNrRG9jdW1lbnQoZG9jKSk7XG59XG5mdW5jdGlvbiBnZXRBcmd1bWVudE1hdGNoZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFyZ3VtZW50TWF0Y2hlcihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLnNvbWUoZnVuY3Rpb24gKGFDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudC52YWx1ZSAmJlxuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScgJiZcbiAgICAgICAgICAgICAgICBhcmd1bWVudC52YWx1ZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgKGFDb25maWcubmFtZSA9PT0gYXJndW1lbnQudmFsdWUubmFtZS52YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAoYUNvbmZpZy50ZXN0ICYmIGFDb25maWcudGVzdChhcmd1bWVudCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudChjb25maWcsIGRvYykge1xuICAgIHZhciBhcmdNYXRjaGVyID0gZ2V0QXJndW1lbnRNYXRjaGVyKGNvbmZpZyk7XG4gICAgcmV0dXJuIG51bGxJZkRvY0lzRW1wdHkoZ3JhcGhxbC52aXNpdChkb2MsIHtcbiAgICAgICAgT3BlcmF0aW9uRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBub2RlKSwgeyB2YXJpYWJsZURlZmluaXRpb25zOiBub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMgPyBub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh2YXJEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY29uZmlnLnNvbWUoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLm5hbWUgPT09IHZhckRlZi52YXJpYWJsZS5uYW1lLnZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkgOiBbXSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEZpZWxkOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlRmllbGQgPSBjb25maWcuc29tZShmdW5jdGlvbiAoYXJnQ29uZmlnKSB7IHJldHVybiBhcmdDb25maWcucmVtb3ZlOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ01hdGNoQ291bnRfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ01hdGNoZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdNYXRjaENvdW50XzEgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hDb3VudF8xID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEFyZ3VtZW50OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hlcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50U3ByZWFkRnJvbURvY3VtZW50KGNvbmZpZywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZW50ZXIobm9kZSkge1xuICAgICAgICBpZiAoY29uZmlnLnNvbWUoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZGVmLm5hbWUgPT09IG5vZGUubmFtZS52YWx1ZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsSWZEb2NJc0VtcHR5KGdyYXBocWwudmlzaXQoZG9jLCB7XG4gICAgICAgIEZyYWdtZW50U3ByZWFkOiB7IGVudGVyOiBlbnRlciB9LFxuICAgICAgICBGcmFnbWVudERlZmluaXRpb246IHsgZW50ZXI6IGVudGVyIH0sXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0QWxsRnJhZ21lbnRTcHJlYWRzRnJvbVNlbGVjdGlvblNldChzZWxlY3Rpb25TZXQpIHtcbiAgICB2YXIgYWxsRnJhZ21lbnRzID0gW107XG4gICAgc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICgoaXNGaWVsZChzZWxlY3Rpb24pIHx8IGlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSkgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIGdldEFsbEZyYWdtZW50U3ByZWFkc0Zyb21TZWxlY3Rpb25TZXQoc2VsZWN0aW9uLnNlbGVjdGlvblNldCkuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykgeyByZXR1cm4gYWxsRnJhZ21lbnRzLnB1c2goZnJhZyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbi5raW5kID09PSAnRnJhZ21lbnRTcHJlYWQnKSB7XG4gICAgICAgICAgICBhbGxGcmFnbWVudHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFsbEZyYWdtZW50cztcbn1cbmZ1bmN0aW9uIGJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0KGRvY3VtZW50KSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSBnZXRNYWluRGVmaW5pdGlvbihkb2N1bWVudCk7XG4gICAgdmFyIGRlZmluaXRpb25PcGVyYXRpb24gPSBkZWZpbml0aW9uLm9wZXJhdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbk9wZXJhdGlvbiA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBtb2RpZmllZERvYyA9IGdyYXBocWwudmlzaXQoZG9jdW1lbnQsIHtcbiAgICAgICAgT3BlcmF0aW9uRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBub2RlKSwgeyBvcGVyYXRpb246ICdxdWVyeScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICBjaGVja0RvY3VtZW50KGRvY3VtZW50KTtcbiAgICB2YXIgbW9kaWZpZWREb2MgPSByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50KFtcbiAgICAgICAge1xuICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdjbGllbnQnOyB9LFxuICAgICAgICAgICAgcmVtb3ZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIF0sIGRvY3VtZW50KTtcbiAgICBpZiAobW9kaWZpZWREb2MpIHtcbiAgICAgICAgbW9kaWZpZWREb2MgPSBncmFwaHFsLnZpc2l0KG1vZGlmaWVkRG9jLCB7XG4gICAgICAgICAgICBGcmFnbWVudERlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUeXBlbmFtZU9ubHkgPSBub2RlLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaWVsZChzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5uYW1lLnZhbHVlID09PSAnX190eXBlbmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1R5cGVuYW1lT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWREb2M7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBtZXJnZURlZXAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBtZXJnZURlZXBBcnJheShzb3VyY2VzKTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcEFycmF5KHNvdXJjZXMpIHtcbiAgICB2YXIgdGFyZ2V0ID0gc291cmNlc1swXSB8fCB7fTtcbiAgICB2YXIgY291bnQgPSBzb3VyY2VzLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgIHZhciBtZXJnZXIgPSBuZXcgRGVlcE1lcmdlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lcmdlci5tZXJnZSh0YXJnZXQsIHNvdXJjZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG52YXIgZGVmYXVsdFJlY29uY2lsZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UodGFyZ2V0W3Byb3BlcnR5XSwgc291cmNlW3Byb3BlcnR5XSk7XG59O1xudmFyIERlZXBNZXJnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZXBNZXJnZXIocmVjb25jaWxlcikge1xuICAgICAgICBpZiAocmVjb25jaWxlciA9PT0gdm9pZCAwKSB7IHJlY29uY2lsZXIgPSBkZWZhdWx0UmVjb25jaWxlcjsgfVxuICAgICAgICB0aGlzLnJlY29uY2lsZXIgPSByZWNvbmNpbGVyO1xuICAgICAgICB0aGlzLmlzT2JqZWN0ID0gaXNOb25OdWxsT2JqZWN0O1xuICAgICAgICB0aGlzLnBhc3RDb3BpZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIERlZXBNZXJnZXIucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZXh0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0W19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vbk51bGxPYmplY3Qoc291cmNlKSAmJiBpc05vbk51bGxPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHNvdXJjZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFZhbHVlID0gdGFyZ2V0W3NvdXJjZUtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2Vbc291cmNlS2V5XSAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5yZWNvbmNpbGVyLmFwcGx5KF90aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt0YXJnZXQsIHNvdXJjZSwgc291cmNlS2V5XSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gX3RoaXMuc2hhbGxvd0NvcHlGb3JNZXJnZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VLZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy5zaGFsbG93Q29weUZvck1lcmdlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VLZXldID0gc291cmNlW3NvdXJjZUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcbiAgICBEZWVwTWVyZ2VyLnByb3RvdHlwZS5zaGFsbG93Q29weUZvck1lcmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05vbk51bGxPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFzdENvcGllcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRzbGliLl9fYXNzaWduKHsgX19wcm90b19fOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpIH0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXN0Q29waWVzLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIERlZXBNZXJnZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBjb25jYXRQYWdpbmF0aW9uKGtleUFyZ3MpIHtcbiAgICBpZiAoa2V5QXJncyA9PT0gdm9pZCAwKSB7IGtleUFyZ3MgPSBmYWxzZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleUFyZ3M6IGtleUFyZ3MsXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmcgPyB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIGV4aXN0aW5nLCB0cnVlKSwgaW5jb21pbmcsIHRydWUpIDogaW5jb21pbmc7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9mZnNldExpbWl0UGFnaW5hdGlvbihrZXlBcmdzKSB7XG4gICAgaWYgKGtleUFyZ3MgPT09IHZvaWQgMCkgeyBrZXlBcmdzID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlBcmdzOiBrZXlBcmdzLFxuICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGV4aXN0aW5nLCBpbmNvbWluZywgX2EpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX2EuYXJncztcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSBleGlzdGluZyA/IGV4aXN0aW5nLnNsaWNlKDApIDogW107XG4gICAgICAgICAgICBpZiAoaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBhcmdzLm9mZnNldCwgb2Zmc2V0ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNvbWluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW29mZnNldCArIGldID0gaW5jb21pbmdbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoLmFwcGx5KG1lcmdlZCwgaW5jb21pbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbGF5U3R5bGVQYWdpbmF0aW9uKGtleUFyZ3MpIHtcbiAgICBpZiAoa2V5QXJncyA9PT0gdm9pZCAwKSB7IGtleUFyZ3MgPSBmYWxzZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleUFyZ3M6IGtleUFyZ3MsXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChleGlzdGluZywgX2EpIHtcbiAgICAgICAgICAgIHZhciBjYW5SZWFkID0gX2EuY2FuUmVhZCwgcmVhZEZpZWxkID0gX2EucmVhZEZpZWxkO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBmaXJzdEVkZ2VDdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGxhc3RFZGdlQ3Vyc29yID0gXCJcIjtcbiAgICAgICAgICAgIGV4aXN0aW5nLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuUmVhZChyZWFkRmllbGQoXCJub2RlXCIsIGVkZ2UpKSkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RWRnZUN1cnNvciA9IGZpcnN0RWRnZUN1cnNvciB8fCBlZGdlLmN1cnNvciB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVkZ2VDdXJzb3IgPSBlZGdlLmN1cnNvciB8fCBsYXN0RWRnZUN1cnNvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9iID0gZXhpc3RpbmcucGFnZUluZm8gfHwge30sIHN0YXJ0Q3Vyc29yID0gX2Iuc3RhcnRDdXJzb3IsIGVuZEN1cnNvciA9IF9iLmVuZEN1cnNvcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZ2V0RXh0cmFzKGV4aXN0aW5nKSksIHsgZWRnZXM6IGVkZ2VzLCBwYWdlSW5mbzogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV4aXN0aW5nLnBhZ2VJbmZvKSwgeyBzdGFydEN1cnNvcjogc3RhcnRDdXJzb3IgfHwgZmlyc3RFZGdlQ3Vyc29yLCBlbmRDdXJzb3I6IGVuZEN1cnNvciB8fCBsYXN0RWRnZUN1cnNvciB9KSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcsIF9hKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IF9hLmFyZ3MsIGlzUmVmZXJlbmNlID0gX2EuaXNSZWZlcmVuY2UsIHJlYWRGaWVsZCA9IF9hLnJlYWRGaWVsZDtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZyA9IG1ha2VFbXB0eURhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5jb21pbmdFZGdlcyA9IGluY29taW5nLmVkZ2VzID8gaW5jb21pbmcuZWRnZXMubWFwKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKGVkZ2UgPSB0c2xpYi5fX2Fzc2lnbih7fSwgZWRnZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuY3Vyc29yID0gcmVhZEZpZWxkKFwiY3Vyc29yXCIsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgIH0pIDogW107XG4gICAgICAgICAgICBpZiAoaW5jb21pbmcucGFnZUluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZUluZm9fMSA9IGluY29taW5nLnBhZ2VJbmZvO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEN1cnNvciA9IHBhZ2VJbmZvXzEuc3RhcnRDdXJzb3IsIGVuZEN1cnNvciA9IHBhZ2VJbmZvXzEuZW5kQ3Vyc29yO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdEVkZ2UgPSBpbmNvbWluZ0VkZ2VzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0RWRnZSA9IGluY29taW5nRWRnZXNbaW5jb21pbmdFZGdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFZGdlICYmIHN0YXJ0Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RWRnZS5jdXJzb3IgPSBzdGFydEN1cnNvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFZGdlICYmIGVuZEN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RWRnZS5jdXJzb3IgPSBlbmRDdXJzb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEN1cnNvciA9IGZpcnN0RWRnZSAmJiBmaXJzdEVkZ2UuY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEN1cnNvciAmJiAhc3RhcnRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmcgPSBtZXJnZURlZXAoaW5jb21pbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDdXJzb3I6IGZpcnN0Q3Vyc29yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYXN0Q3Vyc29yID0gbGFzdEVkZ2UgJiYgbGFzdEVkZ2UuY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q3Vyc29yICYmICFlbmRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmcgPSBtZXJnZURlZXAoaW5jb21pbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3Vyc29yOiBsYXN0Q3Vyc29yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGV4aXN0aW5nLmVkZ2VzO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IFtdO1xuICAgICAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5hZnRlcikge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByZWZpeC5maW5kSW5kZXgoZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2UuY3Vyc29yID09PSBhcmdzLmFmdGVyOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXguc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzICYmIGFyZ3MuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcHJlZml4LmZpbmRJbmRleChmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS5jdXJzb3IgPT09IGFyZ3MuYmVmb3JlOyB9KTtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBpbmRleCA8IDAgPyBwcmVmaXggOiBwcmVmaXguc2xpY2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5jb21pbmcuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlZGdlcyA9IHRzbGliLl9fc3ByZWFkQXJyYXkodHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCBwcmVmaXgsIHRydWUpLCBpbmNvbWluZ0VkZ2VzLCB0cnVlKSwgc3VmZml4LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwYWdlSW5mbyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBpbmNvbWluZy5wYWdlSW5mbyksIGV4aXN0aW5nLnBhZ2VJbmZvKTtcbiAgICAgICAgICAgIGlmIChpbmNvbWluZy5wYWdlSW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGluY29taW5nLnBhZ2VJbmZvLCBoYXNQcmV2aW91c1BhZ2UgPSBfYi5oYXNQcmV2aW91c1BhZ2UsIGhhc05leHRQYWdlID0gX2IuaGFzTmV4dFBhZ2UsIHN0YXJ0Q3Vyc29yID0gX2Iuc3RhcnRDdXJzb3IsIGVuZEN1cnNvciA9IF9iLmVuZEN1cnNvciwgZXh0cmFzID0gdHNsaWIuX19yZXN0KF9iLCBbXCJoYXNQcmV2aW91c1BhZ2VcIiwgXCJoYXNOZXh0UGFnZVwiLCBcInN0YXJ0Q3Vyc29yXCIsIFwiZW5kQ3Vyc29yXCJdKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhZ2VJbmZvLCBleHRyYXMpO1xuICAgICAgICAgICAgICAgIGlmICghcHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBoYXNQcmV2aW91c1BhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5mby5oYXNQcmV2aW91c1BhZ2UgPSBoYXNQcmV2aW91c1BhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHN0YXJ0Q3Vyc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZm8uc3RhcnRDdXJzb3IgPSBzdGFydEN1cnNvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGhhc05leHRQYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZm8uaGFzTmV4dFBhZ2UgPSBoYXNOZXh0UGFnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZm8uZW5kQ3Vyc29yID0gZW5kQ3Vyc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZ2V0RXh0cmFzKGV4aXN0aW5nKSksIGdldEV4dHJhcyhpbmNvbWluZykpLCB7IGVkZ2VzOiBlZGdlcywgcGFnZUluZm86IHBhZ2VJbmZvIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG52YXIgZ2V0RXh0cmFzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHNsaWIuX19yZXN0KG9iaiwgbm90RXh0cmFzKTsgfTtcbnZhciBub3RFeHRyYXMgPSBbXCJlZGdlc1wiLCBcInBhZ2VJbmZvXCJdO1xuZnVuY3Rpb24gbWFrZUVtcHR5RGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZGdlczogW10sXG4gICAgICAgIHBhZ2VJbmZvOiB7XG4gICAgICAgICAgICBoYXNQcmV2aW91c1BhZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaGFzTmV4dFBhZ2U6IHRydWUsXG4gICAgICAgICAgICBzdGFydEN1cnNvcjogXCJcIixcbiAgICAgICAgICAgIGVuZEN1cnNvcjogXCJcIixcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcEhlbHBlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBjbG9uZURlZXBIZWxwZXIodmFsLCBzZWVuKSB7XG4gICAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6IHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXA7XG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXModmFsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5nZXQodmFsKTtcbiAgICAgICAgICAgIHZhciBjb3B5XzEgPSB2YWwuc2xpY2UoMCk7XG4gICAgICAgICAgICBzZWVuLnNldCh2YWwsIGNvcHlfMSk7XG4gICAgICAgICAgICBjb3B5XzEuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzFbaV0gPSBjbG9uZURlZXBIZWxwZXIoY2hpbGQsIHNlZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29weV8xO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjoge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcDtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgdmFyIGNvcHlfMiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkpO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzJba2V5XSA9IGNsb25lRGVlcEhlbHBlcih2YWxba2V5XSwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWVwRnJlZXplKHZhbHVlKSB7XG4gICAgdmFyIHdvcmtTZXQgPSBuZXcgU2V0KFt2YWx1ZV0pO1xuICAgIHdvcmtTZXQuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChpc05vbk51bGxPYmplY3Qob2JqKSAmJiBzaGFsbG93RnJlZXplKG9iaikgPT09IG9iaikge1xuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChvYmpbbmFtZV0pKVxuICAgICAgICAgICAgICAgICAgICB3b3JrU2V0LmFkZChvYmpbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzaGFsbG93RnJlZXplKG9iaikge1xuICAgIGlmIChfX0RFVl9fICYmICFPYmplY3QuaXNGcm96ZW4ob2JqKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIG1heWJlRGVlcEZyZWV6ZShvYmopIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBkZWVwRnJlZXplKG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkob2JzZXJ2ZXJzLCBtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgdmFyIG9ic2VydmVyc1dpdGhNZXRob2QgPSBbXTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnNbbWV0aG9kXSAmJiBvYnNlcnZlcnNXaXRoTWV0aG9kLnB1c2gob2JzKTsgfSk7XG4gICAgb2JzZXJ2ZXJzV2l0aE1ldGhvZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdKGFyZ3VtZW50KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGFzeW5jTWFwKG9ic2VydmFibGUsIG1hcEZuLCBjYXRjaEZuKSB7XG4gICAgcmV0dXJuIG5ldyB6ZW5PYnNlcnZhYmxlVHMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIG5leHQgPSBvYnNlcnZlci5uZXh0LCBlcnJvciA9IG9ic2VydmVyLmVycm9yLCBjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlO1xuICAgICAgICB2YXIgYWN0aXZlQ2FsbGJhY2tDb3VudCA9IDA7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByb21pc2VRdWV1ZSA9IHtcbiAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZShjYWxsYmFjaygpKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2soZXhhbWluZXIsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBpZiAoZXhhbWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICArK2FjdGl2ZUNhbGxiYWNrQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3RoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhhbWluZXIoYXJnKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVF1ZXVlID0gcHJvbWlzZVF1ZXVlLnRoZW4oYm90aCwgYm90aCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWFjdGl2ZUNhbGxiYWNrQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICYmIG5leHQuY2FsbChvYnNlcnZlciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1hY3RpdmVDYWxsYmFja0NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChjYXVnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yICYmIGVycm9yLmNhbGwob2JzZXJ2ZXIsIGNhdWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gZGVsZWdhdGUgJiYgZGVsZWdhdGUuY2FsbChvYnNlcnZlciwgYXJnKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFuZGxlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IG1ha2VDYWxsYmFjayhtYXBGbiwgbmV4dCksXG4gICAgICAgICAgICBlcnJvcjogbWFrZUNhbGxiYWNrKGNhdGNoRm4sIGVycm9yKSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUNhbGxiYWNrQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgJiYgY29tcGxldGUuY2FsbChvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgfSk7XG59XG5cbnZhciBjYW5Vc2VXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiZcbiAgICBnbG9iYWxzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0OyB9KSAhPT0gJ1JlYWN0TmF0aXZlJztcbnZhciBjYW5Vc2VXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbic7XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nO1xudmFyIGNhblVzZURPTSA9IHR5cGVvZiBnbG9iYWxzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50OyB9KSA9PT0gXCJmdW5jdGlvblwiO1xudmFyIHVzaW5nSlNET00gPSBnbG9iYWxzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImpzZG9tXCIpID49IDA7IH0pIHx8IGZhbHNlO1xudmFyIGNhblVzZUxheW91dEVmZmVjdCA9IGNhblVzZURPTSAmJiAhdXNpbmdKU0RPTTtcblxuZnVuY3Rpb24gZml4T2JzZXJ2YWJsZVN1YmNsYXNzKHN1YmNsYXNzKSB7XG4gICAgZnVuY3Rpb24gc2V0KGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViY2xhc3MsIGtleSwgeyB2YWx1ZTogemVuT2JzZXJ2YWJsZVRzLk9ic2VydmFibGUgfSk7XG4gICAgfVxuICAgIGlmIChjYW5Vc2VTeW1ib2wgJiYgU3ltYm9sLnNwZWNpZXMpIHtcbiAgICAgICAgc2V0KFN5bWJvbC5zcGVjaWVzKTtcbiAgICB9XG4gICAgc2V0KFwiQEBzcGVjaWVzXCIpO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxudmFyIENvbmNhc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDb25jYXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhc3Qoc291cmNlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7IH07XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuYWRkQ291bnQgPSAwO1xuICAgICAgICBfdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5oYW5kbGVycyA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhdGVzdCA9IFtcIm5leHRcIiwgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsIFwibmV4dFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF90aGlzLnN1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ViID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF0ZXN0ID0gW1wiZXJyb3JcIiwgZXJyb3JdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KF90aGlzLm9ic2VydmVycywgXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF90aGlzLnN1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLnNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGF0ZXN0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF0ZXN0WzBdID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoX3RoaXMubGF0ZXN0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkoX3RoaXMub2JzZXJ2ZXJzLCBcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIF90aGlzLnN1YiA9IG9icy5zdWJzY3JpYmUoX3RoaXMuaGFuZGxlcnMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IHZhbHVlLnN1YnNjcmliZShfdGhpcy5oYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZXJzLmNvbXBsZXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKF8pIHsgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzb3VyY2VzID0gW25ldyB6ZW5PYnNlcnZhYmxlVHMuT2JzZXJ2YWJsZShzb3VyY2VzKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2Uoc291cmNlcykpIHtcbiAgICAgICAgICAgIHNvdXJjZXMudGhlbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgcmV0dXJuIF90aGlzLnN0YXJ0KGl0ZXJhYmxlKTsgfSwgX3RoaXMuaGFuZGxlcnMuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnQoc291cmNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXN0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChzb3VyY2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YiAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNvdXJjZXMgPSBBcnJheS5mcm9tKHNvdXJjZXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5kZWxpdmVyTGFzdE1lc3NhZ2UgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0KSB7XG4gICAgICAgICAgICB2YXIgbmV4dE9yRXJyb3IgPSB0aGlzLmxhdGVzdFswXTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYnNlcnZlcltuZXh0T3JFcnJvcl07XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwob2JzZXJ2ZXIsIHRoaXMubGF0ZXN0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN1YiA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIG5leHRPckVycm9yID09PSBcIm5leHRcIiAmJlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2FzdC5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5oYXMob2JzZXJ2ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGl2ZXJMYXN0TWVzc2FnZShvYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgKyt0aGlzLmFkZENvdW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlciwgcXVpZXRseSkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKSAmJlxuICAgICAgICAgICAgLS10aGlzLmFkZENvdW50IDwgMSAmJlxuICAgICAgICAgICAgIXF1aWV0bHkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2FzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBvbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IG9uY2UsXG4gICAgICAgICAgICBlcnJvcjogb25jZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBvbmNlLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmFkZENvdW50O1xuICAgICAgICB0aGlzLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgdGhpcy5hZGRDb3VudCA9IGNvdW50O1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhc3Q7XG59KHplbk9ic2VydmFibGVUcy5PYnNlcnZhYmxlKSk7XG5maXhPYnNlcnZhYmxlU3ViY2xhc3MoQ29uY2FzdCk7XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSB7XG4gICAgcmV0dXJuIChyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkgfHwgZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3QoKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwcmVmaXhDb3VudHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBtYWtlVW5pcXVlSWQocHJlZml4KSB7XG4gICAgdmFyIGNvdW50ID0gcHJlZml4Q291bnRzLmdldChwcmVmaXgpIHx8IDE7XG4gICAgcHJlZml4Q291bnRzLnNldChwcmVmaXgsIGNvdW50ICsgMSk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCI6XCIpLmNvbmNhdChjb3VudCwgXCI6XCIpLmNvbmNhdChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUZvckRpc3BsYXkodmFsdWUpIHtcbiAgICB2YXIgdW5kZWZJZCA9IG1ha2VVbmlxdWVJZChcInN0cmluZ2lmeUZvckRpc3BsYXlcIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHVuZGVmSWQgOiB2YWx1ZTtcbiAgICB9KS5zcGxpdChKU09OLnN0cmluZ2lmeSh1bmRlZklkKSkuam9pbihcIjx1bmRlZmluZWQ+XCIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tcGFjdChkZWZhdWx0cywgb3B0aW9ucywgb3B0aW9ucy52YXJpYWJsZXMgJiYge1xuICAgICAgICB2YXJpYWJsZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCAoZGVmYXVsdHMgJiYgZGVmYXVsdHMudmFyaWFibGVzKSksIG9wdGlvbnMudmFyaWFibGVzKSxcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5ERVYgPSBnbG9iYWxzLkRFVjtcbmV4cG9ydHMubWF5YmUgPSBnbG9iYWxzLm1heWJlO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gemVuT2JzZXJ2YWJsZVRzLk9ic2VydmFibGU7XG5leHBvcnRzLkNvbmNhc3QgPSBDb25jYXN0O1xuZXhwb3J0cy5EZWVwTWVyZ2VyID0gRGVlcE1lcmdlcjtcbmV4cG9ydHMuYWRkVHlwZW5hbWVUb0RvY3VtZW50ID0gYWRkVHlwZW5hbWVUb0RvY3VtZW50O1xuZXhwb3J0cy5hcmd1bWVudHNPYmplY3RGcm9tRmllbGQgPSBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQ7XG5leHBvcnRzLmFzeW5jTWFwID0gYXN5bmNNYXA7XG5leHBvcnRzLmJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0ID0gYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQ7XG5leHBvcnRzLmNhblVzZURPTSA9IGNhblVzZURPTTtcbmV4cG9ydHMuY2FuVXNlTGF5b3V0RWZmZWN0ID0gY2FuVXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy5jYW5Vc2VTeW1ib2wgPSBjYW5Vc2VTeW1ib2w7XG5leHBvcnRzLmNhblVzZVdlYWtNYXAgPSBjYW5Vc2VXZWFrTWFwO1xuZXhwb3J0cy5jYW5Vc2VXZWFrU2V0ID0gY2FuVXNlV2Vha1NldDtcbmV4cG9ydHMuY2hlY2tEb2N1bWVudCA9IGNoZWNrRG9jdW1lbnQ7XG5leHBvcnRzLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbmV4cG9ydHMuY29tcGFjdCA9IGNvbXBhY3Q7XG5leHBvcnRzLmNvbmNhdFBhZ2luYXRpb24gPSBjb25jYXRQYWdpbmF0aW9uO1xuZXhwb3J0cy5jcmVhdGVGcmFnbWVudE1hcCA9IGNyZWF0ZUZyYWdtZW50TWFwO1xuZXhwb3J0cy5maXhPYnNlcnZhYmxlU3ViY2xhc3MgPSBmaXhPYnNlcnZhYmxlU3ViY2xhc3M7XG5leHBvcnRzLmdldERlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzO1xuZXhwb3J0cy5nZXREaXJlY3RpdmVOYW1lcyA9IGdldERpcmVjdGl2ZU5hbWVzO1xuZXhwb3J0cy5nZXRGcmFnbWVudERlZmluaXRpb24gPSBnZXRGcmFnbWVudERlZmluaXRpb247XG5leHBvcnRzLmdldEZyYWdtZW50RGVmaW5pdGlvbnMgPSBnZXRGcmFnbWVudERlZmluaXRpb25zO1xuZXhwb3J0cy5nZXRGcmFnbWVudEZyb21TZWxlY3Rpb24gPSBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb247XG5leHBvcnRzLmdldEZyYWdtZW50UXVlcnlEb2N1bWVudCA9IGdldEZyYWdtZW50UXVlcnlEb2N1bWVudDtcbmV4cG9ydHMuZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyA9IGdldEluY2x1c2lvbkRpcmVjdGl2ZXM7XG5leHBvcnRzLmdldE1haW5EZWZpbml0aW9uID0gZ2V0TWFpbkRlZmluaXRpb247XG5leHBvcnRzLmdldE9wZXJhdGlvbkRlZmluaXRpb24gPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uO1xuZXhwb3J0cy5nZXRPcGVyYXRpb25OYW1lID0gZ2V0T3BlcmF0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0UXVlcnlEZWZpbml0aW9uID0gZ2V0UXVlcnlEZWZpbml0aW9uO1xuZXhwb3J0cy5nZXRTdG9yZUtleU5hbWUgPSBnZXRTdG9yZUtleU5hbWU7XG5leHBvcnRzLmdldFR5cGVuYW1lRnJvbVJlc3VsdCA9IGdldFR5cGVuYW1lRnJvbVJlc3VsdDtcbmV4cG9ydHMuZ3JhcGhRTFJlc3VsdEhhc0Vycm9yID0gZ3JhcGhRTFJlc3VsdEhhc0Vycm9yO1xuZXhwb3J0cy5oYXNDbGllbnRFeHBvcnRzID0gaGFzQ2xpZW50RXhwb3J0cztcbmV4cG9ydHMuaGFzRGlyZWN0aXZlcyA9IGhhc0RpcmVjdGl2ZXM7XG5leHBvcnRzLmlzRG9jdW1lbnROb2RlID0gaXNEb2N1bWVudE5vZGU7XG5leHBvcnRzLmlzRmllbGQgPSBpc0ZpZWxkO1xuZXhwb3J0cy5pc0lubGluZUZyYWdtZW50ID0gaXNJbmxpbmVGcmFnbWVudDtcbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuZXhwb3J0cy5pc05vbk51bGxPYmplY3QgPSBpc05vbk51bGxPYmplY3Q7XG5leHBvcnRzLmlzUmVmZXJlbmNlID0gaXNSZWZlcmVuY2U7XG5leHBvcnRzLml0ZXJhdGVPYnNlcnZlcnNTYWZlbHkgPSBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5O1xuZXhwb3J0cy5tYWtlUmVmZXJlbmNlID0gbWFrZVJlZmVyZW5jZTtcbmV4cG9ydHMubWFrZVVuaXF1ZUlkID0gbWFrZVVuaXF1ZUlkO1xuZXhwb3J0cy5tYXliZURlZXBGcmVlemUgPSBtYXliZURlZXBGcmVlemU7XG5leHBvcnRzLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbmV4cG9ydHMubWVyZ2VEZWVwQXJyYXkgPSBtZXJnZURlZXBBcnJheTtcbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xuZXhwb3J0cy5vZmZzZXRMaW1pdFBhZ2luYXRpb24gPSBvZmZzZXRMaW1pdFBhZ2luYXRpb247XG5leHBvcnRzLnJlbGF5U3R5bGVQYWdpbmF0aW9uID0gcmVsYXlTdHlsZVBhZ2luYXRpb247XG5leHBvcnRzLnJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudCA9IHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCA9IHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQ7XG5leHBvcnRzLnJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQgPSByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50O1xuZXhwb3J0cy5yZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50ID0gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQgPSByZW1vdmVGcmFnbWVudFNwcmVhZEZyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVzdWx0S2V5TmFtZUZyb21GaWVsZCA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQ7XG5leHBvcnRzLnNob3VsZEluY2x1ZGUgPSBzaG91bGRJbmNsdWRlO1xuZXhwb3J0cy5zdG9yZUtleU5hbWVGcm9tRmllbGQgPSBzdG9yZUtleU5hbWVGcm9tRmllbGQ7XG5leHBvcnRzLnN0cmluZ2lmeUZvckRpc3BsYXkgPSBzdHJpbmdpZnlGb3JEaXNwbGF5O1xuZXhwb3J0cy52YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24gPSB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsaXRpZXMuY2pzLm1hcFxuIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBhZGRCYXNlUGF0aCxcbiAgYWRkTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmxldCBjYWNoZWRPYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBNYXA8RWxlbWVudCwgKCkgPT4gdm9pZD4oKVxuY29uc3QgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA6IG51bGxcbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcigpOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IHVuZGVmaW5lZCB7XG4gIC8vIFJldHVybiBzaGFyZWQgaW5zdGFuY2Ugb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaWYgYWxyZWFkeSBjcmVhdGVkXG4gIGlmIChjYWNoZWRPYnNlcnZlcikge1xuICAgIHJldHVybiBjYWNoZWRPYnNlcnZlclxuICB9XG5cbiAgLy8gT25seSBjcmVhdGUgc2hhcmVkIEludGVyc2VjdGlvbk9ic2VydmVyIGlmIHN1cHBvcnRlZCBpbiBicm93c2VyXG4gIGlmICghSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gKGNhY2hlZE9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmICghbGlzdGVuZXJzLmhhcyhlbnRyeS50YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYiA9IGxpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KSFcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMCkge1xuICAgICAgICAgIGNhY2hlZE9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpXG4gICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShlbnRyeS50YXJnZXQpXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgeyByb290TWFyZ2luOiAnMjAwcHgnIH1cbiAgKSlcbn1cblxuY29uc3QgbGlzdGVuVG9JbnRlcnNlY3Rpb25zID0gKGVsOiBFbGVtZW50LCBjYjogKCkgPT4gdm9pZCkgPT4ge1xuICBjb25zdCBvYnNlcnZlciA9IGdldE9ic2VydmVyKClcbiAgaWYgKCFvYnNlcnZlcikge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbClcbiAgbGlzdGVuZXJzLnNldChlbCwgY2IpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgIH1cbiAgICBsaXN0ZW5lcnMuZGVsZXRlKGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWZldGNoKFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgb3B0aW9ucz86IFByZWZldGNoT3B0aW9uc1xuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KSB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldFxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0EnICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgIWlzTG9jYWxVUkwoaHJlZikpKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBlLnByZXZlbnREZWZhdWx0KClcblxuICAvLyAgYXZvaWQgc2Nyb2xsIGZvciB1cmxzIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKHNjcm9sbCA9PSBudWxsKSB7XG4gICAgc2Nyb2xsID0gYXMuaW5kZXhPZignIycpIDwgMFxuICB9XG5cbiAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShocmVmLCBhcywgeyBzaGFsbG93IH0pLnRoZW4oXG4gICAgKHN1Y2Nlc3M6IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICghc3VjY2VzcykgcmV0dXJuXG4gICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKClcbiAgICAgIH1cbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gTGluayhwcm9wczogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48TGlua1Byb3BzPikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzW2tleV0gJiZcbiAgICAgICAgICB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB0eXBlb2YgcHJvcHNba2V5XSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdwcmVmZXRjaCdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB0eXBlb2YgcHJvcHNba2V5XSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgaGFzV2FybmVkID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcbiAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWQnXG4gICAgICApXG4gICAgfVxuICB9XG4gIGNvbnN0IHAgPSBwcm9wcy5wcmVmZXRjaCAhPT0gZmFsc2VcblxuICBjb25zdCBbY2hpbGRFbG0sIHNldENoaWxkRWxtXSA9IFJlYWN0LnVzZVN0YXRlPEVsZW1lbnQ+KClcblxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuICBjb25zdCBwYXRobmFtZSA9IChyb3V0ZXIgJiYgcm91dGVyLnBhdGhuYW1lKSB8fCAnLydcblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5ocmVmLCB0cnVlKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogcHJvcHMuYXNcbiAgICAgICAgPyByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuYXMpXG4gICAgICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbcGF0aG5hbWUsIHByb3BzLmhyZWYsIHByb3BzLmFzXSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIHAgJiZcbiAgICAgIEludGVyc2VjdGlvbk9ic2VydmVyICYmXG4gICAgICBjaGlsZEVsbSAmJlxuICAgICAgY2hpbGRFbG0udGFnTmFtZSAmJlxuICAgICAgaXNMb2NhbFVSTChocmVmKVxuICAgICkge1xuICAgICAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9IHByZWZldGNoZWRbaHJlZiArICclJyArIGFzXVxuICAgICAgaWYgKCFpc1ByZWZldGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlblRvSW50ZXJzZWN0aW9ucyhjaGlsZEVsbSwgKCkgPT4ge1xuICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbcCwgY2hpbGRFbG0sIGhyZWYsIGFzLCByb3V0ZXJdKVxuXG4gIGxldCB7IGNoaWxkcmVuLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwgfSA9IHByb3BzXG4gIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZHJlbiBwcm92aWRlZCBpcyBhIHN0cmluZyAoPExpbms+ZXhhbXBsZTwvTGluaz4pIHdlIHdyYXAgaXQgaW4gYW4gPGE+IHRhZ1xuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBjb25zdCBjaGlsZDogYW55ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiAoZWw6IGFueSkgPT4ge1xuICAgICAgaWYgKGVsKSBzZXRDaGlsZEVsbShlbClcblxuICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZC5yZWYoZWwpXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGQucmVmLmN1cnJlbnQgPSBlbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgIH1cbiAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbClcbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgaWYgKHApIHtcbiAgICBjaGlsZFByb3BzLm9uTW91c2VFbnRlciA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgICB9XG4gICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7IHByaW9yaXR5OiB0cnVlIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICBpZiAocHJvcHMucGFzc0hyZWYgfHwgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpKSB7XG4gICAgY2hpbGRQcm9wcy5ocmVmID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoYXMsIHJvdXRlciAmJiByb3V0ZXIubG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua1xuIiwiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggaWYgdGhlcmUgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIHJvb3QgcGF0aCBgL2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGB0cmFpbGluZ1NsYXNoYCBvcHRpb25cbiAqIGluIGBuZXh0LmNvbmZpZy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSFxuICA/IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nXG4gICAgICB9XG4gICAgfVxuICA6IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbiAgJ2xvY2FsZScsXG4gICdsb2NhbGVzJyxcbiAgJ2RlZmF1bHRMb2NhbGUnLFxuXVxuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAncm91dGVDaGFuZ2VTdGFydCcsXG4gICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAnaGFzaENoYW5nZUNvbXBsZXRlJyxcbl1cbmNvbnN0IGNvcmVNZXRob2RGaWVsZHMgPSBbXG4gICdwdXNoJyxcbiAgJ3JlcGxhY2UnLFxuICAncmVsb2FkJyxcbiAgJ2JhY2snLFxuICAncHJlZmV0Y2gnLFxuICAnYmVmb3JlUG9wU3RhdGUnLFxuXVxuXG4vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCAnZXZlbnRzJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5ldmVudHNcbiAgfSxcbn0pXG5cbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgZmllbGQsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdIGFzIHN0cmluZ1xuICAgIH0sXG4gIH0pXG59KVxuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKSA9PiB7XG4gICAgUm91dGVyLmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKFxuICAgICAgICAxXG4gICAgICApfWBcbiAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXIgYXMgYW55XG4gICAgICBpZiAoX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBnZXRSb3V0ZXIoKTogUm91dGVyIHtcbiAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgK1xuICAgICAgJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJ1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIEV4cG9ydCB0aGUgc2luZ2xldG9uUm91dGVyIGFuZCB0aGlzIGlzIHRoZSBwdWJsaWMgQVBJLlxuZXhwb3J0IGRlZmF1bHQgc2luZ2xldG9uUm91dGVyIGFzIFNpbmdsZXRvblJvdXRlclxuXG4vLyBSZWV4cG9ydCB0aGUgd2l0aFJvdXRlIEhPQ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoUm91dGVyIH0gZnJvbSAnLi93aXRoLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcigpOiBOZXh0Um91dGVyIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbn1cblxuLy8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG5cbi8vIENyZWF0ZSBhIHJvdXRlciBhbmQgYXNzaWduIGl0IGFzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXG4vLyBUaGlzIGlzIHVzZWQgaW4gY2xpZW50IHNpZGUgd2hlbiB3ZSBhcmUgaW5pdGlsaXppbmcgdGhlIGFwcC5cbi8vIFRoaXMgc2hvdWxkICoqbm90KiogdXNlIGluc2lkZSB0aGUgc2VydmVyLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlciA9ICguLi5hcmdzOiBSb3V0ZXJBcmdzKTogUm91dGVyID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBSb3V0ZXIoLi4uYXJncylcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MgPSBbXVxuXG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgdGhlIGB3aXRoUm91dGVyYCByb3V0ZXIgaW5zdGFuY2VcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyOiBSb3V0ZXIpOiBOZXh0Um91dGVyIHtcbiAgY29uc3QgX3JvdXRlciA9IHJvdXRlciBhcyBhbnlcbiAgY29uc3QgaW5zdGFuY2UgPSB7fSBhcyBhbnlcblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKSB7XG4gICAgaWYgKHR5cGVvZiBfcm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIEFycmF5LmlzQXJyYXkoX3JvdXRlcltwcm9wZXJ0eV0pID8gW10gOiB7fSxcbiAgICAgICAgX3JvdXRlcltwcm9wZXJ0eV1cbiAgICAgICkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcltwcm9wZXJ0eV1cbiAgfVxuXG4gIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbiAgaW5zdGFuY2UuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gIGNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHJldHVybiBfcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRDb21wb25lbnRUeXBlLCBOZXh0UGFnZUNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyLCB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcblxuZXhwb3J0IHR5cGUgV2l0aFJvdXRlclByb3BzID0ge1xuICByb3V0ZXI6IE5leHRSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgRXhjbHVkZVJvdXRlclByb3BzPFA+ID0gUGljazxcbiAgUCxcbiAgRXhjbHVkZTxrZXlvZiBQLCBrZXlvZiBXaXRoUm91dGVyUHJvcHM+XG4+XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhSb3V0ZXI8XG4gIFAgZXh0ZW5kcyBXaXRoUm91dGVyUHJvcHMsXG4gIEMgPSBOZXh0UGFnZUNvbnRleHRcbj4oXG4gIENvbXBvc2VkQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxDLCBhbnksIFA+XG4pOiBSZWFjdC5Db21wb25lbnRUeXBlPEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPj4ge1xuICBmdW5jdGlvbiBXaXRoUm91dGVyV3JhcHBlcihwcm9wczogYW55KSB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIEphc29uIE1pbGxlciAoaHR0cHM6Ly9qYXNvbmZvcm1hdC5jb20vKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvdjEuMS4zL3NyYy9pbmRleC5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCBmb3IgdGhlIG5lZWRzIG9mIHRoaXMgc2NyaXB0XG4vLyBTZWUgdGhlIExJQ0VOU0UgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZVxuXG50eXBlIEhhbmRsZXIgPSAoLi4uZXZ0czogYW55W10pID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgTWl0dEVtaXR0ZXIgPSB7XG4gIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKTogdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KCk6IE1pdHRFbWl0dGVyIHtcbiAgY29uc3QgYWxsOiB7IFtzOiBzdHJpbmddOiBIYW5kbGVyW10gfSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICByZXR1cm4ge1xuICAgIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgOyhhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICBpZiAoYWxsW3R5cGVdKSB7XG4gICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgOyhhbGxbdHlwZV0gfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyOiBIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoLi4uZXZ0cylcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuIiwiLyogZ2xvYmFsIF9fTkVYVF9EQVRBX18gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHJlc29sdmVSZXdyaXRlcyBmcm9tICcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcbmltcG9ydCBlc2NhcGVQYXRoRGVsaW1pdGVycyBmcm9tICcuL3V0aWxzL2VzY2FwZS1wYXRoLWRlbGltaXRlcnMnXG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9IG51bGwgfCB7IF9fTjogZmFsc2UgfSB8ICh7IF9fTjogdHJ1ZSB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHByZWZpeCAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKVxuICAgID8gcGF0aCA9PT0gJy8nXG4gICAgICA/IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeClcbiAgICAgIDogYCR7cHJlZml4fSR7cGF0aH1gXG4gICAgOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9pMThuX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSlcbiAgICAgID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGg6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfaTE4bl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlKVxuICAgICAgPyBwYXRoLnN1YnN0cihsb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aCkgfHwgJy8nXG59XG5cbi8qKlxuICogRGV0ZWN0cyB3aGV0aGVyIGEgZ2l2ZW4gdXJsIGlzIHJvdXRhYmxlIGJ5IHRoZSBOZXh0LmpzIHJvdXRlciAoYnJvd3NlciBvbmx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG50eXBlIFVybCA9IFVybE9iamVjdCB8IHN0cmluZ1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgYXNQYXRobmFtZTogc3RyaW5nLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbikge1xuICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJ1xuXG4gIGNvbnN0IGR5bmFtaWNSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzXG4gIGNvbnN0IGR5bmFtaWNNYXRjaGVzID1cbiAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHxcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnlcblxuICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpXG5cbiAgaWYgKFxuICAgICFwYXJhbXMuZXZlcnkoKHBhcmFtKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJydcbiAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV1cblxuICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gXG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYFxuICAgICAgfVxuICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmXG4gICAgICAgIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPVxuICAgICAgICAgIGludGVycG9sYXRlZFJvdXRlIS5yZXBsYWNlKFxuICAgICAgICAgICAgcmVwbGFjZWQsXG4gICAgICAgICAgICByZXBlYXRcbiAgICAgICAgICAgICAgPyAodmFsdWUgYXMgc3RyaW5nW10pLm1hcChlc2NhcGVQYXRoRGVsaW1pdGVycykuam9pbignLycpXG4gICAgICAgICAgICAgIDogZXNjYXBlUGF0aERlbGltaXRlcnModmFsdWUgYXMgc3RyaW5nKVxuICAgICAgICAgICkgfHwgJy8nKVxuICAgICAgKVxuICAgIH0pXG4gICkge1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcblxuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgfVxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlLFxuICB9XG59XG5cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeTogUGFyc2VkVXJsUXVlcnksIHBhcmFtczogc3RyaW5nW10pIHtcbiAgY29uc3QgZmlsdGVyZWRRdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuXG4gIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gZmlsdGVyZWRRdWVyeVxufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgZ2l2ZW4gaHlwZXJsaW5rIHdpdGggYSBjZXJ0YWluIHJvdXRlciBzdGF0ZSAoYmFzZVBhdGggbm90IGluY2x1ZGVkKS5cbiAqIFByZXNlcnZlcyBhYnNvbHV0ZSB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhyZWYoXG4gIGN1cnJlbnRQYXRoOiBzdHJpbmcsXG4gIGhyZWY6IFVybCxcbiAgcmVzb2x2ZUFzPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgY29uc3QgYmFzZSA9IG5ldyBVUkwoY3VycmVudFBhdGgsICdodHRwOi8vbicpXG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmNvbnN0IFBBR0VfTE9BRF9FUlJPUiA9IFN5bWJvbCgnUEFHRV9MT0FEX0VSUk9SJylcbmV4cG9ydCBmdW5jdGlvbiBtYXJrTG9hZGluZ0Vycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBQQUdFX0xPQURfRVJST1IsIHt9KVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM6IFVybCkge1xuICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IGFkZEJhc2VQYXRoKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgdXJsKSksXG4gICAgYXM6IGFzID8gYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCBhcykpIDogYXMsXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8UHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbywgQXBwOiBBcHBDb21wb25lbnQpID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeVxuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZjogc3RyaW5nLCBpc1NlcnZlclJlbmRlcjogYm9vbGVhbikge1xuICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3AuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0xvYWRpbmdFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgc2RjOiB7IFthc1BhdGg6IHN0cmluZ106IG9iamVjdCB9ID0ge31cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IGFueVxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXJcbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcbiAgX3NoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGluaXRpYWxTdHlsZVNoZWV0cyxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsb2NhbGUsXG4gICAgICBsb2NhbGVzLFxuICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBpbml0aWFsU3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge31cbiAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0czogaW5pdGlhbFN0eWxlU2hlZXRzLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgIENvbXBvbmVudDogQXBwIGFzIENvbXBvbmVudFR5cGUsXG4gICAgICBzdHlsZVNoZWV0czogW1xuICAgICAgICAvKiAvX2FwcCBkb2VzIG5vdCBuZWVkIGl0cyBzdHlsZXNoZWV0cyBtYW5hZ2VkICovXG4gICAgICBdLFxuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgdGhpcy5hc1BhdGggPVxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIHRlbXBvcmFyaWx5IGdsb2JhbCAoYXR0YWNoZWQgdG8gd2luZG93KVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIF9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfaTE4bl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxuICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlc1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcblxuICAgICAgICAgIGxldCBzY3JvbGxEZWJvdW5jZVRpbWVvdXQ6IHVuZGVmaW5lZCB8IE5vZGVKUy5UaW1lb3V0XG5cbiAgICAgICAgICBjb25zdCBkZWJvdW5jZWRTY3JvbGxTYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbERlYm91bmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHNjcm9sbERlYm91bmNlVGltZW91dClcblxuICAgICAgICAgICAgc2Nyb2xsRGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBhczogY3VyQXMsIG9wdGlvbnMgfSA9IGhpc3Rvcnkuc3RhdGVcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY3VyQXMsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgX05fWDogd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICBfTl9ZOiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LCAxMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZGVib3VuY2VkU2Nyb2xsU2F2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zIH0gPSBzdGF0ZVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzOiBVcmwgPSB1cmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICB9XG4gICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlKVxuICAgIH1cblxuICAgIGFzID0gYWRkTG9jYWxlKGFzLCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgdGhpcy5sb2NhbGVcbiAgICApXG4gICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzXG5cbiAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykpIHtcbiAgICAgIHRoaXMuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKVxuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuICAgIGNvbnN0IHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5wcm9taXNlZEJ1aWxkTWFuaWZlc3RcblxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgPyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpXG4gICAgICA6IHBhdGhuYW1lXG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSkge1xuICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICB9XG5cbiAgICBsZXQgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgIHJlc29sdmVkQXMgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIHBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lLFxuICAgICAgICBwYWdlcyxcbiAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gdGhpcy5fcmVzb2x2ZUhyZWYoeyBwYXRobmFtZTogcCB9LCBwYWdlcykucGF0aG5hbWUhXG4gICAgICApXG5cbiAgICAgIGlmIChyZXNvbHZlZEFzICE9PSBhcykge1xuICAgICAgICBjb25zdCBwb3RlbnRpYWxIcmVmID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQsIHsgcGF0aG5hbWU6IHJlc29sdmVkQXMgfSksXG4gICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKS5wYXRobmFtZSFcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBvdGVudGlhbEhyZWYpKSB7XG4gICAgICAgICAgcm91dGUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGF0aG5hbWUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgc2hhbGxvd1xuICAgICAgKVxuICAgICAgbGV0IHsgZXJyb3IsIHByb3BzLCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIChfX05fU1NHIHx8IF9fTl9TU1ApICYmXG4gICAgICAgIHByb3BzICYmXG4gICAgICAgIChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcyAmJlxuICAgICAgICAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkSHJlZiwgcGFnZXMpXG5cbiAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcbiAgICAgICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsLFxuICAgICAgICBhZGRMb2NhbGUoYXMsIHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFwcENvbXA6IGFueSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnRcbiAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5uZXh0LmlzUHJlcmVuZGVyZWQgPVxuICAgICAgICAgIGFwcENvbXAuZ2V0SW5pdGlhbFByb3BzID09PSBhcHBDb21wLm9yaWdHZXRJbml0aWFsUHJvcHMgJiZcbiAgICAgICAgICAhKHJvdXRlSW5mby5Db21wb25lbnQgYXMgYW55KS5nZXRJbml0aWFsUHJvcHNcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zZXQocm91dGUsIHBhdGhuYW1lISwgcXVlcnksIGNsZWFuZWRBcywgcm91dGVJbmZvKS5jYXRjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIGVycm9yID0gZXJyb3IgfHwgZVxuICAgICAgICAgIGVsc2UgdGhyb3cgZVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gJiYgJ19OX1gnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oKG9wdGlvbnMgYXMgYW55KS5fTl9YLCAob3B0aW9ucyBhcyBhbnkpLl9OX1kpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChQQUdFX0xPQURfRVJST1IgaW4gZXJyIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgJy9fZXJyb3InXG4gICAgICApXG4gICAgICBjb25zdCByb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycixcbiAgICAgICAgZXJyb3I6IGVycixcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICB9IGFzIGFueSlcbiAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKHJvdXRlSW5mb0VyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cblxuICAgICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRSb3V0ZUluZm9cbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBQcml2YXRlUm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgID8gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSkpXG5cbiAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGFIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgaWYgKF9fTl9TU0cgfHwgX19OX1NTUCkge1xuICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBkZWxCYXNlUGF0aChhcyksXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZSxcbiAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGE8UHJpdmF0ZVJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgX19OX1NTR1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgPyB0aGlzLl9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mb1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWVcbiAgICBpZiAoaGFzaCA9PT0gJycpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoaWRFbCkge1xuICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF1cbiAgICBpZiAobmFtZUVsKSB7XG4gICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIF9yZXNvbHZlSHJlZihwYXJzZWRIcmVmOiBVcmxPYmplY3QsIHBhZ2VzOiBzdHJpbmdbXSwgYXBwbHlCYXNlUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRIcmVmXG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgZGVub3JtYWxpemVQYWdlUGF0aChhcHBseUJhc2VQYXRoID8gZGVsQmFzZVBhdGgocGF0aG5hbWUhKSA6IHBhdGhuYW1lISlcbiAgICApXG5cbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lISkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmXG4gICAgICAgICAgZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUhKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gYXBwbHlCYXNlUGF0aCA/IGFkZEJhc2VQYXRoKHBhZ2UpIDogcGFnZVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRIcmVmXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSB9ID0gcGFyc2VkXG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLnByZWZldGNoRGF0YShcbiAgICAgICAgdXJsLFxuICAgICAgICBhc1BhdGgsXG4gICAgICAgIHRoaXMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICksXG4gICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgXSlcbiAgfVxuXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPEdvb2RQYWdlQ2FjaGU+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAodGhpcy5jbGMgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfSlcblxuICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U3RhdGljRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1tjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbY2FjaGVLZXldKVxuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpXG4gIH1cblxuICBnZXRJbml0aWFsUHJvcHMoXG4gICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlLFxuICAgIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddXG4gICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwIGFzIEFwcENvbXBvbmVudClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGFib3J0Q29tcG9uZW50TG9hZChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIGFzKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KGRhdGE6IFByaXZhdGVSb3V0ZUluZm8pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCBhcyBBcHBDb21wb25lbnQpXG4gIH1cbn1cbiIsIi8vIGVzY2FwZSBkZWxpbWl0ZXJzIHVzZWQgYnkgcGF0aC10by1yZWdleHBcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzY2FwZVBhdGhEZWxpbWl0ZXJzKHNlZ21lbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1svIz9dL2csIChjaGFyOiBzdHJpbmcpID0+IGVuY29kZVVSSUNvbXBvbmVudChjaGFyKSlcbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBEVU1NWV9CQVNFID0gbmV3IFVSTChcbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogZ2V0TG9jYXRpb25PcmlnaW4oKVxuKVxuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIERVTU1ZX0JBU0UpIDogRFVNTVlfQkFTRVxuICBjb25zdCB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWYsXG4gICAgb3JpZ2luLFxuICAgIHByb3RvY29sLFxuICB9ID0gbmV3IFVSTCh1cmwsIHJlc29sdmVkQmFzZSlcbiAgaWYgKFxuICAgIG9yaWdpbiAhPT0gRFVNTVlfQkFTRS5vcmlnaW4gfHxcbiAgICAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwnKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKERVTU1ZX0JBU0Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIGRlbGltaXRlcjogJy8nLFxufVxuXG5leHBvcnQgY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIC4uLm1hdGNoZXJPcHRpb25zLFxuICBzdHJpY3Q6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IChjdXN0b21Sb3V0ZSA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qga2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgICBjb25zdCBtYXRjaGVyUmVnZXggPSBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKFxuICAgICAgcGF0aCxcbiAgICAgIGtleXMsXG4gICAgICBjdXN0b21Sb3V0ZSA/IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMgOiBtYXRjaGVyT3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBtYXRjaGVyID0gcGF0aFRvUmVnZXhwLnJlZ2V4cFRvRnVuY3Rpb24obWF0Y2hlclJlZ2V4LCBrZXlzKVxuXG4gICAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBwYXRobmFtZSA9PSBudWxsID8gZmFsc2UgOiBtYXRjaGVyKHBhdGhuYW1lKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21Sb3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgLy8gdW5uYW1lZCBwYXJhbXMgc2hvdWxkIGJlIHJlbW92ZWQgYXMgdGhleVxuICAgICAgICAgIC8vIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5Lm5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWxldGUgKHJlcy5wYXJhbXMgYXMgYW55KVtrZXkubmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5yZXMucGFyYW1zIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbnR5cGUgUGFyYW1zID0geyBbcGFyYW06IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmVEZXN0aW5hdGlvbihcbiAgZGVzdGluYXRpb246IHN0cmluZyxcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgYXBwZW5kUGFyYW1zVG9RdWVyeTogYm9vbGVhbixcbiAgYmFzZVBhdGg6IHN0cmluZ1xuKSB7XG4gIGxldCBwYXJzZWREZXN0aW5hdGlvbjoge1xuICAgIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbiAgICBwcm90b2NvbD86IHN0cmluZ1xuICAgIGhvc3RuYW1lPzogc3RyaW5nXG4gICAgcG9ydD86IHN0cmluZ1xuICB9ICYgUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VSZWxhdGl2ZVVybD4gPSB7fSBhcyBhbnlcblxuICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9ID0gbmV3IFVSTChkZXN0aW5hdGlvbilcblxuICAgIHBhcnNlZERlc3RpbmF0aW9uID0ge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgICAgaGFzaCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0UXVlcnkgPSBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeVxuICBjb25zdCBkZXN0UGF0aCA9IGAke3BhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIX0ke1xuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggfHwgJydcbiAgfWBcbiAgY29uc3QgZGVzdFBhdGhQYXJhbUtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gIHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoZGVzdFBhdGgsIGRlc3RQYXRoUGFyYW1LZXlzKVxuXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1zID0gZGVzdFBhdGhQYXJhbUtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKVxuXG4gIGxldCBkZXN0aW5hdGlvbkNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUoXG4gICAgZGVzdFBhdGgsXG4gICAgLy8gd2UgZG9uJ3QgdmFsaWRhdGUgd2hpbGUgY29tcGlsaW5nIHRoZSBkZXN0aW5hdGlvbiBzaW5jZSB3ZSBzaG91bGRcbiAgICAvLyBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZSB3ZSBnb3QgdG8gdGhpcyBwb2ludCBhbmQgdmFsaWRhdGluZ1xuICAgIC8vIGJyZWFrcyBjb21waWxpbmcgZGVzdGluYXRpb25zIHdpdGggbmFtZWQgcGF0dGVybiBwYXJhbXMgZnJvbSB0aGUgc291cmNlXG4gICAgLy8gZS5nLiAvc29tZXRoaW5nOmhlbGxvKC4qKSAtPiAvYW5vdGhlci86aGVsbG8gaXMgYnJva2VuIHdpdGggdmFsaWRhdGlvblxuICAgIC8vIHNpbmNlIGNvbXBpbGUgdmFsaWRhdGlvbiBpcyBtZWFudCBmb3IgcmV2ZXJzaW5nIGFuZCBub3QgZm9yIGluc2VydGluZ1xuICAgIC8vIHBhcmFtcyBmcm9tIGEgc2VwYXJhdGUgcGF0aC1yZWdleCBpbnRvIGFub3RoZXJcbiAgICB7IHZhbGlkYXRlOiBmYWxzZSB9XG4gIClcbiAgbGV0IG5ld1VybFxuXG4gIC8vIHVwZGF0ZSBhbnkgcGFyYW1zIGluIHF1ZXJ5IHZhbHVlc1xuICBmb3IgKGNvbnN0IFtrZXksIHN0ck9yQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKGRlc3RRdWVyeSkpIHtcbiAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHN0ck9yQXJyYXkpID8gc3RyT3JBcnJheVswXSA6IHN0ck9yQXJyYXlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAgICAgLy8gY29ycmVjdGx5XG4gICAgICB2YWx1ZSA9IGAvJHt2YWx1ZX1gXG4gICAgICBjb25zdCBxdWVyeUNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUodmFsdWUsIHsgdmFsaWRhdGU6IGZhbHNlIH0pXG4gICAgICB2YWx1ZSA9IHF1ZXJ5Q29tcGlsZXIocGFyYW1zKS5zdWJzdHIoMSlcbiAgICB9XG4gICAgZGVzdFF1ZXJ5W2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgLy8gYWRkIHBhdGggcGFyYW1zIHRvIHF1ZXJ5IGlmIGl0J3Mgbm90IGEgcmVkaXJlY3QgYW5kIG5vdFxuICAvLyBhbHJlYWR5IGRlZmluZWQgaW4gZGVzdGluYXRpb24gcXVlcnkgb3IgcGF0aFxuICBjb25zdCBwYXJhbUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpXG5cbiAgaWYgKFxuICAgIGFwcGVuZFBhcmFtc1RvUXVlcnkgJiZcbiAgICAhcGFyYW1LZXlzLnNvbWUoKGtleSkgPT4gZGVzdFBhdGhQYXJhbXMuaW5jbHVkZXMoa2V5KSlcbiAgKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1LZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVzdFF1ZXJ5KSkge1xuICAgICAgICBkZXN0UXVlcnlba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2hvdWxkQWRkQmFzZVBhdGggPSBkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgYmFzZVBhdGhcblxuICB0cnkge1xuICAgIG5ld1VybCA9IGAke3Nob3VsZEFkZEJhc2VQYXRoID8gYmFzZVBhdGggOiAnJ30ke2Rlc3RpbmF0aW9uQ29tcGlsZXIoXG4gICAgICBwYXJhbXNcbiAgICApfWBcblxuICAgIGNvbnN0IFtwYXRobmFtZSwgaGFzaF0gPSBuZXdVcmwuc3BsaXQoJyMnKVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoID0gYCR7aGFzaCA/ICcjJyA6ICcnfSR7aGFzaCB8fCAnJ31gXG4gICAgZGVsZXRlIHBhcnNlZERlc3RpbmF0aW9uLnNlYXJjaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0V4cGVjdGVkIC4qPyB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5LykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRvIHVzZSBhIG11bHRpLW1hdGNoIGluIHRoZSBkZXN0aW5hdGlvbiB5b3UgbXVzdCBhZGQgXFxgKlxcYCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBuYW1lIHRvIHNpZ25pZnkgaXQgc2hvdWxkIHJlcGVhdC4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1tdWx0aS1tYXRjaGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBRdWVyeSBtZXJnZSBvcmRlciBsb3dlc3QgcHJpb3JpdHkgdG8gaGlnaGVzdFxuICAvLyAxLiBpbml0aWFsIFVSTCBxdWVyeSB2YWx1ZXNcbiAgLy8gMi4gcGF0aCBzZWdtZW50IHZhbHVlc1xuICAvLyAzLiBkZXN0aW5hdGlvbiBzcGVjaWZpZWQgcXVlcnkgdmFsdWVzXG4gIHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5ID0ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIC4uLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdVcmwsXG4gICAgcGFyc2VkRGVzdGluYXRpb24sXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHBhdGhNYXRjaCBmcm9tICcuL3BhdGgtbWF0Y2gnXG5pbXBvcnQgcHJlcGFyZURlc3RpbmF0aW9uIGZyb20gJy4vcHJlcGFyZS1kZXN0aW5hdGlvbidcbmltcG9ydCB7IFJld3JpdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbG9hZC1jdXN0b20tcm91dGVzJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuXG5jb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXIgPSBwYXRoTWF0Y2godHJ1ZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJld3JpdGVzKFxuICBhc1BhdGg6IHN0cmluZyxcbiAgcGFnZXM6IHN0cmluZ1tdLFxuICBiYXNlUGF0aDogc3RyaW5nLFxuICByZXdyaXRlczogUmV3cml0ZVtdLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIHJlc29sdmVIcmVmOiAocGF0aDogc3RyaW5nKSA9PiBzdHJpbmdcbikge1xuICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGFzUGF0aCkpIHtcbiAgICBmb3IgKGNvbnN0IHJld3JpdGUgb2YgcmV3cml0ZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBjdXN0b21Sb3V0ZU1hdGNoZXIocmV3cml0ZS5zb3VyY2UpXG4gICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaGVyKGFzUGF0aClcblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBpZiAoIXJld3JpdGUuZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgcHJveGllZCByZXdyaXRlIHdoaWNoIGlzbid0IGhhbmRsZWQgb24gdGhlIGNsaWVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdFJlcyA9IHByZXBhcmVEZXN0aW5hdGlvbihcbiAgICAgICAgICByZXdyaXRlLmRlc3RpbmF0aW9uLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHJld3JpdGUuYmFzZVBhdGggPT09IGZhbHNlID8gJycgOiBiYXNlUGF0aFxuICAgICAgICApXG4gICAgICAgIGFzUGF0aCA9IGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGFzUGF0aCkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSByZXdyaXRlc1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBtYXRjaCBhIGR5bmFtaWMtcm91dGUsIGlmIHNvIHdlIGJyZWFrIHRoZSByZXdyaXRlcyBjaGFpblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSByZXNvbHZlSHJlZihhc1BhdGgpXG5cbiAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gYXNQYXRoICYmIHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhc1BhdGhcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4vcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBNYW5pZmVzdEl0ZW0gfSBmcm9tICcuLi9zZXJ2ZXIvbG9hZC1jb21wb25lbnRzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB7IEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9zZXJ2ZXIvZ2V0LXBhZ2UtZmlsZXMnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBIZWFkRW50cnkgPSBbc3RyaW5nLCB7IFtrZXk6IHN0cmluZ106IGFueSB9XVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgaGVhZDogSGVhZEVudHJ5W11cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBhbnlcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcblxudmFyIGdlbmVyaWNNZXNzYWdlID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7XG52YXIgX2EgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIHNldFByb3RvdHlwZU9mID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChvYmosIHByb3RvKSB7XG4gICAgb2JqLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBvYmo7XG59IDogX2E7XG52YXIgSW52YXJpYW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEludmFyaWFudEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludmFyaWFudEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gZ2VuZXJpY01lc3NhZ2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZW9mIG1lc3NhZ2UgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8gZ2VuZXJpY01lc3NhZ2UgKyBcIjogXCIgKyBtZXNzYWdlICsgXCIgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9pbnZhcmlhbnQtcGFja2FnZXMpXCJcbiAgICAgICAgICAgIDogbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZnJhbWVzVG9Qb3AgPSAxO1xuICAgICAgICBfdGhpcy5uYW1lID0gZ2VuZXJpY01lc3NhZ2U7XG4gICAgICAgIHNldFByb3RvdHlwZU9mKF90aGlzLCBJbnZhcmlhbnRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbnZhcmlhbnRFcnJvcjtcbn0oRXJyb3IpKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IobWVzc2FnZSk7XG4gICAgfVxufVxudmFyIHZlcmJvc2l0eUxldmVscyA9IFtcImRlYnVnXCIsIFwibG9nXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwic2lsZW50XCJdO1xudmFyIHZlcmJvc2l0eUxldmVsID0gdmVyYm9zaXR5TGV2ZWxzLmluZGV4T2YoXCJsb2dcIik7XG5mdW5jdGlvbiB3cmFwQ29uc29sZU1ldGhvZChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZlcmJvc2l0eUxldmVscy5pbmRleE9mKG5hbWUpID49IHZlcmJvc2l0eUxldmVsKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGNvbnNvbGUubG9nIGlmIHRoaXMgaG9zdCBlbnZpcm9ubWVudCBoYXBwZW5zIG5vdCB0byBwcm92aWRlXG4gICAgICAgICAgICAvLyBhbGwgdGhlIGNvbnNvbGUuKiBtZXRob2RzIHdlIG5lZWQuXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc29sZVtuYW1lXSB8fCBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4oZnVuY3Rpb24gKGludmFyaWFudCkge1xuICAgIGludmFyaWFudC5kZWJ1ZyA9IHdyYXBDb25zb2xlTWV0aG9kKFwiZGVidWdcIik7XG4gICAgaW52YXJpYW50LmxvZyA9IHdyYXBDb25zb2xlTWV0aG9kKFwibG9nXCIpO1xuICAgIGludmFyaWFudC53YXJuID0gd3JhcENvbnNvbGVNZXRob2QoXCJ3YXJuXCIpO1xuICAgIGludmFyaWFudC5lcnJvciA9IHdyYXBDb25zb2xlTWV0aG9kKFwiZXJyb3JcIik7XG59KShpbnZhcmlhbnQgfHwgKGludmFyaWFudCA9IHt9KSk7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHkobGV2ZWwpIHtcbiAgICB2YXIgb2xkID0gdmVyYm9zaXR5TGV2ZWxzW3ZlcmJvc2l0eUxldmVsXTtcbiAgICB2ZXJib3NpdHlMZXZlbCA9IE1hdGgubWF4KDAsIHZlcmJvc2l0eUxldmVscy5pbmRleE9mKGxldmVsKSk7XG4gICAgcmV0dXJuIG9sZDtcbn1cbnZhciBpbnZhcmlhbnQkMSA9IGludmFyaWFudDtcblxuZXhwb3J0cy5JbnZhcmlhbnRFcnJvciA9IEludmFyaWFudEVycm9yO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpbnZhcmlhbnQkMTtcbmV4cG9ydHMuaW52YXJpYW50ID0gaW52YXJpYW50O1xuZXhwb3J0cy5zZXRWZXJib3NpdHkgPSBzZXRWZXJib3NpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhcmlhbnQuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBtYXliZSh0aHVuaykge1xuICB0cnkgeyByZXR1cm4gdGh1bmsoKSB9IGNhdGNoIChfKSB7fVxufVxuXG52YXIgc2FmZUdsb2JhbCA9IChcbiAgbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBnbG9iYWxUaGlzIH0pIHx8XG4gIG1heWJlKGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93IH0pIHx8XG4gIG1heWJlKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZiB9KSB8fFxuICBtYXliZShmdW5jdGlvbigpIHsgcmV0dXJuIGdsb2JhbCB9KSB8fFxuICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGV2ZXIgdG8gYmUgaW52b2tlZCBhdCBydW50aW1lLCBhc1xuICAvLyBsb25nIGFzIGF0IGxlYXN0IG9uZSBvZiBnbG9iYWxUaGlzLCB3aW5kb3csIHNlbGYsIG9yIGdsb2JhbCBpcyBkZWZpbmVkLCBzb1xuICAvLyB3ZSBhcmUgdW5kZXIgbm8gb2JsaWdhdGlvbiB0byBtYWtlIGl0IGVhc3kgZm9yIHN0YXRpYyBhbmFseXNpcyB0b29scyB0b1xuICAvLyBkZXRlY3Qgc3ludGFjdGljIHVzYWdlIG9mIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3Rvci4gSWYgeW91IHRoaW5rIHlvdSBjYW5cbiAgLy8gaW1wcm92ZSB5b3VyIHN0YXRpYyBhbmFseXNpcyB0byBkZXRlY3QgdGhpcyBvYmZ1c2NhdGlvbiwgdGhpbmsgYWdhaW4uIFRoaXNcbiAgLy8gaXMgYW4gYXJtcyByYWNlIHlvdSBjYW5ub3Qgd2luLCBhdCBsZWFzdCBub3QgaW4gSmF2YVNjcmlwdC5cbiAgbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXliZS5jb25zdHJ1Y3RvcihcInJldHVybiB0aGlzXCIpKCkgfSlcbik7XG5cbnZhciBuZWVkVG9SZW1vdmUgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgaWYgKHNhZmVHbG9iYWwgJiZcbiAgICAgICFtYXliZShmdW5jdGlvbigpIHsgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WIH0pICYmXG4gICAgICAhbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9jZXNzIH0pKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNhZmVHbG9iYWwsIFwicHJvY2Vzc1wiLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAvLyBUaGlzIGRlZmF1bHQgbmVlZHMgdG8gYmUgXCJwcm9kdWN0aW9uXCIgaW5zdGVhZCBvZiBcImRldmVsb3BtZW50XCIsIHRvXG4gICAgICAgICAgLy8gYXZvaWQgdGhlIHByb2JsZW0gaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9wdWxsLzI4OTRcbiAgICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgc29sdmUsIG9uY2UgbWVyZ2VkIGFuZCByZWxlYXNlZC5cbiAgICAgICAgICBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgLy8gTGV0IGFueW9uZSBlbHNlIGNoYW5nZSBnbG9iYWwucHJvY2VzcyBhcyB0aGV5IHNlZSBmaXQsIGJ1dCBoaWRlIGl0IGZyb21cbiAgICAgIC8vIE9iamVjdC5rZXlzKGdsb2JhbCkgZW51bWVyYXRpb24uXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIG5lZWRUb1JlbW92ZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gQ2FsbCBpbnN0YWxsKCkgYXQgbGVhc3Qgb25jZSwgd2hlbiB0aGlzIG1vZHVsZSBpcyBpbXBvcnRlZC5cbmluc3RhbGwoKTtcblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICBpZiAobmVlZFRvUmVtb3ZlKSB7XG4gICAgZGVsZXRlIHNhZmVHbG9iYWwucHJvY2VzcztcbiAgICBuZWVkVG9SZW1vdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmluc3RhbGwgPSBpbnN0YWxsO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmNqcy5tYXBcbiIsImV4cG9ydHMuT2JzZXJ2YWJsZSA9IHJlcXVpcmUoXCJ6ZW4tb2JzZXJ2YWJsZS9pbmRleC5qc1wiKTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgQ2FydCBmcm9tIFwiLi4vY29tcG9uZW50cy9jYXJ0XCJcclxuaW1wb3J0IHtBcG9sbG9Qcm92aWRlciwgQXBvbGxvQ2xpZW50LCBIdHRwTGluaywgSW5NZW1vcnlDYWNoZX0gZnJvbSAnQGFwb2xsby9jbGllbnQnO1xyXG5pbXBvcnQgUmVzdGF1cmFudExpc3QgZnJvbSAnLi4vY29tcG9uZW50cy9yZXN0YXVyYW50TGlzdCc7XHJcbmltcG9ydCB7IElucHV0R3JvdXAsIElucHV0R3JvdXBBZGRvbiwgSW5wdXR9IGZyb20gXCJyZWFjdHN0cmFwXCI7XHJcblxyXG5cclxuY29uc3QgSG9tZSA9ICgpID0+IHtcclxuICBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MTMzN1wiO1xyXG4gIGNvbnNvbGUubG9nKGBVUkw6ICR7QVBJX1VSTH1gKVxyXG4gIGNvbnN0IFtxdWVyeSwgc2V0UXVlcnldID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgbGluayA9IG5ldyBIdHRwTGluayh7IHVyaTogYCR7QVBJX1VSTH0vZ3JhcGhxbGB9KVxyXG4gIGNvbnN0IGNhY2hlID0gbmV3IEluTWVtb3J5Q2FjaGUoKVxyXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBBcG9sbG9DbGllbnQoe2xpbmssY2FjaGV9KTtcclxuXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICAgIDxBcG9sbG9Qcm92aWRlciBjbGllbnQ9e2NsaWVudH0+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWFyY2hcIj5cclxuICAgICAgICAgICAgPGgyPiBMb2NhbCBSZXN0YXVyYW50czwvaDI+XHJcbiAgICAgICAgICAgICAgPElucHV0R3JvdXAgPlxyXG4gICAgICAgICAgICAgIDxJbnB1dEdyb3VwQWRkb24gYWRkb25UeXBlPVwiYXBwZW5kXCI+IFNlYXJjaCA8L0lucHV0R3JvdXBBZGRvbj5cclxuICAgICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICBzZXRRdWVyeShlLnRhcmdldC52YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtxdWVyeX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDwvSW5wdXRHcm91cD48YnI+PC9icj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPFJlc3RhdXJhbnRMaXN0IHNlYXJjaD17cXVlcnl9IC8+XHJcbiAgICAgICAgICA8Q2FydD4gPC9DYXJ0PlxyXG4gICAgICA8L0Fwb2xsb1Byb3ZpZGVyPlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvbWU7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQHdyeS9jb250ZXh0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkB3cnkvZXF1YWxpdHlcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQHdyeS90cmllXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdyYXBocWxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ3JhcGhxbC10YWdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9yb3V0ZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3B0aW1pc21cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3QtaXNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RzdHJhcFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHlsZWQtanN4L3N0eWxlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN5bWJvbC1vYnNlcnZhYmxlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRzbGliXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInplbi1vYnNlcnZhYmxlL2luZGV4LmpzXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=